<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BTC Study</title>
  
  <subtitle>学习比特币</subtitle>
  <link href="https://www.btcstudy.org/atom.xml" rel="self"/>
  
  <link href="https://www.btcstudy.org/"/>
  <updated>2023-01-12T06:01:27.495Z</updated>
  <id>https://www.btcstudy.org/</id>
  
  <author>
    <name>btcstudy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于 Statechain 的闪电网络通道</title>
    <link href="https://www.btcstudy.org/2023/01/12/statechain-lightning-combined-in-bitcoin/"/>
    <id>https://www.btcstudy.org/2023/01/12/statechain-lightning-combined-in-bitcoin/</id>
    <published>2023-01-12T03:19:57.000Z</published>
    <updated>2023-01-12T06:01:27.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：SHINOBI</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/statechain-lightning-combined-in-bitcoin">https://bitcoinmagazine.com/technical/statechain-lightning-combined-in-bitcoin</a></em></p></blockquote><p>去年我写过 <a href="https://bitcoinmagazine.com/technical/a-new-privacy-tool-for-bitcoin">Commerceblock 团队开发的 Mercury Wallet</a> 功能，这是一种 <a href="https://bitcoinmagazine.com/technical/statechains-sending-keys-not-coins-to-scale-bitcoin-off-chain">statechain</a> 和 <a href="https://en.bitcoin.it/wiki/CoinSwap">CoinSwap</a> 的双料实现。它既引入一种新的混币工具，又是第一种实现了 statechain 这种新的二层扩展方案的钱包。他们团队在 Ruben Somsen 的原始 statechain 提议基础上作了一些变更，使得没有 <a href="https://bitcoinmagazine.com/technical/how-sighash-anyprevout-and-eltoo-could-improve-the-lightning-network">ANYPREVOUT/Eltoo sighash flag</a> 也能正常实现 statechain，还整合一种新的 CoinSwap 设计，让用户可以多次混币而无需在链上交互。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>给尚未读过我前一篇文章的读者简单总结一下：statechain 是一种离链机制，用于在完全离链的任何人之间免费地转账。资金的原始所有者跟一个 statechain 运营者合作，构造一个 ECDSA-MPC 地址，该地址的私钥是分成两半的，一半在用户手里，另一半在运营者手里，然后双方要一起构造一个带有时间锁的取款交易并签好名，再然后用户再把钱打到这个地址里去。</p><p>没有任何一方完整控制这个私钥，而且用户拿着一个预先签好名的交易，因此可以在时间锁解锁后单方面拿回这些资金。当用户希望转移这笔资产时，他们就通知运营者，后者跟支付的接收方合作，一起创建新的一组私钥碎片（但跟原来的私钥碎片有相同的地产），然后生成另一笔带有时间锁（且时间锁更短）的交易并签名；最后，运营者删除上一份私钥的碎片。</p><p>如此一来，现在运营者手上的私钥碎片，将仅能与资金的新主人手上的私钥碎片结合，所以只要他们删除了旧的私钥碎片，他们就无法与资金的旧主人一起花费资金。此外，越新的取款交易，其时间锁越短，因此资金的新主人总是能比旧主人更快取走资金。这种机制限制了 statechain 资金可以转移的次数，到点了就必须取出（否则便有可能被旧主人取走）。</p><h2 id="基于-statechain-的闪电通道"><a href="#基于-statechain-的闪电通道" class="headerlink" title="基于 statechain 的闪电通道"></a>基于 statechain 的闪电通道</h2><p>Commerceblock 现在正在撰写一个<a href="https://github.com/commerceblock/blip-XXXX/blob/main/blip-XXXX.md">新的 BLIP</a>（比特币闪电网络升级提议），以实现一种在 Somsen 的最初提议中便提出的东西：在一笔 statechain 资金上建立一条闪电通道。</p><p>statechain 自身的一个缺点在于，每次转移时，都是整个 UTXO 一起转移的。但是，假如 statechain 的取款交易不是把资金转移到一个普通用户的地址中，而是转到一条闪电通道中呢？那么 statechain 自交的一部分就可以通过通道的初始余额分布来传输，而这条通道随后便可按常规发起闪电支付。</p><p>整个流程也从一名用户创建一笔 statechain 资金起步。创建者和这个 Statechain 的运营者走一遍常规流程：创建共有私钥，并签名带有时间锁的区块交易；然后创建者（Alice）找到一个愿意接受 statechain 资金的通道对手方（Bob）。Alice 和 Bob 一起，如法炮制 Alice 与运营者一起分割私钥的流程，创建出他们自己的共有公钥。然后，俩人都把他们的共有公钥和个人公钥碎片分享给这个 Statechain 的运营者。这使得运营者可以质询他们，让他们各自签名并证明自己同意按最新的余额合作关闭 statechain，而不必等候 statechain 的取款时间锁过期。</p><p>从这里开始，有了 Bob 的授权，Alice 和这个 Statechain 的运营者就可以签名一笔交易，将 statechain 中的资金直接花费到一个多签名的闪电通道中，并处理闪电网络通道的创建流程（译者注：这条通道是 Alice 和 Bob 的通道）。这时候，这个 Statechain 地址依然控制在 Alice 和运营者手中，但开启闪电通道的交易现在到了 Bob 手上，而且其时间锁比最初那笔取款交易更短，保证了这笔交易可以在 Alice 单方面关闭这个 Statechain 之前就生效。然后，Alice 和 Bob 跟运营者完成最后一次更新，使用他们的共有公钥跟运营者创建一笔将 statechain 资金花费到 Alice-Bob 通道的取款交易（译者注：常规的 statechain 转账，让 Alice 和 Bob 的共有公钥变成这个 statechain 的新主人），并且这笔取款交易的时间锁更短。现在，Alice 和 Bob 可以向外公布自己有一条闪电通道了。</p><p>（译者注：这套协议的目的是基于一笔 statechain 资金，在当前所有者和意向支付者之间创建一条通道，从而允许当前所有者分割 statechian 资金、仅支付部分资金给意向支付者。在协议结束后，相关的 Statechain 将不再属于原主人（在这里是 Alice），因为跟 Alice 匹配的私钥碎片已被运营者销毁；取而代之的是 Alice-Bob 的通道。</p><p>（译者注：它的缺点，或者说尚不完备的地方，在于 Alice 其实无法把通道（或者说自己剩下的余额）全部转给 Carol，因为这需要把 Alice 和 Bob 在通道内发生的所有交互的记录都转移给 Carol，否则 Alice 和 Bob 可以串谋欺诈 Carol；但这里没有设计保证 Alice 转移了所有资料的机制，这需要 Alice/Bob 在每次发起闪电支付之后，都提交一个承诺。不过，基于上文所述的原理，也可以考虑将它实现为多方参与的 coinpool，而不是两方参与的闪电通道。）</p><h2 id="提升-statechain-的效用"><a href="#提升-statechain-的效用" class="headerlink" title="提升 statechain 的效用"></a>提升 statechain 的效用</h2><p>这一提议将大大提升 statechain 的效用，因为它放宽了 statechain 原本严格的流动性要求。不论什么时候某人想接受一笔 statechain 资金但发现面额跟支付额不匹配，发送者都可以通过跟 TA 开启一条闪电通道来解决这个问题，直到某一方花完自己剩下的资金（或者说通道中的资金全部属于其中一方），再完成一笔转移全部 statechain 资金的转账。这样的可能性不仅提升了 statechain 的用途，也提高了闪电网络的效用（如果这套协议得到合理的支持的话）。</p><p>通道内余额的再平衡，对闪电网络中的节点是必要的功能，不论你是路由节点还是仅仅收发交易的边缘节点。当通道内的资金全部移动到了通道的一段，这条通道就失去了向某个方向传递支付的作用（如果所有资金都在你这边，你就没法通过这条通道收取支付了；如果所有资金都在你的对手那边，那你就没办法使用这条通道来支付了）。所以，你需要把一条通道中的资金移动到另一条通道中，通过引起别的通道的失衡来重新平衡你自己的通道。最终，这样的动态会以某处的通道必须在闪电网络和链上交换资金收尾。</p><p>Statechain 则允许流动性像在链上移动那样，但又不需要创建链上的足迹，也不必为此支付手续费。假设你有一条枯竭的通道，所有的余额都在你的对手那边，你已经没有可以花费的容量了，同时你又有一个 Statechain 资金。那么，你可以把这笔 Statechain 资金转移给任何愿意接受的人，假如你不能花费全部的 Statechain 资金，那么你可以在它之上建立一条闪电通道，而且这条通道也可以用来再平衡你的普通闪电通道。</p><p>从再平衡你的通道需要经过的通道数量上看，这将允许提升效率（别忘了，当你要再平衡你的通道时，它会让资金流经的每一条通道都失衡），最优的情况下，你可以直接将资金发送给同一个对手，从而再平衡你的通道。如果你希望关闭某一条通道，跟另一个人开启另一条通道，你甚至可以将此通道中的所有余额都再平衡掉、全部转移到你跟新对手基于 statechain 建立的新通道中。</p><h2 id="Statechain-和闪电网络的未来"><a href="#Statechain-和闪电网络的未来" class="headerlink" title="Statechain 和闪电网络的未来"></a>Statechain 和闪电网络的未来</h2><p>在讨论他们未来的计划是，Commerceblock 的 Nicolas Gregory 说：“我们的计划是建立一套结合 statechain 和闪电网络技术的标准方法，从而协助闪电网络通过使用 state channel 在链下完成再平衡。当前的这套规范将成为实现这一目标的基石。”</p><p>在一开始，statechain 就被提议跟闪电网络结合，以解决它自身的一个问题：在支付时必须转移整个 UTXO 的价值。这也为闪电网络提供了一定程度的灵活性，因为闪电网络没有自身的流动性管理方法。</p><p>现在，闪电网络已经处在早期增长的健康阶段，而一份可靠的 statechain 实现也已经存在超过一年了，所以，是时候考虑结合两者了。闪电网络，作为一个网络，是一个可在任意没有直接联系的两方之间自动化处理转账的系统。至于网络图谱中的各通道的内部是如何工作的，严格来说，对于发送者和接收者，都是无关紧要的；只要建立通道的两方自己过得去就行。</p><p>Statechain 和闪电通道都给对方提供了许多好处，我们需要做的，就是开发出让两者交互的标准化方法。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">在一笔 statechain 资金上建立一条闪电通道</summary>
    
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Statechain" scheme="https://www.btcstudy.org/tags/Statechain/"/>
    
  </entry>
  
  <entry>
    <title>RGB 协议的设计</title>
    <link href="https://www.btcstudy.org/2023/01/10/overview-of-the-main-concepts-and-features-of-the-rgb-design/"/>
    <id>https://www.btcstudy.org/2023/01/10/overview-of-the-main-concepts-and-features-of-the-rgb-design/</id>
    <published>2023-01-10T08:34:40.000Z</published>
    <updated>2023-01-12T06:01:27.485Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Federico Tenga</em></p><p><em>来源：<a href="https://docs.rgb.info/design">https://docs.rgb.info/design</a></em></p></blockquote><h3 id="一次性密封条"><a href="#一次性密封条" class="headerlink" title="一次性密封条"></a>一次性密封条</h3><p>实体的 “一次性密封” 是一种带有唯一编码的塑料带，通常用于检测存储和运输过程中的篡改。举个例子，当你在一个运输集装箱的门上锁好一个一次性密封条之后，如果你在再次开门的时候，发现印着自己预期中的号码的密封条完好无损，那么你就可以确信在运输期间没有人打开过这个集装箱（假设制造一个一模一样的密封条是足够困难的）。</p><p><img src="/../images/overview-of-the-main-concepts-and-features-of-the-rgb-design/single-use-seals.png" alt="single-use-seals"></p><p>类似地，使用电子的一次性密封条（最早由 <a href="https://petertodd.org/2016/state-machine-consensus-building-blocks">Peter Todd 在 2016 年</a>提出），你可以对一条消息锁上一个电子密封条，确保这条消息只能被使用一次。举个例子，假设这条消息是某块土地的所有权证书，要是没有一次性密封系统，我可以对许多人展示这个证书，并说服每一个人我对这块土地有充分的权利，然后一地多卖。在证书上应用一次性密封条，我们可以将打开密封条的操作定义成卖出土地的必要步骤，因此，卖方就没有办法把同一块土地卖给多个人；一旦 TA 尝试这么做，第二个买方就会注意到这块土地已经卖出了，因为电子密封条已经打开过了。</p><p>实现电子化一次性密封条的一种简单方法是设置一个公证服务端，每当某一个密封条打开或者锁上时就在公开的注册处发布证书，这样任何人都能验证自己关心的密封条的状态。但是，这种设置需要用户信任这个公证服务端，因此，希望实现免信任性和抗审查性的协议不能使用这种方法。</p><h3 id="基于比特币的一次性密封条"><a href="#基于比特币的一次性密封条" class="headerlink" title="基于比特币的一次性密封条"></a>基于比特币的一次性密封条</h3><p>不必使用一个受信任的实体来证明电子密封条的开启和关闭，我们可以使用比特币的<strong>未花费的交易输出</strong>（<a href="https://en.bitcoin.it/wiki/UTXO">UTXOs</a>）作为密封条。实际上，一个 UTXO 就可以被视为一个密封条：在创建它的时候，密封条锁上；在花费它的时候，密封条打开。根据比特币的共识规则，一个输出只能被花费一次；因此，如果我们拿它作为密封条，那么确保比特币共识规则得到执行的激励因素，将同样保证这样的密封条只能开启一次。</p><p>为提供一个更现实的例子，我们想象有一个所有权证书，定义了转移所有权给一个新的所有权人的必要条件是<strong>花费某一个比特币 UTXO</strong>（这个 UTXO 的私钥应该控制在当前的所有权人手中），而当这个 UTXO 被花费的时候，花费它的那一笔比特币交易将指明谁是这项被转移的财产的新所有权人。因为比特币交易的数据结构受到严格而刻意的规则的约束，将所有关于接收方的信息编码到比特币交易本身会有一些局限性（而且对相关方的隐私性有非常坏的效果），所以，更好的办法是，仅在比特币交易中添加一个关于接收者身份的承诺（例如，在输出字段中添加接收者的 UTXO 的一个哈希值）。</p><p>实质上，这就等同于，每次所有权转移的时候，我们都修改原始的合约，指明哪一个新的比特币 UTXO，是最新的所有权控制者。</p><p><img src="/../images/overview-of-the-main-concepts-and-features-of-the-rgb-design/bitcoin-based-single-use-seals-zh.png" alt="bitcoin-based-single-use-seals-zh"></p><h3 id="RGB-状态变更"><a href="#RGB-状态变更" class="headerlink" title="RGB 状态变更"></a>RGB 状态变更</h3><p>RGB 协议使用上述的 “基于比特币的一次性密封条” 模式，这意味着，每当一笔 RGB 交易发生时，实际上就是发送者给某个合约（定义了被转移的权利的那个）创建了一次<strong>状态变更</strong>。就以同质化资产（fungible assets）为例。首先，合约的发行者设定了合约的创始状态，定义了合约的细节，例如资产的名称、总供应量，以及有权移动这些供应量的 UTXO。然后，当资产被第一次转移时，第一个 UTXO 的所有者就可以创建一次状态变更，定义哪一个 UTXO 将持有这项资产。</p><p>状态变更可以应用在变更资产所有权的权利上，也可以应用在别的类型的权利上，例如，在资产发行合约中，可以是二次发行的权利，或者是 添加/改变 资产的特定属性（例如：元数据）的权利。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证收到的 RGB 转账，跟验证收到的普通比特币支付有很大的区别。在比特币中，一个连接到网络的节点会持续不断地下载和验证区块以及交易池中的交易。这样的节点对 UTXO 集（区块链上所有未花费的输出的集合）总有一个实时更新的试图，当它看到一笔新交易时，要验证其有效性，只需要验证该交易的所有输入都是 UTXO 集的最新状态的一部分。</p><p>在 RGB 中，没有全局网络这样的、所有的交易都在其中传播的东西，因此也无法创建等价于比特币 UTXO 集的东西。这意味着，在接收一笔支付时，一个 RGB 客户端将不仅需要验证交易的最新状态是有效的，还必须对以往所有的状态转化作同样的验证，一路追溯到发行合约的创始状态。</p><p><img src="/../images/overview-of-the-main-concepts-and-features-of-the-rgb-design/RGB-validation.png" alt="RGB-validation"></p><p>与此同时，这也意味着，与比特币及任何其它全局共识系统不同，在 RGB 协议中，<strong>一个客户端不需要知道、也不需要验证全局中发生的所有交易</strong>，因为它只需要知道跟自己的钱包相关的交易即可。因此，每个客户端需要验证的数据量都更小，整个系统因此更加可扩展。</p><p>一个 RGB 客户端在收到一笔支付时需要一次性验证大量数据，这可能会被视为一个问题，因为它可能导致支付的处理速度比较慢 —— 花在验证上的时间会比较长。但是，仅当你初次持有一项具有很长的交易历史的资产时才会遇到这个问题；而且，可以开发出新的数据可得性层（data availability layers），让客户端可以自愿跟他人分享跟某个合约相关的状态转换数据，这样潜在的接收方可以提前开始验证一部分交易历史。</p><h3 id="确定性的比特币承诺"><a href="#确定性的比特币承诺" class="headerlink" title="确定性的比特币承诺"></a>确定性的比特币承诺</h3><p>RGB 利用了比特币区块链来<strong>防止重复花费</strong>，而且，这是通过在特定的比特币交易 —— 它花费了当前正持有要被转移的权利的 UTXO —— 中承诺 RGB 状态转换，来实现的。为了让这样的承诺既是可以验证的，又是安全的，我们要满足两个条件：（i）多次状态转换可以承诺到单笔比特币交易中；（ii）每一次状态转换都只能被承诺进比特币交易一次（否则就有重复花费的可能性）。</p><p>为了让多次状态转换可以放进一个承诺中，状态转换的内容要被多次聚合：首先，跟某一个合约（或者说资产 ID）相关的所有状态转换，要确定性地聚合（成一个承诺）；然后，所有被转移的资产的承诺，要被聚合成一棵默克尔树，而最终的根哈希值，就是最终的 RGB 承诺。为了保证跟其它无关 RGB、但同样也需要使用确定性比特币承诺的协议的兼容性，RGB 承诺和其它协议的承诺要再一次聚合（如 <a href="https://github.com/LNP-BP/LNPBPs/blob/master/lnpbp-0004.md">LNPBP-4 标准</a>所述），如此得到的哈希值，才是实际上被嵌入比特币交易中的消息。</p><p><img src="/../images/overview-of-the-main-concepts-and-features-of-the-rgb-design/deterministic-bitcoin-commitments-zh.png" alt="deterministic-bitcoin-commitments-zh"></p><p>在最终的 LNPBP-4 消息就绪之后，有两种办法可以将其承诺到比特币交易中：</p><ol><li><strong>Taproot 承诺</strong>：一个包含了 LNPBP-4 消息的 OP_RETURN 脚本，添加到一笔比特币交易的<strong>第一个 Taproot 输出</strong>的 TapTree（脚本树）的顶层的右叶子（top right leag）中；而且这层关系将仅在链下向 RGB 转账的接收方揭晓。这样一来，比特币交易就可以仅使用一个 taproot 输出，既将比特币找零发回给发送者，又包含这个承诺，而不必添加额外的数据，也不必暴露该交易可能包含一个 RGB 承诺的任何痕迹。</li><li><a href="https://bitcoin.stackexchange.com/questions/29554/explanation-of-what-an-op-return-transaction-looks-like"><strong>OP_RETURN</strong></a> <strong>承诺</strong>：LNPBP-4 消息直接嵌入到一笔比特币交易的第一个 OP_RETURN 输出中。这将导致交易膨胀 46 字节，但同样不会揭晓关于这笔 RGB 转装的内容的任何消息，因为对区块链观察者来说，这就只是一个带有一个哈希值的 OP_RETURN 输出（举个例子，跟 open timestamp 交易一模一样）。对比 Taproot 承诺，这种方法的优势在于简洁性和易于实现。</li></ol><p>在多个承诺要插入比特币交易的情形中，只有第一个会跟 RGB 验证规则有关，其它都会被忽略，所以任何重复花费的尝试都是没有意义的。</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>因为我们可以在单个比特币承诺中包含任意数量的状态转换，大规模的批处理也成为可能。例如，假设某人想同时给多人支付，他只需为每一个接收者创建一个状态转换，并将所有的状态转换都承诺到同一笔比特币交易中，就可以了，不需要占用更多字节。这意味着，每笔 RGB 支付的链上手续费边际成本都可以非常小，因为同一笔手续费被任意数量的转账平摊了。</p><p>但是，这样的批处理技术只有在花费同一个 UTXO 时才有用，如果用户要花费多个 UTXO，那么每个 UTXO 都需要用作比特币交易的输入，则这笔交易的体积会增加、需要支付的链上手续费也会提高。这意味着，批处理对使用合并 UTXO 的服务供应商来说尤为有用，比如要给大量用户操作取款的托管式交易所。比如，一个交易所可以每 30 分钟将所有的取款请求聚合在一起，只需付出带有一个输入和一个输出的比特币交易的链上手续费，就可以及时给每个发起取款请求的用户支付。</p><h3 id="隐私性"><a href="#隐私性" class="headerlink" title="隐私性"></a>隐私性</h3><p>得益于客户端验证的设计（向区块链观察者隐藏了信息），RGB 已经得到了<strong>更高程度的隐私性</strong>，但是，为了进一步提升其隐私性，我们还给协议添加了其它特性。</p><h4 id="盲化的-UTXO"><a href="#盲化的-UTXO" class="headerlink" title="盲化的 UTXO"></a>盲化的 UTXO</h4><p>为了让转账的接收方获得对抗支付方的额外隐私性，RGB 使用了 “<strong>盲化的 UTXO（blinded UTXOs）</strong>” 而不是普通的 UTXO 作为支付的输出点。这意味着，当一名用户想要接收支付时，他不会分享自己希望用来接收资产的 UTXO，他会给出这个 UTXO 的一种盲化形式，由 UTXO 拼接一个随机盲化秘密值之后的哈希值组成。如此一来，支付方就完全不知道资产去了哪里，而且支付方也无法看到资产未来的花费方向（在常规的比特币链上支付中，支付方总是能看到这些信息）。</p><p>而在花费的时候，为了证明自己的 UTXO 正是某个资产的所有者，发送者需要跟接收者分享用来生成盲化 UTXO 的盲化秘密值，所以，在验证阶段，新的接收方可以验证出来，那个盲化的 UTXO，确实是从这个要花费的 UTXO 中推导出来的。</p><p>盲化 UTXO 的例子：</p><pre><code>UTXO:ad3ebdcda0f83b37fffab0439c89fd3ef7d99c41c353a45a98d5983d9ad00183:0盲化秘密值：8114079862469528952盲化输出点：txob1kewrvnf8sjmarq65gv98lz2xrgxylpnlta8lc3p78fjxaw9qda4qkewlwr</code></pre><h4 id="Bulletproof"><a href="#Bulletproof" class="headerlink" title="Bulletproof"></a>Bulletproof</h4><p>为了隐藏一项资产的交易历史中的每一次状态转换的具体数值，RGB 还实现了<strong>一种零知识证明机制</strong>；这种机制叫做 “Bulletproof”，是由 Blockstream 公司开发出来的，它是 “机密交易（Confidential Transactions）”（已经用在 Liquid 侧链中） 的一种经过优化且效率更高的版本。感谢 Bulletproof，用户可以获得对抗未来的资产所有权人的隐私性。虽然未来的所有权人可以看到从创始状态到自己的状态这一路上用到的所有 UTXO，但他们看不到每一次状态转换中被转移的资产数量（但得益于零知识证明，他们依然可以验证此前任何时刻都没有出现过隐形的通胀）。</p><p>你可以从 <a href="https://blog.blockstream.com/en-bulletproofs-faster-rangeproofs-and-much-more/">Blockstream 的博客</a>中了解 Bulletproof。</p><h3 id="客户端间通信"><a href="#客户端间通信" class="headerlink" title="客户端间通信"></a>客户端间通信</h3><p>为了达成一笔 RGB 转账，参与的客户端需要彼此分享一些数据。具体来说，发送者需要给接收者（们）分享 consignment，<strong>这种数据结构包含了验证转账所需的一切信息</strong>，包括可以追溯到合约创始状态的所有状态转换。</p><p>RGB 协议不关心用于这种数据分享操作的通信渠道，而且这确实也可以用许多方式实现。虽然你信鸽来分享 consignment 也是可以的，但 RGB 软件已经实现了更实用的电子化信道。当前，在 RGB 软件中主要有两种分享数据的方法：</p><ul><li><a href="https://github.com/Storm-WG/storm-spec">Storm</a>：一种点对点的即时通信和存储系统，基于闪电网络。</li><li><a href="https://github.com/RGB-Tools/rgb-http-json-rpc">RGB 代理服务端</a>：一种标准化的 HTTP JSON-RPC 服务端，其客户端可以上传和下载数据。用户可以运行自己的代理服务端，也是使用第三方的服务端。依赖于第三方的服务端会影响隐私性和抗审查性，但不影响安全性。</li></ul><p>通信方式的协调可通过一种<a href="https://github.com/LNP-BP/invoices">发票协议</a>来完成，接收者提供一种或多种发送者可用于上传 consignment 数据的端点。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">RGB 设计的主要概念和特性概述</summary>
    
    
    
    
    <category term="RGB" scheme="https://www.btcstudy.org/tags/RGB/"/>
    
  </entry>
  
  <entry>
    <title>RSA 累加器：一种马上可用且可扩展的默克尔树替代品</title>
    <link href="https://www.btcstudy.org/2023/01/07/a-scalable-drop-in-replacement-for-merkle-trees/"/>
    <id>https://www.btcstudy.org/2023/01/07/a-scalable-drop-in-replacement-for-merkle-trees/</id>
    <published>2023-01-07T15:58:57.000Z</published>
    <updated>2023-01-12T06:01:27.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Benedikt Bünz、Benjamin Fisch、Dan Boneh</em></p><p><em>来源：<a href="https://btctranscripts.com/scalingbitcoin/tokyo-2018/accumulators/">https://btctranscripts.com/scalingbitcoin/tokyo-2018/accumulators/</a></em></p><p><em>本文为 Benedikt Bünz 在 Scaling Bitcoin Conference 2018 上的演讲的文字稿，由 Bryan Bishop 转写。</em></p></blockquote><h2 id="开场白"><a href="#开场白" class="headerlink" title="开场白"></a>开场白</h2><p>哈咯。声音测试。没问题。</p><p>我今天准备讲讲 UTXO 的累加器（accumulators）。前面的两场演讲给本演讲做了很好的铺垫。本演讲涉及的工作是我和 Ben Fisch（他今天也在这里）和 Dan Boneh 的联合成果。我还希望给 Stanford Blockchain Conference（曾用名 BPASE）打个广告，这个会将在 2019 年 1 月在斯坦福召开。无论你是否要去演讲，你都应该去看看。</p><h2 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h2><p>UTXO 集的膨胀是一个日益严重的问题。今天上午我们已经听过了关于 UTXO 集合中的粉尘（译者注：指面额过于微小，因此无法单独花费的 UTXO）。我们已经有大约  6000 万个 UTXO。这里面的问题，我们在前几场演讲中已经听过了：区块链在存储 UTXO 上是非常低效的结构，如果我要下载一个旧区块，那么我需要知道当前区块与该旧区块之间的所有区块头。如果我想下载一笔旧交易并检查这笔交易是否已经花掉了，并且我只知道最新的区块，那么我需要检查从该交易到最新交易之间的所有交易，看看有没有哪一笔花费了它。</p><h2 id="UTXO-承诺"><a href="#UTXO-承诺" class="headerlink" title="UTXO 承诺"></a>UTXO 承诺</h2><p>有人提议用 UTXO 承诺来解决这个问题。就像我们刚刚听过的，每个区块都包含一个对最新状态（例如当前的 UTXO 集状态）的承诺。这里的想法是，利用共识规则来保证区块头中包含一个事实上正确的 UTXO 承诺。轻客户端将能够检查这个承诺。如果我想说服一个轻客户端某个 UTXO 是存在的，那么我需要给 TA 一个证据，证明它在最新的 UTXO 集承诺所涵盖的数据中。我们可以使用这种思路，将所有人都变成一个轻客户端。</p><h2 id="默克尔树"><a href="#默克尔树" class="headerlink" title="默克尔树"></a>默克尔树</h2><p>实现这种思路的经典办法是 “默克尔树”。默克尔树的建构方法就像这样。我可以给你一个包含证据，证明 UTXO 集中含有某些东西；在生成包含证据时，需要  <code>log(n)</code> 次哈希计算，而且我可以在某些时候更新证据，每次更新都是  <code>log(n)</code>。</p><h2 id="无状态的全节点"><a href="#无状态的全节点" class="headerlink" title="无状态的全节点"></a>无状态的全节点</h2><p>这样一来，我就能建构一种无状态的全节点，它不需要存储完整的 UTXO 集。这是怎么工作的呢？当我要发送一笔交易的时候，我必须提供一个证据，证明我的交易在花费一个还没有被花过的币。在当前，矿工用自己的 UTXO 集检查我的交易。但在这种设计中，由用户自己证明自己的币还没被花费过。因此，矿工将不必存储 UTXO 集，就能直接检查一笔交易是否被花费过。这很有趣。</p><h2 id="默克尔树的问题"><a href="#默克尔树的问题" class="headerlink" title="默克尔树的问题"></a>默克尔树的问题</h2><p>但这种方法有一些问题。主要的问题是，如果每一笔交易都要附加这些包含证据，它们的体积会变得非常大。每一笔交易都需要包含证据，那么区块链会需要额外的 160 GB 空间。并且，在验证区块链时，你需要做许多昂贵的检查。在 Peter Todd 提到这一点时，他提议仅对非常老旧的交易使用这种方法，而大部分交易不应该被逼迫使用这种技术。</p><h2 id="RSA-累加器"><a href="#RSA-累加器" class="headerlink" title="RSA 累加器"></a>RSA 累加器</h2><p>那么，我想讲讲 RSA 累加器，它是默克尔树的一种替代。我们需要选择一个 RSA 模量，它是一个很大的数（N），是两个大质数（p，q）的乘积。我们还需要一种哈希函数，将任意元素映射成质数。然后，我们从群（the group）（Z<sub>N</sub>，译者注）中选出一个元素（下文称为 “g”，译者注）来初始化一个累加器（即定义累加器的初始值  $A_0 = g$ ，译者注）。</p><p>这种累加器要怎么用呢？假设我们要在集合中加入一些东西。这种累加器是对某个集合的一个简短的的承诺。如果我们想要给一个累加器加入一些东西，我们就以被加入的元素为幂次，求累加器原值的幂，即 Add(A<sub>i</sub>, x)=A<sub>i</sub><sup>H(x)</sup>。要是我们需要删去一些东西，我们就以被删元素的倒数为幂次，求累加器原值的幂，即  Del(A<sub>i</sub>, x)=A<sub>i</sub><sup>1/+H(x)</sup>。这里实际上都需要把元素哈希成质数，但在演讲剩下的时间里我会假设每一个元素都是一个质数。这是可以做到的。</p><p>如果我要表示一个 UTXO 集 S，那么相应的累加器的值就是 g 的幂，次数为 S 中所有元素的乘积。这种累计器的一个很好的属性是，不必管元素添加的顺序，这种次序是完全可交换的。它还有其它很好的特性。</p><h2 id="累加器证据"><a href="#累加器证据" class="headerlink" title="累加器证据"></a>累加器证据</h2><p>这种累加器的包含证据是非常简单的，只需要求累加器的现值（A）的被证明元素（x）的倒数次幂（A<sup>1/x</sup>）。这可以通过使用一个陷门（trapdoor），或者说构建累加器的秘密值（p，q），来计算；我们可以优化这一点。不然，你就得知道整个集合，才能计算出来。如果累加器是诚实地构造的，那么这样的计算会给累加器的现值消去一定的幂次，从而依然得到一个有效的累加器值。在 RSA 群有安全证明，如果 x 不在集合中，你是没办法做这样的操作的。</p><p>我们也可以创造出非包含证据，相对要复杂一些，所以我在这里就跳过这些细节了，你可以直接看大屏幕（译者注：Exclusion(A, x): A = g<sup>u</sup> ; a · x + b · u = gcd(x, u)=1​）。它使用了 bazooko 系数。详见 LiLiXue07。你可以作非常高效的无状态更新。我可以高效地告诉你：无论哪一笔交易或者什么东西加入集合或者从集合中移除，我都可以相应地更新我的证据。在我们的论文中，我们说明了可用的方法。</p><h2 id="RSA-需要受信任的启动设置吗？"><a href="#RSA-需要受信任的启动设置吗？" class="headerlink" title="RSA 需要受信任的启动设置吗？"></a>RSA 需要受信任的启动设置吗？</h2><p>你可能已经听过了这些东西，并且认为，这是没用的，因为 RSA 累加器需要一次受信任的启动设置。要由谁来执行这个受信任的启动设置？“受信任的启动设置” 又是什么意思呢？</p><p>问题就在于 N 是 p 和 q 的乘积；如果某人知道 p 和 q，那 TA 就可以完全攻破整个方案，并欺骗你，让你以为某个元素在某个累加器中（即使这并非事实）。而且，累加器的高效删除需要一个陷门。传统的方案假设了有一个累加器管理员，来做这些事。另外，你有可能可以直接找出 N（Ron Rivest 假设）。</p><p>的确有一些时候，可以产生没有人知道陷门的 N，例如，Ron Rivest 一开始创建了一个 RSA 难题，并且他删除了 p 和 q，如果你信任他（他可是那么著名的密码学家，还是图灵奖得主呢），那么你就可以使用他给出的 N 值。又或者，有一家很老的公司，他们现在破产了，他们在一个硬件模块中保存了一个私钥，而这个模块在这家公司破产的时候毁坏了。也许这样的 N，你也是可以合理使用的。但这可能还不够好。</p><h2 id="类群"><a href="#类群" class="headerlink" title="类群"></a>类群</h2><p>BW88 和 L12 两篇论文提议使用 “类群（Class groups）”。类群是一个令人惊讶的数学概念，最初由高斯（Gauss）提出 …… 这是一个二次方根数领域的类群（it’s a class group of quadratic number fields），这其中的想法是，这是一个不明阶数的群，所以你不知道这个群中有多少个数。它的属性类似于 RSA，但并不要求受信任的启动设置。类群的元素比 RSA 元素稍微短一点，大概是其长度的一半。</p><h2 id="RSA-累加器前沿"><a href="#RSA-累加器前沿" class="headerlink" title="RSA 累加器前沿"></a>RSA 累加器前沿</h2><p>如果只考虑包含证明，RSA 累加器的证据是固定大小的，无论累加器覆盖了多少数据。证据将一直是 3000 比特。当集合的体积大于 4000 个元素时，RSA 包含证据比默克尔包含证据要好。而且，它还有 “动态无状态添加” 特性，就是你可以给累加器增加元素，而无需知晓整个集合。你可以把这个用在去中心化存储中；一个完全验证的节点不需要存储，用户会维护自己的 UTXO 和相应的包含证明。</p><p>这里的提升空间在于聚合以及批处理包含证明：要是我有许多个证据，我怎么聚合它们呢？另外，我们能实现无状态删除吗，也就是在不知道整个集合时，为累加器删除元素？验证速度还能更快吗？</p><h2 id="聚合包含证据"><a href="#聚合包含证据" class="headerlink" title="聚合包含证据"></a>聚合包含证据</h2><p>假设我们有同一个累加器的两个包含证据。事实证明，我们可以利用叫做 “Shamir 技巧” 的方法，创建别的东西 —— 你想要检查的这两个元素的一个包含证据。只要我们能对两个元素实现，那么我们就能对任意数量的元素实现。把一个区块中的所有包含证据都合并成一个 —— 而不是让每一笔交易都附带一个默克尔证据或者一个 RSA 包含证据。所以，我们不需要前面说的额外的 160 GB 的存储空间，只需要 1.5 kB，你甚至可以打印在一张纸上。</p><h2 id="无状态的删除"><a href="#无状态的删除" class="headerlink" title="无状态的删除"></a>无状态的删除</h2><p>如果我有一个陷门，我就能做到高效删除。但要是我们没有呢？我们改变一下模型：我们假设每次我们想要删除某些元素的时候，我们实际上都有一个可用的包含证据。什么时候我们需要从 UTXO 集中删除东西？无非是某一个 UTXO 被花费的时候。但在它被花费的时候，用户总要提供相应的包含证据。那么，累加器的下一个值将正好等于这个证据；为什么这么说呢？因为这个证据就是  <code>g^(u/x)</code> ，相等于把 x 从集合中消去了。也即，证据恰好就是累加器现值删去被证明的元素后得到的值。因此我们可以把累加器的值设为这个证据的值。在区块链中，情形稍有区别，因为我们会有许多笔交易，因此有许多个对应于同一个累加器值的包含证据。这里，我们又可以利用前面提到的同一种技巧 —— 把所有包含证据合并成一个包含证据，然后更新我们的累加器。这就是我们实现无状态删除的办法，所以我们可以实现批量删除功能。即使我们只有对同一个累加器值的多个证据，也能一次性删除它们。</p><h2 id="太慢了？"><a href="#太慢了？" class="headerlink" title="太慢了？"></a>太慢了？</h2><p>RSA 有点慢，它比哈希计算要慢。如果你的设置是一个 2000 比特的 RSA，那么每秒只能做 219 次更新。这有点慢，尤其是对完全同步（full sync）来说，你需要更新整个区块链，因此需要检查所有这些证据，同步会变得非常慢。聚合技术只能降低证据的体积，不能节约验证时间。</p><p>对于类群，现在还没用基准测试，但它已经用在 “可验证延迟函数（verifiable delay functions）” 中了。Chia 项目刚刚推出了一个比赛，你可以尝试加速类群的计算或尝试打破它们，我记得奖金好像是 10 万美元。我们很快会更清楚这些东西实际上有没有用、安不安全。</p><h2 id="Wesolowski-证据（Wesolowski-2018）"><a href="#Wesolowski-证据（Wesolowski-2018）" class="headerlink" title="Wesolowski 证据（Wesolowski 2018）"></a>Wesolowski 证据（Wesolowski 2018）</h2><p>我们可以用 Wesolowski 证据来减低验证时间，这是在可验证延迟函数的开发者产生的技术。你也可以使用幂计算证据（proof of exponentiation）。使用 128 比特的大数除法（也即幂计算证据的验证），相比于直接验证，是显著的加速（大约快上 5000 倍）。</p><h2 id="快速区块验证"><a href="#快速区块验证" class="headerlink" title="快速区块验证"></a>快速区块验证</h2><p>现在我们也可以实现快速的区块验证。假设我是一个矿工，我希望组装我的区块。基于区块链的最新状态，累加器的最新状态，我可以使用无状态删除技术，从累加器中移除一批元素 …… 也就是移除所有被花费的 UTXO …… 然后给累加器加入新的假以，然后我组装新的区块，它依然有区块头，以及相应的交易，可能还有一个 BLS 签名（这是 一种小体积的签名）。然后，它还有两个值，一个是上一个累加器值移除所有被花费的 UTXO（集合为 “s”）之后得到的值（称为 “半路值”），另一个是半路值加上所有新产生的 UTXO （集合为 “n”）之后得到的值（称为 “完全值”），以及它们的幂计算证据。</p><p>那么，完全验证节点现在需要做什么呢？TA 必须验证 BLS 签名（这可以很快），然后验证两个幂计算证据（在现实中也非常快）。你只需要检查，从上一个累加器值删去 s 是否可以得到半路值，从半路值加上 n 是否可以得到新的累加器值（完全值），即可。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>那么这一套技术的表现如何？请谨慎看待我提供的数字。</p><p>我在我的 macbook 笔记本电脑上使用标准的 java 库做了测试。使用默克尔数，对 6400 万个元素的集合生成一个包含证据需要大概 20 次哈希计算，是 8.5 微秒。要是我使用新的 Wesolowski 证据，验证它只需要 0.3 微秒，这比默克尔树快很多。至于类群，我们不知道。会更快还是更慢？类群的体积更小，但也说不准更快还是更慢。在 Pieter Wuille 实现之前，我们很难估计。</p><h2 id="向量承诺"><a href="#向量承诺" class="headerlink" title="向量承诺"></a>向量承诺</h2><p>“向量承诺” 类似于累加器。你也可以使用默克尔树来实现。这是一种对某一个向量的承诺，所以我可以在某个位置开启它，然后告诉你这个向量在位置 x 有一个值。我们开发了一种新的向量承诺，之前也有来自 RSA 的向量承诺，但验证将需要几 GB 的内存，或者内存会线性增长，而我们的方案不需要内存，所以更加高效。</p><h2 id="简短的-IOP"><a href="#简短的-IOP" class="headerlink" title="简短的 IOP"></a>简短的 IOP</h2><p>像 STARK 这样的零知识证明技术 …… 或者说叫做 “IOP” 的零知识证明技术类，大体上，是证明者为更长的证据创造一个更短的承诺，然后验证者请求一些索引，证明者发送相应的证据以及默克尔证据，证明在位置 x，证据就是这个数值，然后验证者可以接受或拒绝。问题在于，默克尔路径本身非常大，我们可以用向量承诺来替代，然后我们可以聚合向量承诺，将它缩减到几 kB，而不是大量的默克尔证据。可以将证据体积缩减到 …… 这些数字都来自于一种设定，很难获得真实的数字，因为你要看设定是什么样的。对于一个比较大的设定，你可以将证据的体积从几百缩减到几十。这会渐渐逼近以  <code>log(n)</code> 的缩减比率 。所以证据可以变短。</p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>（无）</p>]]></content>
    
    
    <summary type="html">RSA 累计器的原理及特性</summary>
    
    
    
    
    <category term="累加器" scheme="https://www.btcstudy.org/tags/%E7%B4%AF%E5%8A%A0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>eclair 客户端背后的架构</title>
    <link href="https://www.btcstudy.org/2023/01/04/the-architecture-behind-eclair/"/>
    <id>https://www.btcstudy.org/2023/01/04/the-architecture-behind-eclair/</id>
    <published>2023-01-03T17:10:25.000Z</published>
    <updated>2023-01-12T06:01:27.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：ACINQ</em></p><p><em>来源：<a href="https://medium.com/@ACINQ/the-architecture-behind-eclair-ca0c99880962">https://medium.com/@ACINQ/the-architecture-behind-eclair-ca0c99880962</a></em></p></blockquote><blockquote><p>长话短说：eclair 客户端的架构基于 “演员模型”，让开发可靠且可扩展的软件变得更加简单。它支持着闪电网络中最大的节点，已经可靠地运行了接近 5 年。</p></blockquote><h2 id="一个网络，多种实现"><a href="#一个网络，多种实现" class="headerlink" title="一个网络，多种实现"></a>一个网络，多种实现</h2><p>闪电网络是一种去中心化的支付网络，围绕着一套共享的开源规范 —— <a href="https://github.com/lightning/bolts">闪电网络 BOLT</a> —— 发展起来。</p><p>许多公司都对这套规范有所贡献，最积极的一些是 ACINQ、Blockstream、Lightning Labs 和 Spiral。改变规范需要花时间，也许多这许多团队的共识；这保证了被接受的特性都经过了彻底的审核，并且让闪电网络更高效、更安全，也更易于使用。</p><p>但是，规范只是一个起点：它需要被转化成实际上有用的软件。上面提到的四家公司都有自己的实现了 BOLT 的软件：<a href="https://github.com/acinq/eclair">eclair</a> (ACINQ)、<a href="https://github.com/ElementsProject/lightning/">cln</a> (Blockstream)、<a href="https://github.com/lightningnetwork/lnd">lnd</a> (Lightning Labs) 和 <a href="https://github.com/lightningdevkit/rust-lightning">ldk</a> (Spiral)。虽然每一种实现都有区别，但它们都遵循了同一种规范，而且是可以互通的，这也是为什么尽管节点们运行的软件各有不同，但我们能形成一个闪电网络。</p><p>每一种实现都有自己的优点和缺点，这对整个网络是好事：用户可以根据自己最适应的取舍、自己希望使用闪电网络的方式，选择合用的软件。在本文中，我们关注 eclair，这是当前闪电网络中最大的节点 ——  <a href="https://mempool.space/lightning/node/03864ef025fde8fb587d989186ce6a4a186895ee44a926bfc370e2c366597a3f8f">ACINQ 节点</a> —— 所用的软件。我们的节点从 2018 年初开始就平滑地运行，开启了几千条通道、转发过无数的交易，并且通过流动性服务为非托管的移动钱包（曾用名 “eclair-mobile”，现用名 “Phoenix”）用户提供了良好的体验。</p><p>人们常常问我们：在生产环境中运行这么大的节点，一定非常难，有没有什么秘诀？我们的回答常常让人失望 —— 这并不是很难。Eclair 从一开始就是为并发、稳定性和横向可扩展性而设计的，所以部署和管理大量任务都非常简单。来看看让我们能做到这些的技术抉择。</p><h2 id="演员模型"><a href="#演员模型" class="headerlink" title="演员模型"></a>演员模型</h2><p>“演员模型” 是一种并发计算的模式，既可以集成到一种编程语言中（例如 <a href="https://www.erlang.org/">Erlang</a> 和 <a href="https://elixir-lang.org/">Elixir</a>）、也可以作为已有语言的一个库来实现（例如 JVM 的 <a href="https://akka.io/">Akka</a>）。发明它是为了在许多机器的集群或者多核心的机器上高效且安全地运行高度并发的任务，办法是移除整个并发错误类型（不设共享的可变更状态）。</p><p>“演员” 是非常轻量级的进程，既不绑定到具体的线程，也不通过异步的消息传递来交互，所以不需要 “锁”。演员有可变的内部状态，但并不向彼此公开。在接收一条消息时，一个演员会运行一个同步消息处理器，这个处理器可能会更新其内部状态、向其它演员发送有限数量的消息并创建有限数量的新演员。一个演员一次只处理一条消息，这可以防止数据竞争进入。</p><p><img src="/../images/the-architecture-behind-eclair/EsSmMlg.png" alt="img"></p><p style="text-align:center">- 演员交换消息 -</p><p>上图展示了对等节点连接逻辑的一个简化版本：单个演员（图中的 “switchboard”，总机）接收 “connect” 消息以初始化对其它闪电节点的连接、创建子演员以实际处理 TCP 连接逻辑，并在稍后 —— 收到 “connected” 消息，表明连接已经建立时 —— 更新自己的内部状态。在转发 “connect” 消息给对等节点演员后，总机就可以去处理别的、不相关的消息了。</p><p>这种编程模式迫使开发者异步地处理每一个操作，并思考易于被忽略的罕见情形，例如：要是我发送一条消息之后一直得不到响应，那会怎么样？这种模型非常适合于实现有限状态机，而有限状态机完美适配闪电网络。乍看起来很难，但现实中编译器很有用，所以开发体验很舒服。最终生成的代码也很容易测试，而且微妙的罕见情形也很容易复现。</p><p>演员模型最重要的特性之一是位置的透明性：因为演员是通过信息来交互的，所以演员在哪里运行并不重要。它们可能在同一个进程中，也可能在同一台机器的不同进程中，甚至在远端的机器上。这是通过演员模型的实现直接处理的：应用逻辑在发送消息时使用演员 “引用”，而且不需要关心信息如何送达目的地（保证最多只需要一次分发）。我们后面会看到 eclair 是如何利用这一点轻易实现横向扩展的。</p><h2 id="Scala，一种功能性的编程语言"><a href="#Scala，一种功能性的编程语言" class="headerlink" title="Scala，一种功能性的编程语言"></a>Scala，一种功能性的编程语言</h2><p>Eclair 客户端是用 Scala 语言实现的，这种功能性编程语言运行在 JVM（Java 虚拟机）上。我们使用 <a href="https://akka.io/">Akka</a> 库来结合演员模型和功能性编程。这两种编程模式相得益彰，而且很容易从简单、可组合的模块创建出复杂的系统，同时保证正确性和高效并发。</p><p>功能性编程帮助开发者专注在小型的、严格限定的模块上：数据不可变更性以及对副作用的严格控制，保证了这些模块不会因为竞争进入或者高级模块的误用，而以未预期到的状态结束。它也提供了非常丰富而且有表达力的类型系统。在现实中，这意味着开发者可以专注于寻找正确的架构和解决问题的数据模式，然后，因为有编译器的帮助，实现也会变得轻而易举。它使我们能轻而易举地解决复杂的问题，这也是我们的代码库比别的闪电网络客户端实现小得多的原因。</p><p>下面这张代码截图显示了我们是如何创建洋葱加密的支付消息的：注意模板匹配（pattern matching）和功能性组合是如何帮助创建简洁、易于检查正确性的实现的。</p><pre><code class="scala">/** * @param cmd             command to send the HTLC for this payment. * @param outgoingChannel channel to send the HTLC to. * @param sharedSecrets   shared secrets (used to decrypt the error in case of payment failure). */case class OutgoingPaymentPacket(cmd: CMD_ADD_HTLC, outgoingChannel: ShortChannelId, sharedSecrets: Seq[(ByteVector32, PublicKey)])/** Helpers to create outgoing payment packets. */object OutgoingPaymentPacket &#123;  case class NodePayload(nodeId: PublicKey, payload: PerHopPayload)  case class PaymentPayloads(amount: MilliSatoshi, expiry: CltvExpiry, payloads: Seq[NodePayload])  sealed trait OutgoingPaymentError extends Throwable  case class CannotCreateOnion(message: String) extends OutgoingPaymentError &#123; override def getMessage: String = message &#125;  case class CannotDecryptBlindedRoute(message: String) extends OutgoingPaymentError &#123; override def getMessage: String = message &#125;  case class InvalidRouteRecipient(expected: PublicKey, actual: PublicKey) extends OutgoingPaymentError &#123; override def getMessage: String = s&quot;expected route to $expected, got route to $actual&quot; &#125;  case class MissingTrampolineHop(trampolineNodeId: PublicKey) extends OutgoingPaymentError &#123; override def getMessage: String = s&quot;expected route to trampoline node $trampolineNodeId&quot; &#125;  case class MissingBlindedHop(introductionNodeIds: Set[PublicKey]) extends OutgoingPaymentError &#123; override def getMessage: String = s&quot;expected blinded route using one of the following introduction nodes: $&#123;introductionNodeIds.mkString(&quot;, &quot;)&#125;&quot; &#125;  case object EmptyRoute extends OutgoingPaymentError &#123; override def getMessage: String = &quot;route cannot be empty&quot; &#125;  sealed trait Upstream  object Upstream &#123;    case class Local(id: UUID) extends Upstream    case class Trampoline(adds: Seq[UpdateAddHtlc]) extends Upstream &#123;      val amountIn: MilliSatoshi = adds.map(_.amountMsat).sum      val expiryIn: CltvExpiry = adds.map(_.cltvExpiry).min    &#125;  &#125;  /** Build an encrypted onion packet from onion payloads and node public keys. */  def buildOnion(packetPayloadLength: Int, payloads: Seq[NodePayload], associatedData: ByteVector32): Either[OutgoingPaymentError, Sphinx.PacketAndSecrets] = &#123;    val sessionKey = randomKey()    val nodeIds = payloads.map(_.nodeId)    val payloadsBin = payloads      .map(p =&gt; PaymentOnionCodecs.perHopPayloadCodec.encode(p.payload.records))      .map &#123;        case Attempt.Successful(bits) =&gt; bits.bytes        case Attempt.Failure(cause) =&gt; return Left(CannotCreateOnion(cause.message))      &#125;    Sphinx.create(sessionKey, packetPayloadLength, nodeIds, payloadsBin, Some(associatedData)) match &#123;      case Failure(f) =&gt; Left(CannotCreateOnion(f.getMessage))      case Success(packet) =&gt; Right(packet)    &#125;  &#125;  private case class OutgoingPaymentWithChannel(shortChannelId: ShortChannelId, nextBlinding_opt: Option[PublicKey], payment: PaymentPayloads)  private def getOutgoingChannel(privateKey: PrivateKey, payment: PaymentPayloads, route: Route): Either[OutgoingPaymentError, OutgoingPaymentWithChannel] = &#123;    route.hops.headOption match &#123;      case Some(hop) =&gt; Right(OutgoingPaymentWithChannel(hop.shortChannelId, None, payment))      case None =&gt; route.finalHop_opt match &#123;        case Some(hop: BlindedHop) =&gt;          // We are the introduction node of the blinded route: we need to decrypt the first payload.          val firstBlinding = hop.route.introductionNode.blindingEphemeralKey          val firstEncryptedPayload = hop.route.introductionNode.encryptedPayload          RouteBlindingEncryptedDataCodecs.decode(privateKey, firstBlinding, firstEncryptedPayload) match &#123;            case Left(e) =&gt; Left(CannotDecryptBlindedRoute(e.message))            case Right(decoded) =&gt;              val tlvs = TlvStream(OnionPaymentPayloadTlv.EncryptedRecipientData(firstEncryptedPayload), OnionPaymentPayloadTlv.BlindingPoint(firstBlinding))              IntermediatePayload.ChannelRelay.Blinded.validate(tlvs, decoded.tlvs, decoded.nextBlinding) match &#123;                case Left(e) =&gt; Left(CannotDecryptBlindedRoute(e.failureMessage.message))                case Right(payload) =&gt;                  val payment1 = PaymentPayloads(payload.amountToForward(payment.amount), payload.outgoingCltv(payment.expiry), payment.payloads.tail)                  Right(OutgoingPaymentWithChannel(payload.outgoingChannelId, Some(decoded.nextBlinding), payment1))              &#125;          &#125;        case _ =&gt; Left(EmptyRoute)      &#125;    &#125;  &#125;  /** Build the command to add an HTLC for the given recipient using the provided route. */  def buildOutgoingPayment(replyTo: ActorRef, privateKey: PrivateKey, upstream: Upstream, paymentHash: ByteVector32, route: Route, recipient: Recipient): Either[OutgoingPaymentError, OutgoingPaymentPacket] = &#123;    for &#123;      paymentTmp &lt;- recipient.buildPayloads(paymentHash, route)      outgoing &lt;- getOutgoingChannel(privateKey, paymentTmp, route)      onion &lt;- buildOnion(PaymentOnionCodecs.paymentOnionPayloadLength, outgoing.payment.payloads, paymentHash) // BOLT 2 requires that associatedData == paymentHash    &#125; yield &#123;      val cmd = CMD_ADD_HTLC(replyTo, outgoing.payment.amount, paymentHash, outgoing.payment.expiry, onion.packet, outgoing.nextBlinding_opt, Origin.Hot(replyTo, upstream), commit = true)      OutgoingPaymentPacket(cmd, outgoing.shortChannelId, onion.sharedSecrets)    &#125;  &#125;&#125;</code></pre><h2 id="JVM，一种被严重低估的运行环境"><a href="#JVM，一种被严重低估的运行环境" class="headerlink" title="JVM，一种被严重低估的运行环境"></a>JVM，一种被严重低估的运行环境</h2><p>Eclair 运行起来非常快：<a href="https://github.com/bottlepay/lightning-benchmark#results">我们所知的最新一份独立性能基准测试</a>（虽然现在已经过时了），将 eclair 评为处理支付最快的闪电实现。这可能会让那些认为 JVM 很慢的人感到意外，但现在应该澄清对这种被低估的运行环境的误解了。</p><p>虽然基于 JVM 的程序通常比别的编程语言消耗更多的内存，但其运行时性能通常都跟竞争对手打平甚至更好（甚至在没有垃圾回收的程序中也是如此）。这是 JVM 及其垃圾回收器的数十年优化的结果。JVM 也让我们容易跟原生的代码交互（如果有必要的话），感谢 JNI（Java Native Interface）：eclair 使用这个为所有的密码学操作调用 <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a> 库。</p><p>JVM 已经被大量的成熟企业项目使用，并且提供了非常丰富而且经过考验的库和工具（集成开发环境、调试器、代码分析器、过滤器、监控器，等等）。流行的 java 库都有几百万用户（甚至不止），而且已经应用了数十年，这保证了我们不需要重新发明轮子，而且在必要时可以使用可靠的现成模块。</p><p><img src="/../images/the-architecture-behind-eclair/4FXsXg.jpeg" alt="img"></p><p style="text-align:center">- 罕见图片：功能编程师使用简单模块开发出复杂的系统 -</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Eclair 提供了一个非常强大的插件系统：插件接收来自系统的主演员（main singleton actor）的演员引用，而且 可以发送自己想要的任何消息给任何一个演员。它们也可以注册到事件流中的某个事件中，从而允许它们响应重要事件（通道创建、对等节点连接、支付转发，等等）。这给插件的作者创造了无穷无尽的可能性！</p><p>但是，这种广泛的可能性也有缺点，就是缺乏易于使用的文档：我们没办法用简单、好读的文档介绍每一次演员的交互。开发者必须关注演员们收到的消息以及什么消息可能被返回，然后发现哪些东西是可以通过数据模式来浏览的。这给新进入的开发者带来了不小的门槛，我们准备通过提供正式的、可以作为样品的插件代码，来帮助插件作者起步。</p><h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>默认情况下，eclair 会在同一个 JVM 实例上创建所有的演员：这对于不需要扩展到几万条通道和 TCP 连接的节点来说，更加高效。但我们也支持一种<a href="https://github.com/ACINQ/eclair/blob/master/docs/Cluster.md">集群模式</a>，可以在分散的 “前端” 机器上运行一些演员，这可以用来扩展更大的节点。</p><p>这些前端及其处理连接管理（使用 BOLT8 流量加密）以及 gossip 管理（BOLT7），同时后端及其处理通道和支付。这保证了使用最多流量和最容易遭遇 DoS（拒绝服务式攻击）的模块可以放在负载均衡器后面，甚至基于实时使用量自动扩展（如果有需要的话）。</p><p>我们的节点当前使用了三台前端机器。这些机器不是满负载运行的，但是使用多一些机器是验证集群模式的架构、找出优化点的好办法。</p><p><img src="/../images/the-architecture-behind-eclair/8Vf_nLw.png" alt="img"></p><p style="text-align:center">- ACNIQ 节点的架构 -</p><p>当然，我们可以更进一步：eclair 创建的许多其它演员可以分散在多台机器上，这就使得单个逻辑节点可以拓展到几十万甚至几百万通道（如果有需要的话），而不需要复杂的操作设置。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>因为许多原因，Eclair 是知名度最低的实现：我们使用一种可以说有点小众的编程语言（但它真的很棒）、有些人就是不喜欢 JVM、我们也没有花时间来解释我们做了什么和为什么要这样做，而且人们常常以为我们只关心手机钱包（Phoenix）的开发。但桃李不言，下自成蹊：eclair 的可靠性使之成为了最大的闪电网络节点，解释了我们在网络中的重要位置。我们从一开始就参与闪电网络的开发，而且一直致力于创建干净、可以派上用场的软件，以让比特币的点对点支付更加快捷、安全、可靠，并且易于使用。</p><p>我们希望这篇文章能分享关于 eclair 工作原理、我们的节点何以如此可靠、eclair 如何设计以应对大型商务需要的洞见。如果你也在运行大型节点，或者你准备这样做，我们很希望能听到你的反馈，我们想知道如何能帮助你更简单把事情做成。为了帮助闪电网络成长，我们要帮助节点扩展。<a href="https://github.com/ACINQ/eclair/blob/master/README.md#installation">试试 eclair 吧</a>，继续创造吧！</p><p>（完）</p>]]></content>
    
    
    <summary type="html">桃李不言，下自成蹊：eclair是最大的闪电网络节点</summary>
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/categories/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="开发" scheme="https://www.btcstudy.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin Optech 周报 2022 年度回顾特别版</title>
    <link href="https://www.btcstudy.org/2022/12/31/bitcoin-optech-newsletter-2022-year-in-review-special/"/>
    <id>https://www.btcstudy.org/2022/12/31/bitcoin-optech-newsletter-2022-year-in-review-special/</id>
    <published>2022-12-31T08:02:46.000Z</published>
    <updated>2023-01-12T06:01:27.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Optech</em></p><p><em>来源：<a href="https://bitcoinops.org/zh/newsletters/2022/12/21/">https://bitcoinops.org/zh/newsletters/2022/12/21/</a></em></p><p><em>本译本由 “原语里弄（<a href="https://www.primitiveslane.org/">Primitives Lane</a>）” 提供。</em></p></blockquote><p>这份特别版的 Optech Newsletter 总结了 2022 年全年比特币值得注意的发展。 这是我们的年终总结系列（<a href="https://bitcoinops.org/en/newsletters/2018/12/28/">2018</a>、<a href="https://bitcoinops.org/en/newsletters/2019/12/28/">2019</a>、<a href="https://bitcoinops.org/en/newsletters/2020/12/23/">2020</a> 以及 <a href="https://bitcoinops.org/en/newsletters/2021/12/22/">2021</a>）的延续。</p><h2 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h2><p>一月份，LDK <a href="https://bitcoinops.org/en/newsletters/2022/01/05/#rust-lightning-1177">合并</a>了一个 “<a href="https://bitcoinops.org/en/topics/stateless-invoices/">无状态发票</a>” 的实现，这种技术允许生成无限数量的发票而不必存储任何相关数据，除非这样的发票得到支付。无状态发票的提议是在 2021 年 9 月提出的，LDK 的实现不同于建议手段，虽然它实现了相同的目标，而且不需要闪电网络协议作出任何变更。稍后，闪电网络规范合并了一项<a href="https://bitcoinops.org/en/newsletters/2022/01/12/#bolts-912">更新</a>，允许其它类型的无状态发票可以 —— 至少是部分地 —— 添加到 <a href="https://bitcoinops.org/en/newsletters/2022/01/19/#eclair-2063">Eclair</a>、<a href="https://bitcoinops.org/en/newsletters/2022/04/13/#core-lightning-5086">Core Lightning</a> 和 <a href="https://bitcoinops.org/en/newsletters/2022/04/20/#lnd-5810">LND</a> 诸客户端中。</p><p>同样在一月份，Jack Dorsey、Alex Morcos 和 Martin White <a href="https://bitcoinops.org/en/newsletters/2022/01/19/#bitcoin-and-ln-legal-defense-fund">设立</a>了一个比特币法律辩护基金（Bitcoin Legal Defense Fund），这是 “一个非营利的实体，致力于尽可能减少阻遏开发者主动开发比特币和相关项目的法律问题。”</p><h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><p>在一月份发生的，关于简化为预签名的交易增加手续费的<a href="https://bitcoinops.org/en/newsletters/2022/01/12/#fee-accounts">讨论</a>，在二月份引发了关于 Jeremy Rubin 在 2020 年提出的 “<a href="https://bitcoinops.org/en/topics/fee-sponsorship/">交易手续费赞助</a>” 想法的<a href="https://bitcoinops.org/en/newsletters/2022/02/23/#fee-bumping-and-transaction-fee-sponsorship">新一轮讨论</a>。人们提出了对这种实现的多项挑战。尽管当时的讨论没有取得太大的精湛，但一种实现了类似目标 —— 而且不像手续费赞助那样需要软分叉 —— 的技术在十月份<a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#v3-tx-relay">出现</a>了。</p><p>LKD 对<a href="https://bitcoinops.org/en/topics/stateless-invoices/">无状态发票</a>的初步支持，使它可以加入一种新的、用于闪电网络节点负载均衡的<a href="https://bitcoinops.org/en/newsletters/2022/02/23/#ldk-1199">简单</a>方法，称作 “<em>幻影节点支付</em>”。</p><p><img src="/../images/bitcoin-optech-newsletter-2022-year-in-review-special/nts.dot.png" alt="Illustration of phantom node payment path"></p><h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><p>由 René Pickhardt 和 Stefan Richter 在 2021 年首次推出的闪电网络寻路算法在三月得到了一次<a href="https://bitcoinops.org/en/newsletters/2022/03/23/#payment-delivery-algorithm-update">更新</a>，Pickhardt 指出一项优化使其计算效率提高很多。</p><p>一项与之匹配、允许开设 “<a href="https://bitcoinops.org/en/topics/zero-conf-channels/">零确认通道</a>” 的方法也形成了<a href="https://bitcoinops.org/zh/newsletters/2022/06/08/#bolts-910">规范</a>，并开始产生实现；LDK 在三月<a href="https://bitcoinops.org/en/newsletters/2022/03/23/#ldk-1311">添加</a>对相关的 “通道短标识符（SCID）” <em>昵称</em> 字段时率先起步，<a href="https://bitcoinops.org/zh/newsletters/2022/06/22/#eclair-2224">Eclair</a>、<a href="https://bitcoinops.org/zh/newsletters/2022/07/13/#core-lightning-5275">Core Lightning</a> 和 <a href="https://bitcoinops.org/zh/newsletters/2022/07/13/#lnd-5955">LND</a> 相继跟上。</p><p><img src="/../images/bitcoin-optech-newsletter-2022-year-in-review-special/hannels.png" alt="Illustration of zero-conf channels"></p><p style="text-align:center">- - -</p><h2 id="2022-总结：Replace-By-Fee"><a href="#2022-总结：Replace-By-Fee" class="headerlink" title="2022 总结：Replace-By-Fee"></a>2022 总结：Replace-By-Fee</h2><p>今年，我们看到了许多关于 “<a href="https://bitcoinops.org/en/topics/replace-by-fee/">手续费替换</a>（RBF）” 的讨论，以及一些重要的行动。我们一月份的周报<a href="https://bitcoinops.org/en/newsletters/2022/01/05/#brief-full-rbf-then-opt-in-rbf">总结</a>了一项来自 Jeremy Rubin 的提议：任意交易都可以在原版交易到达节点后的一段时间内被更高手续费的替代版本替换；超时之后，再应用现有的规则 —— 仅允许遵循 <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">BIP125</a> 的替代版本替换原版。这将允许商家在替换窗口关闭之后接受未确认的交易，就像现在这样。更重要的是，它也许可以让依赖于可替换性来实现安全性的协议不必担心未携带 BIP125 信号的交易，只要一个协议节点或者瞭望塔拥有合理的机会、在知晓一笔交易后即时响应即可。</p><p>在一月底， Gloria Zhao 开始了一场关于 RBF 的新讨论，她<a href="https://bitcoinops.org/en/newsletters/2022/02/09/#discussion-about-rbf-policy">介绍</a>了当前的 RBF 策略的背景、过去几年间发现的一些问题（例如 “<a href="https://bitcoinops.org/en/topics/transaction-pinning/">交易钉死攻击</a>”）、RBF 策略如何影响钱包软件的用户界面，以及几种可能的优化措施。在三月上旬，Zhao 追加了两场关于 RBF 的开发者讨论的<a href="https://bitcoinops.org/en/newsletters/2022/03/16/#ideas-for-improving-rbf-policy">总结</a>，一场来自线上，一场来自线下。</p><p>同样在三月，Larry Ruane 提出了跟 RBF 相关的<a href="https://bitcoinops.org/en/newsletters/2022/03/30/#transaction-witness-replacement">问题</a>：替换交易的见证数据而不改变交易的其余部分（决定 txid 的部分）。</p><p>在七月，Antoine Riard 在 Bitcoin Core 代码库<a href="https://bitcoinops.org/zh/newsletters/2022/06/22/#full-replace-by-fee">开启</a>了一个 PR，为 Bitcoin Core 添加了一个 <code>mempoolfullrbf</code> 配置选项。这个选项默认保持 Bitcoin Core 以前的行为：仅允许包含 <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">BIP125</a> 信号的未确认交易被替换。而额外配置了这个选项的节点则会接受任意替换交易并转发和挖矿，即使原版交易并不包含 BIP125 信号。Riard 也在 Bitcoin-Dev 邮件组中开启了一个帖子以讨论这一变更。几乎所有的 PR 评论都是正面的，而大部分邮件组讨论都是不相关的话题，所以并不意外地，这个 PR 在开启的大约一个月后<a href="https://bitcoinops.org/zh/newsletters/2022/07/13/#bitcoin-core-25353">合并</a>了。</p><p>在十月份，Bitcoin Core 项目开始分发 24.0 版本的候选版本 —— 24.0 将是第一个包含 <code>mempoolfullrbf</code> 配置选项的。Dario Sneidermanis 看到了候选版本的更新声明中关于这个选项的部分，于是在 Bitcoin-Dev 邮件组中<a href="https://bitcoinops.org/zh/newsletters/2022/10/19/#transaction-replacement-option">发帖</a>指出，太多用户和矿工启用这个选项会让不带信号的替换交易变成可以依靠的。而更可靠的无信号替换交易也会让接受未确认交易作为支付手段的服务商更容易遭受盗窃、迫使这些服务商改变自己的行为。讨论在接下来的<a href="https://bitcoinops.org/zh/newsletters/2022/10/26/#continued-discussion-about-full-rbf-rbf">一周</a>和<a href="https://bitcoinops.org/zh/newsletters/2022/11/02/#mempool-consistency">又一周</a>连绵不断。一个月后，Sneidermanis 在邮件组中引起了担忧的苗头，Suhas Daftuar <a href="https://bitcoinops.org/zh/newsletters/2022/11/09/#continued-discussion-about-enabling-fullrbf-rbf">总结</a> 了反对该选项的一些论证，并开启了一个将它从 Bitcoin Core 中移除的 PR。类似的其它 PR 在此前和此后都出现了，但 Daftuar 的 PR 变成了讨论有无可能永久移除这个选项的焦点。</p><p>在 Daftuar 的 PR 中出现了许多指出保留 <code>mempoolfullrbf</code> 的反面意见。包括许多钱包开发者都提到，有时候他们会遇到希望发起替换、又没有使用 BIP125 信号的用户。</p><p>在十一月末，Daftuar 关闭了这个 PR，而且 Bitcoin Core 项目也放出了带有 <code>mempoolfullrbf</code> 的 24.0。在十二月，开发者 0xB10C <a href="https://bitcoinops.org/zh/newsletters/2022/12/14/#rbf">推出</a>了一个网站，用于监控并不包含 BIP125 信号的替换交易；这样的交易如果能得到确认，则表明它可能由一个使用 <code>mempoolfullrbf</code> 配置选项（或带有类似特性的其它软件）开启全面 RBF（full-RBF）的矿工经手。至今年年底，全面 RBF 依然在其它的 Bitcoin Core PR 和邮件组帖子中被讨论。</p><p style="text-align:center">- - -</p><h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><p>四月份，Ruben Somsen <a href="https://bitcoinops.org/en/newsletters/2022/04/06/#delinked-reusable-addresses">提出</a>了 “<a href="https://bitcoinops.org/en/topics/silent-payments/">静默支付</a>” 的想法，它将允许人们给一个公开的标识符（近似于 “地址”）支付，但不必在链上显示出这个标识符。这可以帮助防止<a href="https://bitcoinops.org/en/topics/output-linking/">地址复用</a>。举个例子，Alice 可以在自己的网页中发布一个公开标识符，而 Bob 可以将这个标识符转化为一个独一无二的、只有 Alice 可以花费的比特币地址。如果 Carol 后来访问 Alice 的网站，并复用 Alice 的标识符，她将推导出另一个地址；这个地址无论是 Bob 还是其它第三方，都无法直接断定是否属于 Alice。后来，开发者 W0ltx 为 Bitcoin Core 创建了静默支付的一个<a href="https://bitcoinops.org/en/newsletters/2022/06/01/#experimentation-with-silent-payments">提议实现</a>，并在稍后取得了<a href="https://bitcoinops.org/zh/newsletters/2022/08/24/#pr">重大进展</a>。</p><p>Lightning Labs <a href="https://bitcoinops.org/en/newsletters/2022/04/13/#transferable-token-scheme">推出</a>了 Taro，这个协议（基于以前的提议）允许用户将非比特币的代币的创建和转移承诺到比特币区块链上。Taro 旨在跟闪电网络一起使用，实现可路由的链下转账。类似于以前的闪电网络跨资产转账提议，仅仅转发支付的中间节点不需要理解 Taro 协议，也不需要知道被转移的资产的细节 —— 他们只需使用跟其它闪电支付同样的协议，转移比特币即可。</p><p>四月份还出现了关于量子安全的密钥交换的<a href="https://bitcoinops.org/en/newsletters/2022/04/20/#quantum-safe-key-exchange">讨论</a>；未来可能出现快速的量子计算机，但量子安全的密钥交换将允许用户使用可以<a href="https://bitcoinops.org/en/topics/quantum-resistance/">抵御</a>这样的量子计算攻击的密钥来接收比特币。这份特别版的 Optech Newsletter 总结了 2022 年全年比特币值得注意的发展。 这是我们的年终总结系列（<a href="https://bitcoinops.org/en/newsletters/2018/12/28/">2018</a>、<a href="https://bitcoinops.org/en/newsletters/2019/12/28/">2019</a>、<a href="https://bitcoinops.org/en/newsletters/2020/12/23/">2020</a> 以及 <a href="https://bitcoinops.org/en/newsletters/2021/12/22/">2021</a>）的延续。</p><h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><p>用于创建 <a href="https://bitcoinops.org/en/topics/multisignature/">schnorr 多签</a> 的 <a href="https://bitcoinops.org/en/topics/musig/">MuSig2</a> 协议在 2022 年取得了一些进展。<a href="https://bitcoinops.org/en/newsletters/2022/04/13/#musig2-proposed-bip">提议的一个 BIP</a> 在 5 月收到了重要的 <a href="https://bitcoinops.org/en/newsletters/2022/05/04/#musig2-implementation-notes">反馈</a>。后来，在 10 月，Yannick Seurin、Tim Ruffing、Elliott Jin 和 Jonas Nick 发现了一个 <a href="https://bitcoinops.org/zh/newsletters/2022/10/19/#musig2">漏洞</a>：该协议在某些方式下可被利用。研究人员宣布他们计划在更新版本中修复该漏洞。</p><p><a href="https://bitcoinops.org/en/topics/package-relay/">包中继</a> 的 BIP 草案由 Gloria Zhao 在 5 月<a href="https://bitcoinops.org/en/newsletters/2022/05/25/#package-relay-proposal">发布</a>。包中继修复了 Bitcoin Core <a href="https://bitcoinops.org/en/topics/cpfp/">CPFP 手续费追加</a>这一重大问题。这个问题是如果其父交易支付的费率高于节点的动态最低交易池手续费，则各个节点只会接受手续费追加的子交易。这使得 CPFP 对依赖于预签名交易的协议来说不够可靠，例如许多合约协议（包括当前的闪电网络协议）。包中继允许将父交易和子交易看作是一个单位进行评估，从而消除了上述问题——尽管没有消除其他相关问题，例如<a href="https://bitcoinops.org/en/topics/transaction-pinning/">交易钉死</a>。在 6 月份，<a href="https://bitcoinops.org/zh/newsletters/2022/06/15/#continued-package-relay-bip-discussion">有</a>更多关于包中继的讨论。</p><p>在 5 月份，我们还见证了比特币内核库项目（libbitcoinkernel）的<a href="https://bitcoinops.org/en/newsletters/2022/05/04/#bitcoin-core-24322">第一次合并</a>，试图将尽可能多的 Bitcoin Core 共识代码分离到一个单独的库中，即使该代码仍附带有一些非共识代码。从长远来看，这一目标是精简 libbitcoinkernel 到只包含共识代码，让其他项目可以轻松使用该代码或让审计人员分析对 Bitcoin Core 的共识逻辑的变更。几个额外的 libbitcoinkernel PR 也在今年合并。</p><p style="text-align:center">- - -</p><h2 id="2022-总结：流行基础设施项目的主要发布"><a href="#2022-总结：流行基础设施项目的主要发布" class="headerlink" title="2022 总结：流行基础设施项目的主要发布"></a>2022 总结：流行基础设施项目的主要发布</h2><ul><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#eclair-0-7-0">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/02/02/#eclair-0-7-0">Eclair 0.7.0</a> 添加了对<a href="https://bitcoinops.org/en/topics/anchor-outputs/">锚点输出</a>、中继<a href="https://bitcoinops.org/en/topics/onion-messages/">洋葱消息</a>以及在生产环境中使用 PostgreSQL 数据库的支持。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#btcpay-server-1-4">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/03/02/#btcpay-server-1-4-6">BTCPay Server 1.4</a> 添加了对 <a href="https://bitcoinops.org/en/topics/cpfp/">CPFP 手续费追加</a> 的支持、可使用 LN URL 的更多功能以及多个 UI 改进。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#ldk-0-0-105">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/03/09/#ldk-0-0-105">LDK 0.0.105</a> 添加了对幻影节点支付的支持以及支付寻路概率的优化。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#bdk-0-17-0">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/03/30/#bdk-0-17-0">BDK 0.17.0</a> 可更容易地派生地址，甚至是当钱包处于离线状态时。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#bitcoin-core-23-0">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/04/27/#bitcoin-core-23-0">Bitcoin Core 23.0</a> 默认为新钱包提供<a href="https://bitcoinops.org/en/topics/output-script-descriptors/">描述符</a>钱包，还允许描述符钱包以轻松支持使用 <a href="https://bitcoinops.org/en/topics/taproot/">taproot</a> 接收到 <a href="https://bitcoinops.org/en/topics/bech32/">bech32m</a> 地址。它还增加了对使用非默认 TCP/IP 端口的支持，并开始允许使用 <a href="https://github.com/cjdelisle/cjdns">CJDNS</a> 网络覆盖。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#core-lightning-0-11-0">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/04/27/#core-lightning-0-11-0">Core Lightning 0.11.0</a> 添加了对同一对方节点的多个活跃通道以及支付<a href="https://bitcoinops.org/en/topics/stateless-invoices/">无状态发票</a>的支持。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#rust-bitcoin-0-28">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/04/27/#rust-bitcoin-0-28">Rust Bitcoin 0.28</a> 添加了对 <a href="https://bitcoinops.org/en/topics/taproot/">taproot</a> 的支持并改进了相关 API，例如 <a href="https://bitcoinops.org/en/topics/psbt/">PSBTs</a>。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#btcpay-1-5-1">●</a> <a href="https://bitcoinops.org/en/newsletters/2022/05/04/#btcpay-server-1-5-1">BTCPay 服务器 1.5.1</a> 添加了一个新的首页仪表板、一个新的转账处理器功能以及可自动批准拉取付款和退款的能力。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#ldk-0-0-108-0-0-107">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/06/22/#ldk-0-0-108">LDK 0.0.108 和 0.0.107</a> 增加了对<a href="https://bitcoinops.org/en/topics/large-channels/">大通道</a>和<a href="https://bitcoinops.org/en/topics/zero-conf-channels/">零确认通道</a>的支持；此外，还提供了可使移动客户端从服务器同步网络路由信息（即 gossip）的代码。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#bdk-0-19-0">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/06/22/#bdk-0-19-0">BDK 0.19.0</a> 通过<a href="https://bitcoinops.org/en/topics/output-script-descriptors/">描述符</a>、<a href="https://bitcoinops.org/en/topics/psbt/">PSBTs</a> 和其他子系统添加了对 <a href="https://bitcoinops.org/en/topics/taproot/">taproot</a> 的实验性支持。它还添加了一个新的<a href="https://bitcoinops.org/en/topics/coin-selection/">选币</a>算法。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#lnd-0-15-0-beta">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/06/29/#lnd-0-15-0-beta">LND 0.15.0-beta</a> 添加了对发票元数据的支持。发票元数据可用于<a href="https://bitcoinops.org/en/topics/stateless-invoices/">无状态发票</a>的其他程序（以及 LND 潜在的未来版本）。该版本还支持对内部钱包接收和花费比特币到 <a href="https://bitcoinops.org/en/topics/taproot/">P2TR</a> keyspend 输出以及实验性的 <a href="https://bitcoinops.org/en/topics/musig/">MuSig2</a>。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#rust-bitcoin-0-29">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/08/17/#rust-bitcoin-0-29">Rust Bitcoin 0.29</a> 添加了<a href="https://bitcoinops.org/en/topics/compact-block-relay/">致密区块中继</a>的数据结构（<a href="https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki">BIP152</a>）并改进了对 <a href="https://bitcoinops.org/en/topics/taproot/">taproot</a> 和 <a href="https://bitcoinops.org/en/topics/psbt/">PSBT</a> 的支持。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#core-lightning-0-12-0">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/08/24/#core-lightning-0-12-0">Core Lightning 0.12.0</a> 添加了一个新的 <code>bookkeeper</code> 插件、一个 <code>commando</code> 插件以及对<a href="https://bitcoinops.org/en/topics/static-channel-backups/">静态通道备份</a>的支持，并明确开始允许对方节点能够打开连接到你节点的<a href="https://bitcoinops.org/en/topics/zero-conf-channels/">零确认通道</a>。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#lnd-0-15-1-beta">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/08/31/#lnd-0-15-1-beta">LND 0.15.1-beta</a> 添加了对<a href="https://bitcoinops.org/en/topics/zero-conf-channels/">零确认通道</a>和通道别名的支持，并可以在任何地方使用 <a href="https://bitcoinops.org/en/topics/taproot/">taproot</a> 地址。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#ldk-0-0-111">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/09/14/#ldk-0-0-111">LDK 0.0.111</a> 添加了对创建、接收和中继<a href="https://bitcoinops.org/en/topics/onion-messages/">洋葱消息</a>的支持。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#core-lightning-22-11">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/12/07/#core-lightning-22-11">Core Lightning 22.11</a> 开始使用新的版本编号方案并添加了新的插件管理器。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#libsecp256k1-0-2-0">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/12/14/#libsecp256k1-0-2-0">libsecp256k1 0.2.0</a> 是这个被广泛采用的比特币相关密码学操作库的第一个被打标签的发布版本。</li><li><a href="https://bitcoinops.org/zh/newsletters/2022/12/21/#bitcoin-core-24-0-1">●</a> <a href="https://bitcoinops.org/zh/newsletters/2022/12/14/#bitcoin-core-24-0-1">Bitcoin Core 24.0.1</a> 添加了一个用于配置节点的<a href="https://bitcoinops.org/en/topics/replace-by-fee/">费用替换</a>（RBF）策略的选项、一个新的用于在单笔交易中很容易花费所有钱包资金的 <code>sendall</code> RPC、一个可用于验证一笔交易将如何影响钱包的 <code>simulaterawtransaction</code> RPC，以及创建仅观察的<a href="https://bitcoinops.org/en/topics/output-script-descriptors/">描述符</a>的能力（其中包含 <a href="https://bitcoinops.org/en/topics/miniscript/">miniscript</a> 表达式的以提高与其他软件的向前兼容性）。</li></ul><p style="text-align:center">- - -</p><h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><p>6 月，闪电网络开发人员<a href="https://bitcoinops.org/zh/newsletters/2022/06/15/#summary-of-ln-developer-meeting">开会</a>讨论协议开发的未来。讨论的主题包括基于 <a href="https://bitcoinops.org/en/topics/taproot/">taproot</a> 的闪电网络通道、<a href="https://bitcoinops.org/en/topics/tapscript/">tapscript</a> 和 <a href="https://bitcoinops.org/en/topics/musig/">MuSig2</a>（包括递归 MuSig2）、更新 gossip 协议以公告新通道及已变更通道、<a href="https://bitcoinops.org/en/topics/onion-messages/">洋葱消息</a>，<a href="https://bitcoinops.org/en/topics/rendez-vous-routing/">盲化路径</a>、探测（probing）及余额共享、<a href="https://bitcoinops.org/en/topics/trampoline-payments/">蹦床（trampoline）路由</a>、<a href="https://bitcoinops.org/en/topics/offers/">要约（offers）</a> 和 LNURL 协议。</p><h2 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h2><p>7 月，Bastien Teinturier <a href="https://bitcoinops.org/zh/newsletters/2022/07/06/#onion-message-rate-limiting">发布</a>了一篇关于限制<a href="https://bitcoinops.org/en/topics/onion-messages/">洋葱消息</a>以防止拒绝服务攻击想法的摘要。他将该想法归功于 Rusty Russell。但是，Olaoluwa Osuntokun 建议可以重新考虑他在 3 月份的<a href="https://bitcoinops.org/en/newsletters/2022/03/09/#paying-for-onion-messages">提案</a>。该提案通过对数据中继收费来防止滥用洋葱消息。参与讨论的大多数开发人员似乎更愿意在向协议添加额外费用之前先尝试限制速率。</p><p>本月 Bitcoin Core 还<a href="https://bitcoinops.org/zh/newsletters/2022/07/20/#bitcoin-core-24148">合并了一个 pull request</a>，添加了对用 <a href="https://bitcoinops.org/en/topics/miniscript/">miniscript</a> 编写的<a href="https://bitcoinops.org/en/topics/output-script-descriptors/">输出脚本描述符</a>仅观察模式的支持。我们预计未来的 PR 将允许钱包为基于 miniscript 的描述符创建签名。随着其他钱包和签名设备实现 miniscript 支持，在钱包之间转移策略、多个钱包合作花费比特币应该变得更容易，例如多重签名策略或者那些涉及到不同签名者在不同场合下的策略（例如后备签名者）。</p><h2 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h2><p>8 月，Eclair <a href="https://bitcoinops.org/zh/newsletters/2022/08/17/#eclair-2273">合并了</a>一项对交互式充值协议的支持。<a href="https://bitcoinops.org/en/topics/dual-funding/">双重充值协议</a>依赖于该支持。双重充值协议允许两个节点中的任何一个（或共同）为新的闪电网络通道充值。当月晚些时候，另一项<a href="https://bitcoinops.org/zh/newsletters/2022/08/31/#eclair-2275">合并</a>使 Eclair 开始对双重充值进行实验性支持。双重充值的开放协议有助于确保商家能够访问那些能立即收到客户付款的通道。</p><p>Antoine Riard 和 Gleb Naumenko <a href="https://bitcoinops.org/zh/newsletters/2022/08/24/#overview-of-channel-jamming-attacks-and-mitigations">发布了</a>一份关于<a href="https://bitcoinops.org/en/topics/channel-jamming-attacks/">通道阻塞攻击</a>及其若干建议解决方案的指南。对于攻击者控制的每个通道，他们可以通过发送永远不会完成的付款使十多个其他通道无法使用——这意味着攻击者不需要支付任何直接成本。该问题自 2015 年以来就已为人所知，但之前提出的解决方案均未获得广泛接受。 在之后的 11 月，Clara Shikhelman 和 Sergei Tikhomirov 将发表他们自己的<a href="https://bitcoinops.org/zh/newsletters/2022/11/16/#paper-about-channel-jamming-attacks">论文</a>。论文中有对此的分析和建议的解决方案，包括基于小额预付费用和基于信誉自动推荐。随后，Riard <a href="https://bitcoinops.org/zh/newsletters/2022/11/30/#reputation-credentials-proposal-to-mitigate-ln-jamming-attacks">发表了</a>一个使用特定于节点、不可交易令牌的替代解决方案。在之后的 12 月，Joost Jager 将<a href="https://bitcoinops.org/zh/newsletters/2022/12/14/#local-jamming-to-prevent-remote-jamming">宣布</a>一个“简单但不完美”的实用程序，可以帮助节点减轻一些阻塞问题，而无需对闪电网络协议进行任何更改。</p><p><img src="/../images/bitcoin-optech-newsletter-2022-year-in-review-special/attacks.png" alt="Illustration of the two types of channel jamming attacks"></p><p>Lloyd Fournier <a href="https://bitcoinops.org/zh/newsletters/2022/08/17/#using-bitcoincompatible-bls-signatures-for-dlcs-bls-dlc">写了一篇</a>关于 <a href="https://bitcoinops.org/en/topics/discreet-log-contracts/">DLC</a> 预言机使用 Boneh-Lynn-Shacham（<a href="https://en.wikipedia.org/wiki/BLS_digital_signature">BLS</a>）签名进行证明的好处。比特币不支持 BLS 签名，需要软分叉才能添加它们，但 Fournier 给出了他合着的一篇论文链接。该论文描述了如何从 BLS 签名中安全地提取信息，将该信息用在与比特币兼容的<a href="https://bitcoinops.org/en/topics/adaptor-signatures/">签名适配器</a>中而不对比特币进行任何变更。这将允许“无状态”预言机，其中合约各方（但不是预言机）可以私下同意他们希望预言机证明哪些信息，例如，通过指定一个程序。而该程序可用他们所知预言机可以运行的任何编程语言来编写。</p><p>然后他们可以根据合约分配他们的存款资金，甚至不需要告知预言机他们计划使用它。到了结算合约的时候，每一方都可以自己运行程序。如果他们都同意运行结果，就可以合作结算合约，根本不需要预言机的参与；如果他们不同意，他们中的任何一方都可以将程序发送到预言机（可能需要为其服务支付少量费用）并收到 BLS 对程序源代码的证明以及运行程序的返回值。证明可以转换为允许在链上结算 DLC 的签名。与当前的 DLC 合约一样，预言机无法根据其 BLS 签名知道是哪些链上交易。</p><p style="text-align:center">- - -</p><h2 id="2022-总结：Bitcoin-Optech"><a href="#2022-总结：Bitcoin-Optech" class="headerlink" title="2022 总结：Bitcoin Optech"></a>2022 总结：Bitcoin Optech</h2><p>在 Optech 的第五年，我们发布了 51 份<a href="https://bitcoinops.org/zh/newsletters/">周报</a>，并在我们的<a href="https://bitcoinops.org/en/topics/">主题索引</a>中新增了 11 个页面。 Optech 今年总共发表了超过 70,000 字的有关比特币软件研发的文章，大致相当于一本 200 页的书。</p><p style="text-align:center">- - -</p><h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><p>Lisa Neigut 在 Lightning-Dev 邮件列表中<a href="https://bitcoinops.org/zh/newsletters/2022/09/28/#ln-fee-ratecards">发表了</a>一个费率卡的提案。该提案允许节点宣传其转发费用的四级费率。更好地宣传转发费用，包括在某些情况下设置负费用的能力，可以帮助确保转发节点有足够的容量将付款中继到最终目的地。开发人员 ZmnSCPxj 在今年早些时候曾<a href="https://bitcoinops.org/zh/newsletters/2022/06/15/#using-routing-fees-to-signal-liquidity">发布</a>了他自己基于费用来改进路由的解决方案。这是一种使用费率卡的简单方法，“你可以将价目表建模为相同两个节点间的四个独立通道，每个都有不同的成本。如果成本最低的路径失败了，你只需尝试另一条可能有更多跳数但有效成本较低的路由，或者以更高的成本尝试相同的通道。” René Pickhardt <a href="https://bitcoinops.org/zh/newsletters/2022/10/05/#ln-flow-control">建议了</a>一个支付流量控制的替代方法。</p><h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><p>在十月，Gloria Zhao <a href="https://bitcoinops.org/zh/newsletters/2022/10/05/#ln-penalty">提出</a>允许使用版本号 3 的交易运用修改后的交易中继策略组。这些策略基于使用 <a href="https://bitcoinops.org/en/topics/cpfp/">CPFP</a> 和 <a href="https://bitcoinops.org/en/topics/replace-by-fee/">RBF</a> 的经验，并增添了打包中继的思想。设计这些策略是为了帮助防止 LN 等两方合约协议中的钉死攻击 —— 确保用户能够及时得到交易确认，以关闭通道，结算付款 (<a href="https://bitcoinops.org/en/topics/htlc/">HTLCs</a>) ，并对不当行为进行强制惩罚。Greg Sanders 在本月晚些时候<a href="https://bitcoinops.org/zh/newsletters/2022/10/26/#ephemeral-anchors">跟进</a>，提出一个关于<em>临时锚点</em>的额外提议，一种已经在大多数 LN 实现中应用的<a href="https://bitcoinops.org/en/topics/anchor-outputs/">锚点输出</a>的简单形式。</p><p>Eclair 增加了在使用<a href="https://bitcoinops.org/en/topics/trampoline-payments/">蹦床中继</a>时对基础形式的异步付款的<a href="https://bitcoinops.org/zh/newsletters/2022/10/05/#eclair-2435">支持</a>。异步付款允许在无需信任有资产的第三方的情况下向离线节点（例如手机钱包）支付。异步支付的理想机制依赖 <a href="https://bitcoinops.org/en/topics/ptlc/">PTLCs</a>，但为其部分实现，仅需要第三方延迟转发资金，直到离线节点恢复上线。蹦床节点可以提供这种延迟，因此这个 PR 利用它们来进行异步支付的实验。</p><p>十月同样出现了两个影响多个应用程序的区块解析<a href="https://bitcoinops.org/zh/newsletters/2022/10/19/#btcd-lnd">错误</a>。BTCD 的一个意外触发的错误使它和下游程序 LND 无法处理最新的区块。这会让用户丢失资产，尽管尚未报告此类问题。<a href="https://bitcoinops.org/zh/newsletters/2022/11/09/#block-parsing-bug-affecting-multiple-software-bug">第二个</a>相关错误此次被故意触发，再次影响了 BTCD 和 LND 以及某些版本的 Rust-Bitcoin 的用户。同样，可能有用户失去资金，尽管我们尚未得到此类事件报告。</p><p>John Light <a href="https://bitcoinops.org/zh/newsletters/2022/10/19/#rollup">发布</a>了一篇关于 validity rollups 的研究报告 —— 一种侧链，其当前状态被紧凑地存储在主链上。侧链比特币的所有者可以使用存储在主链上的状态来证明他们控制了多少个侧链比特币。通过提交带有有效性证明的主链交易，他们可以从侧链上提取其拥有的比特币，即使侧链的运营商或矿工试图阻止。Light 的研究深入描述了 validity rollups，研究了如何在比特币中支持它及实施中的各种担忧。</p><p><a href="https://github.com/dhruv/bips/blob/bip324/bip-0324.mediawiki">BIP324</a> 提案更新了，并得到了三年内的首次邮件列表讨论。BIP324 是关于<a href="https://bitcoinops.org/zh/newsletters/2022/10/19/#bip324">加密的 v2 P2P 传输协议</a>。对未经确认的交易进行加密传输，有助于隐藏其来源，不被控制许多互联网中继的窃听者（如大型 ISP 和政府）发现。它还可以帮助检测篡改，并可能使<a href="https://bitcoinops.org/en/topics/eclipse-attacks/">日蚀攻击</a>更加困难。</p><p>一次比特币协议开发者会议中，Bryan Bishop <a href="https://bitcoinops.org/zh/newsletters/2022/10/26/#coredevtech-transcripts-coredev-tech">主持</a> 了几项议题讨论，包括<a href="https://bitcoinops.org/en/topics/v2-p2p-transport/">传输加密</a>、交易费和<a href="https://bitcoinops.org/en/topics/fee-sniping/">经济安全性</a>、 FROST <a href="https://bitcoinops.org/en/topics/threshold-signature/">门限签名</a>方案、使用GitHub进行源代码托管和开发讨论的可持续性、BIP 中的可证明规范、<a href="https://bitcoinops.org/en/topics/package-relay/">包中继</a>和 <a href="https://bitcoinops.org/en/topics/version-3-transaction-relay/">v3 交易中继</a>、Stratum 第二版采矿协议、以及让代码合并到比特币核心和其他自由软件项目。</p><p style="text-align:center">- - -</p><h2 id="2022-年软分叉提议总结"><a href="#2022-年软分叉提议总结" class="headerlink" title="2022 年软分叉提议总结"></a>2022 年软分叉提议总结</h2><p>一月伴随着 Jeremy Rubin <a href="https://bitcoinops.org/en/newsletters/2022/01/19/#irc-meeting">举行</a>第一次 IRC 会议，审核和讨论 <a href="https://bitcoinops.org/en/topics/op_checktemplateverify/">OP_CHECKTEMPLATEVERIFY</a>(CTV) 软分叉提案。同时，Peter Todd 在 Bitcoin-Dev 邮件列表中<a href="https://bitcoinops.org/en/newsletters/2022/01/19/#mailing-list-discussion">发布</a>了对该提案的一些担忧，最值得注意的是，他认为此前的软分叉已经使几乎所有比特币用户受益。</p><p>Lloyd Fournier 在 DLC-Dev 和 Bitcoin-Dev 邮件列表中<a href="https://bitcoinops.org/en/newsletters/2022/02/02/#improving-dlc-efficiency-by-changing-script">发布</a>了CTV操作码如何从根本上减少创建某些 <a href="https://bitcoinops.org/en/topics/discreet-log-contracts/">谨慎日志合约</a>（DLC）所需的签名数量，以及减少一些其他操作的数量。Jonas Nick 指出，使用提议的 <a href="https://bitcoinops.org/en/topics/sighash_anyprevout/">SIGHASH_ANYPREVOUT</a> (APO)签名哈希模式也可以进行类似的优化。</p><p>Russell O’Connor <a href="https://bitcoinops.org/en/newsletters/2022/02/02/#composable-alternatives-to-ctv-and-apo">提议</a>了 CTV 和 APO 的替代方案——一个软分叉，增加了一个 “OP_TXHASH” 操作码和一个 <a href="https://bitcoinops.org/en/topics/op_checksigfromstack/">OP_CHECKSIGFROMSTACK</a>（CSFS）操作码。TXHASH 操作码将指定一个花费交易的哪些部分应该被序列化和散列化，其散列摘要将被放在评估堆栈中供以后的操作码使用。CSFS 操作码将指定一个公钥，并要求对堆栈上的特定数据进行相应的签名，例如由 TXHASH 创建的交易摘要。这将允许以一种可能更简单、更灵活、更容易通过其他后续软分叉扩展的方式来模拟 CTV 和 APO。</p><p>二月，Rusty Russell <a href="https://bitcoinops.org/en/newsletters/2022/02/16/#simplified-alternative-to-op-txhash">提出</a> <code>OP_TX</code>，这是 <code>OP_TXHASH</code> 的一个更简单的版本。同时，Jeremy Rubin <a href="https://bitcoinops.org/en/newsletters/2022/02/23/#ctv-signet">发表了</a>激活 CTV 的 <a href="https://bitcoinops.org/en/topics/signet/">Signet</a>的参数和代码。这简化了提议的操作码的公开实验，并使使用该代码的不同软件之间的兼容性测试变得更加容易。同样在 2 月，开发者 ZmnSCPxj 提出了一个新的操作码 <code>OP_EVICT</code>，作为 2021 年提出的操作码 <code>OP_TAPLEAF_UPDATE_VERIFY</code>（TLUV）的替代。与 TLUV 一样，EVICT 专注于两个以上用户共享单个 UTXO 所有权的用例，如 <a href="https://bitcoinops.org/en/topics/joinpools/">joinpools</a>、<a href="https://bitcoinops.org/en/topics/channel-factories/">channel factories</a> 和某些 <a href="https://bitcoinops.org/en/topics/covenants/">covenants</a>。ZmnSCPxj 后来<a href="https://bitcoinops.org/en/newsletters/2022/03/16/#looping-folding">提出</a>一个不同的新操作码，<code>OP_FOLD</code>，作为一个可以建立类似 EVICT的行为的更通用的构造（尽管这需要一些其他脚本语言的改变）。</p><p>到了三月，关于 CTV 和较新的操作码提案的讨论导致了关于限制比特币脚本语言的表现力的<a href="https://bitcoinops.org/en/newsletters/2022/03/09/#limiting-script-language-expressiveness">讨论</a>，主要是为了防止<em>递归契约</em>——在重新花费这些比特币及与其合并的比特币的每笔交易中都需要永远满足这些条件。担心的问题包括失去抗审查能力，启用<a href="https://bitcoinops.org/en/topics/sidechains/">驱动链</a>，鼓励不必要的计算，并使用户有可能因递归契约而意外地丢币。</p><p>三月还见证了另一个对比特币的脚本语言进行软分叉的想法，这次是允许未来的交易选择使用一种完全不同的基于 Lisp 的语言。Anthony Towns <a href="https://bitcoinops.org/en/newsletters/2022/03/16/#using-chia-lisp">提议</a>了这个想法，并描述了它如何比 Script 以及之前提议的替代品 <a href="https://bitcoinops.org/en/topics/simplicity/">Simplicity</a>更好。</p><p>四月，Jeremy Rubin 在 Bitcoin-Dev 邮件列表<a href="https://bitcoinops.org/en/newsletters/2022/04/27/#discussion-about-activating-ctv">发布</a>了发布软件的计划，该软件允许矿工开始示意他们是否打算强制执行针对拟议的 CTV 操作码的 <a href="https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki">BIP119</a> 规则。这引发了关于 CTV 和类似建议的讨论，如 APO。Rubin 后来宣布，由于他和其他 CTV 支持者评估了他们收到的反馈，他目前不会发布激活 CTV 的编译软件。</p><p>五月，Rusty Russell <a href="https://bitcoinops.org/en/newsletters/2022/05/18/#updated-op-tx-proposal">更新</a>了他的 <code>OP_TX</code> 提案。最初的提议将允许递归契约，这引起了本节前面提到的担忧。取而代之的是，Russell 提出了一个 TX 的初始版本，仅限于允许 CTV 的行为，CTV 是专门为防止递归契约而设计的。这个新版本的 TX 可以在未来逐步更新，以提供更多的功能，使其更加强大，但也允许对这些新功能进行独立分析。五月的附加讨论<a href="https://bitcoinops.org/en/newsletters/2022/05/18/#when-would-enabling-op-cat-allow-recursive-covenants">考察</a>了 <code>OP_CAT</code> 操作码（2010年从比特币中删除），一些开发者偶发建议将来可将其作为添加的候选操作码。</p><p>九月，Jeremy Rubin <a href="https://bitcoinops.org/zh/newsletters/2022/09/21/#apo-drivechains">描述了</a>如何将可信设置程序与提议的 APO 特性相结合，实现类似于<a href="https://bitcoinops.org/en/topics/sidechains/">驱动链</a>所提议的行为。防止驱动链在比特币上的实施是开发者 ZmnSCPxj 在今年早些时候建议全节点运营商反对实现了递归契约的软分叉的原因之一。</p><p>同样在九月，Anthony Towns <a href="https://bitcoinops.org/zh/newsletters/2022/09/28/#bitcoin-implementation-designed-for-testing-soft-forks-on-signet-signet">宣布</a>一个专门为测试软分叉而设计的比特币实现 <a href="https://bitcoinops.org/en/topics/signet/">signet</a>。基于比特币核心，Towns 的代码将以高质量的规范和实现来执行软分叉提案的规则，使用户更简单地尝试拟议的更改——包括相互比较更改或看到它们的互动方式。Towns 还计划加入对交易中继政策（如<a href="https://bitcoinops.org/en/topics/package-relay/">包中继</a>）提议的重大改变。</p><p>十一月，Salvatore Ingala 在 Bitcoin-Dev 邮件列表中<a href="https://bitcoinops.org/zh/newsletters/2022/11/16/#general-smart-contracts-in-bitcoin-via-covenants">发布</a>了一个提议，提出了一个新的契约类型（需要一个软分叉），允许使用默克尔树来创建智能合约，此合约可以在一笔链上交易到另一笔链上交易中携带状态。这将与其他一些密码货币系统智能合约的应用类似，但与比特币现有的基于 UTXO 的系统兼容。</p><p style="text-align:center">- - -</p><h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><p>十一月见证了 Joost Jager <a href="https://bitcoinops.org/zh/newsletters/2022/11/02/#ln-routing-failure-attribution">更新</a>了 2019 年的一份提案，该提案用于改善 LN 中失败支付的错误报告。该错误将指明未能由节点转发付款的通道的身份，这样花费者可以在有限时间内避免使用包含该节点的通道。一些 LN 的实现将更新代码支持此提案，即使他们不会立即开始使用。这些实现包括 <a href="https://bitcoinops.org/zh/newsletters/2022/11/09/#eclair-2441">Eclair</a> 和 <a href="https://bitcoinops.org/zh/newsletters/2022/11/16/#core-lightning-5698">Core Lightning</a>。</p><h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><p>在十二 月，协议开发者 John Law 在 Lightning-Dev 邮件列表中发表了他今年的第三份主要提案。如前两份提案，他提出了 LN 的链外交易的新设计方式，以在不对比特币的共识代码进行任何修改的情况下实现新的功能。总的来说，Law 提出了 LN 临时用户可以一次<a href="https://bitcoinops.org/zh/newsletters/2022/10/12/#ln-with-long-timeouts-proposal">保持离线</a>状态数月的方式，将特定付款的执行与已结算资产的管理<a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2022-October/003732.html">分离</a>，以提高与<a href="https://bitcoinops.org/en/topics/watchtowers/">瞭望塔</a>的兼容性，并<a href="https://bitcoinops.org/zh/newsletters/2022/12/14/#factory-optimized-ln-protocol-proposal">优化</a><a href="https://bitcoinops.org/en/topics/channel-factories/">通道工厂</a>中 LN 通道的使用，这可以大规模降低使用 LN 的链上开销。</p><p><em>我们感谢所有前文中列出姓名的比特币的贡献者，并感谢做出同样重要工作的其他人，他们为比特币的发展创造了难以置信的另一年。Optech 周报将于 1 月 4 日恢复常规周三出版计划。</em></p><p>（完）</p>]]></content>
    
    
    <summary type="html">年终总结系列的续篇</summary>
    
    
    
    <category term="比特币主网" scheme="https://www.btcstudy.org/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BB%E7%BD%91/"/>
    
    
    <category term="比特币" scheme="https://www.btcstudy.org/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>LSAT：使用比特币闪电支付的匿名身份认证</title>
    <link href="https://www.btcstudy.org/2022/12/23/lsats-pseudonymous-authentication-using-bitcoin-lightning-payments/"/>
    <id>https://www.btcstudy.org/2022/12/23/lsats-pseudonymous-authentication-using-bitcoin-lightning-payments/</id>
    <published>2022-12-23T13:39:09.000Z</published>
    <updated>2023-01-12T06:01:27.478Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Tierion</em></p><p><em>来源：<a href="https://medium.com/tierion/lsats-pseudonymous-authentication-using-bitcoin-lightning-payments-459e209b4b36">https://medium.com/tierion/lsats-pseudonymous-authentication-using-bitcoin-lightning-payments-459e209b4b36</a></em></p></blockquote><p><img src="/../images/lsats-pseudonymous-authentication-using-bitcoin-lightning-payments/D0HDK2Q.png" alt="img"></p><p>几个月来，我们一直在跟 <a href="https://lightning.engineering/">Lightning Labs</a> 的工程师们开发闪电网络服务身份认证 Token（Lightning Service Authentication Tokens, LSATs）。我们的目标是让用户面对服务端可以验证自己的身份，而无需要求用户创建账户和存储任何用户的数据。LAST 结合了闪电网络上的比特币微支付，以及 <code>402: Payment Required</code> HTTP 状态码、<a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/41892.pdf">macaroons</a> 以及身份验证头这样的标准。今天我们将推出一系列的开源工具，让开发者们可以创建自己的 LSAT 应用程序。</p><ul><li><p><a href="https://github.com/Tierion/boltwall">Boltwall</a></p></li><li><p><a href="https://github.com/tierion/now-boltwall">Now-Boltwall</a></p></li><li><p><a href="https://github.com/Tierion/lsat-js">LSAT-js</a></p></li><li><p><a href="https://lsat-playground.bucko.now.sh/">LSAT Playground</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2></li></ul><p>身份验证和授权是许多互联网和手机应用的前提。身份验证确定是谁在发出请求，而授权则为用户设定许可。</p><p>现在的身份验证实现有两个显著的缺点。其一，它们依赖于第三方来存储敏感数据。这些信息经常遭到窃取或泄露，让用户处于风险之中。其二，用户的真实身份常常被身份验证关联起来。将你的真实身份绑定到第三方的身份验证服务（比如 Google 和 Facebook），会暴露你在使用什么服务、使用的频率如何。</p><p>在 2019 年，Tierion 开始开发这些问题的解决方案。我们推出了 <a href="https://medium.com/tierion/boltwall-middleware-for-lightning-payments-authorization-e3a1dbb54a4c">Boltwall</a>，一种用于部署闪电网络付费服务的中间件。Boltwall 的初版使用了一种不记名的凭证，叫做 “<a href="http://hackingdistributed.com/2014/05/16/macaroons-are-better-than-cookies/">macaroons</a>”（直译为 “马卡龙”），是关联到闪电网络发票的。请求会基于发票是否得到支付而得到许可。</p><p>几个月后，Lightning Labs 的 CTO <a href="https://twitter.com/roasbeef">Olaoluwa Osuntokun‏</a> 提出了他称为 “闪电网络服务身份认证 Token” 的提议。虽然 Boltwall 是独立开发的，<a href="https://docs.google.com/presentation/d/1QSm8tQs35-ZGf7a7a2pvFlSduH3mzvMgQaf-06Jjaow/edit#slide=id.p">LSAT 演讲</a>中描述的动机非常契合我们的目标：将闪电支付用于身份验证，使身份验证不依赖于个人和隐私信息。</p><p>我们意识到，有必要形成单一一个标准。在 Lightning Labs 发布他们自己的实现之后，我们决定朝着同一个目标齐头并进。我们跟 Lightning Labs 的工程师们一起优化 LAST 标准、将 Boltwall 迁移到兼容 LSAT，并开发了一个工具箱，让开发者们可以在自己的应用的使用 LSAT。</p><h2 id="什么是-LSAT？"><a href="#什么是-LSAT？" class="headerlink" title="什么是 LSAT？"></a>什么是 LSAT？</h2><p>一个 LSAT 就是一个 HTTP 头，编码了一个 macaroom 和相应的闪电发票。该闪电发票的支付证据，是产生一个有效的 LAST 的基本要求。</p><h3 id="LSAT-token"><a href="#LSAT-token" class="headerlink" title="LSAT token"></a>LSAT token</h3><p>一个 LSAT token 由两部分组成：一个 macaroom 和一个支付证据。闪电网络支付提供了一种密码学安全的方式来证明支付。每个发票都会生成一个相应的 32 字节的支付哈希值。这个哈希值是由一个随机的 32 字节的字符串（称为 “原像”）使用 SHA-256 算法生成的。而这个原像，只有在这个闪电发票成功支付后才会揭晓。因为找出原像不可能靠猜，证明只有这个原像才能用来生成这个发票的支付哈希值也很简单。当你成功支付这个发票之后，你拿到了原像，就能生成一个有效的 LAST token 了。</p><h3 id="身份验证流程"><a href="#身份验证流程" class="headerlink" title="身份验证流程"></a>身份验证流程</h3><p>LSAT 的身份验证流程跟 HTTP 类似。我们用最简单的 LSAT 身份验证流程，来演示一下它是怎么工作的。</p><ol><li>客户端向一个服务端上的受保护路由发起一个请求，无需任何身份验证。</li><li>服务端返回一个带有  <code>402: Payment Required</code> 的响应（详见： <a href="https://tools.ietf.org/html/rfc7231#section-6.5.2">IETF RFC 7231</a>）。</li><li>响应也包含一个 WWW-Autheneicate 头（<a href="https://www.ietf.org/rfc/rfc2617.txt">RFC 2617</a>）。它其实是对客户端的一个 “挑战”，指明类型（LSAT）以及必须满足的编码条件：一个 macaroon 和一个发票。</li><li>客户端支付发票，获得 32 字节的原像。</li><li>然后，原像和来自原本的 WWW-Authenticate 头的 macaroon 编码成一个 token。客户端在带有类型前缀 “LAST” 的 Authorization 头中发送这个 token。</li></ol><p>任何读到这个请求的人，都可以通过验证原像与 LSAT 中编码的哈希值的关系，来校验支付。Macaroon 文件中也可以编码其它的 <em>caveat（说明）</em>。说明指示了 token 使用的进一步限制，例如超时时间、请求来源、服务层级，等等。Macaroon 也支持 “<a href="https://github.com/lightningnetwork/lnd/blob/master/docs/macaroons.md#macaroon-delegation">委托</a>”。所以客户端可以在他们的 LSAT 中加入说明（附带更严格的条件），例如更低的服务层级，或者更快的超时时间。然后，修改过的 LSAT 就可以借给另一个人，让 TA 使用相同的服务。</p><h2 id="Chainpoint-的机器间支付"><a href="#Chainpoint-的机器间支付" class="headerlink" title="Chainpoint 的机器间支付"></a>Chainpoint 的机器间支付</h2><p>Tierion 从 2019 年中开始开发基于闪电网络的身份验证技术，同时设计了完全比特币原生的一种新版 <a href="http://chainpoint.org/">Chainpoint Network</a>。</p><p>Chainpoint 让开发者可以铆定数据到区块链上，创建一个时间戳证明。一个由节点组成的网络会收集和汇总哈希值，然后发送锚定交易到区块链上。Chainpoint 的运营者需要运行这项基础设施的激励和支付机制。链上的比特币支付行不通，因为比特币交易的手续费较高，而且吞吐量有限。</p><p>闪电网络让每一个 <a href="https://github.com/chainpoint/chainpoint-core">Chainpoint Core</a> 节点都可以为提交一次哈希值收取一次微支付。有了 Boltwall 赋能的 LAST，Core 节点可以为任何想要提交哈希值的客户端发送一个 LAST 挑战。在支付之后，客户端在带有 LSAT 的许可请求中提交一个哈希值。这让每一个 Core 节点都能为自己的服务验证支付。客户端的开销，相比于他们自己用比特币交易在链上锚定数据，是微不足道的。</p><p>再加上 <a href="https://blog.lightning.engineering/technical/posts/2019/04/15/loop-out-in-depth.html">Loop Out</a> 这样的服务，每一个 Core 节点都可以将从闪电支付中赚取的比特币转移到自己的链上钱包、为锚定交易支付手续费，从而创建一个 <em>完全闭环的、比特币原生的生态系统</em>。</p><h3 id="带有-HODL-发票的一次性-token"><a href="#带有-HODL-发票的一次性-token" class="headerlink" title="带有 HODL 发票的一次性 token"></a>带有 HODL 发票的一次性 token</h3><p>敏锐的读者可能已经注意到了，仅仅使用一个支付过的发票来授权哈希提交会出现一个大问题：用户只要支付一次，就能无限次提交哈希值。在一个分布式网络中跟踪发票和哈希值提交请求的关系是不现实的。相反，我们使用另一个闪电网络原生的协议来跟踪状态：<a href="https://wiki.ion.radar.tech/tech/research/hodl-invoice">HODL 发票</a>。对 HODL 发票的原生支持已经直接做进了 Boltwall 的 LAST 实现中，所以别的项目也可以直接使用。</p><p>HODL 发票工作的原理是，它们不是自动完成的（跟常规的发票不同）。在 <em>支付者</em> 支付之后，<em>接收者</em> 可以验证支付，但资金还不可用。当一个预定的原像向 <em>接收者</em> 揭晓时，结算才发生。要是没有揭晓，资金会退还给 <em>支付者</em>。HODL 发票有许多用途（<a href="https://github.com/lightningnetwork/lnd/pull/2022">LND 代码库的 PR</a> 提供了解释和案例），但是在 Chainpoint 中，我们仅仅用来跟踪状态。</p><p><a href="https://github.com/Tierion/boltwall#hodl-invoices">在 Boltwall 中</a>，只有携带一个 HODL 发票的 LAST 才会被认为是有效的。未支付的、已经结清的发票，都是无效的。当一个客户端在提交哈希值之前给发票支付了，这个发票和对应的 LSAT 就处于 “held” 状态。如果还没提交哈希值，一段时间后支付会返回。而提交了哈希值之后，发票就会由 Chainpioint 结算、支付原像就会附加到 LSAT 上。因为结算完成的 HODL 发票就会被认为过期了，所以使用这个 LSAT 发起的任何请求都会返回  <code>401: Unauthorized response</code> （未获许可的响应）。</p><h2 id="LSAT-工具箱"><a href="#LSAT-工具箱" class="headerlink" title="LSAT 工具箱"></a>LSAT 工具箱</h2><p>我们优化 LSAT 的动机不仅仅是为了在 Chainpoint 中使用闪电支付和身份验证。越多应用使用 LSAT，它对每个人都会变得越有用。因此，我们决定开源我们已经开发出的工具箱，让其他人也为自己的应用嵌入 LSAT。以下就是我们已经发布的代码库：</p><p><strong>BOLTWALL</strong></p><p>Blotwall 支持比特币闪电网络付费和使用 LSAT 的身份验证。用户无需注册账户、API 密钥、信用卡，你就可以直接收费；而且你也不需要存储任何用户数据。你需要的只是在你的 Expressjs 服务端（或类似的 Nodejs 框架例如 Restify）、你想用付费来保护的路由前面加一行代码。任何尝试访问这个路由的客户端都会收到 LSAT。要了解配置、用户、安装和代码文档，请看这个 <a href="https://github.com/Tierion/boltwall">Boltwall 代码库</a>。</p><p><strong>NOW-BOLTWALL</strong></p><p><a href="https://github.com/tierion/now-boltwall">now-boltwall</a> 是一种命令行工具，帮助你简单地部署一个在线的、启用 Boltwall 的服务端，连接到一个运行中的 lnd 实例。它提供了工具来帮助你检索和设置你的 lnd 连接证书、设置你的 Boltwall、甚至可以快速连接到一个 <a href="https://btcpayserver.org/">BTCPay 服务端</a>。服务端使用 <a href="https://zeit.co/home">Zeit’s Now</a> 部署，这是一种免服务端的部署框架，有大量的免费套餐。完整的文件见<a href="https://github.com/tierion/now-boltwall">此处</a>。</p><p><strong>LSAT-JS</strong></p><p><a href="https://github.com/Tierion/lsat-js">lsat-js</a> 是一种使用 TypeScript 编写的功能库，兼容大部分现在的浏览器。它提供了工具来开发、解析和验证 LSAT，不论是客户端还是服务端。代码和文档见<a href="https://github.com/Tierion/lsat-js">此处</a>。</p><p><strong>LSAT PLAYGROUND</strong></p><p>我们甚至开发了一种客户端网页应用，演示了 lsat-js 中所有可用的工具。LAST Playground 包括了代码片段，并且给了你无需撰写代码就能跟 LSAT 交互的渠道。它也提供了一个在线的 demo，你可以使用一个测试网节点来支付、获得使用 Boltwall 保护的一个 API 的限时访问。试用  <a href="https://lsat-playground.bucko.now.sh/">LSAT Playground</a>，立马上手 LSAT。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>比特币引入了原生于互联网的支付系统的概念。闪电网络的创新则展示了这项技术的价值不仅仅是金融交易。LSAT 向着一个我们不需要信任第三方来保管我们的私人信息、用户拥有更安全和隐私的身份验证手段的世界迈出了一步。我们希望 Boltwall 和 lsat-js 能让开发者们更容易基于更好的身份验证基础设施创建自己的应用。</p><p>请看看我们在 Github 上的代码库，并给我们反馈！<a href="https://github.com/Tierion/boltwall">Boltwall </a> 和相关 LSAT 工具的开发是由 Buck Perley 领导的。如果你有问题，请在<a href="https://twitter.com/BuckPerley">推特上联系他</a>。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">更安全和隐私的身份验证手段</summary>
    
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    <category term="LSAT" scheme="https://www.btcstudy.org/tags/LSAT/"/>
    
  </entry>
  
  <entry>
    <title>基于 LNURL 的闪电网络地址</title>
    <link href="https://www.btcstudy.org/2022/12/22/how-lightning-address-works/"/>
    <id>https://www.btcstudy.org/2022/12/22/how-lightning-address-works/</id>
    <published>2022-12-22T04:18:15.000Z</published>
    <updated>2023-01-12T06:01:27.469Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：heisenberg</em></p><p><em>来源：<a href="https://stacker.news/items/65872">https://stacker.news/items/65872</a></em></p></blockquote><p>富有经验的用户知道，现在你可以给  <code>名字@域名</code> 这种格式的闪电网络地址直接支付了。但是，它到底是怎么一回事呢？</p><p>在这篇短文中 ，我会向还不了解这个功能的朋友解释它的原理。同时，我会介绍闪电网络发票（invoices）和 LNURL-pay 协议的基础知识。</p><h2 id="闪电网络发票基础知识"><a href="#闪电网络发票基础知识" class="headerlink" title="闪电网络发票基础知识"></a>闪电网络发票基础知识</h2><p>闪电网络发票是当前在闪电网络上发送和接收资金的标准。如果你想接受一些比特币，你必须在你的 节点/钱包 处生成一个发票。发票只是一串文字（以 “lnbt” 开头），包含了接收者的 ID 和资金的数额（以及其它东西）。实际上还有更多信息，但我们这边就不深究了。发票最常见的分享形式是 QR 二维码，其实就是上述字符串的图像表示。</p><p>例子：</p><p><img src="/../images/how-lightning-address-works/invoice.png" alt="LN Invoice"></p><p>然后，支付者的闪电钱包会在网络中寻找触达接收者的路径、按照优势对这些路径排序并逐一尝试，直到支付成功（有时候可能也会失败）。</p><p>但是，闪电网络发票有很大的局限性。设想你是一个 Youtube 视频作者，你想在自己的视频中生成一个静态的二维码，这样你的粉丝就可以给你捐赠了。但是每个发票都由超时限制（通常是 1 小时），而且无法多次支付。这是因为，在路由支付的过程中，中间节点会知道叫做 “支付原像” 的随机数，所以使用同一个发票多次支付是不安全的（每个发票只包含了一个支付原像，知道了支付原像就可以获得支付者支付的资金）。那该怎么办呢？这就轮到 LNURL-pay 了。</p><h2 id="LNRUL-pay-基础知识"><a href="#LNRUL-pay-基础知识" class="headerlink" title="LNRUL-pay 基础知识"></a>LNRUL-pay 基础知识</h2><p>LNRUL-pay 是一种标准，允许用户创建一个静态的 QR 码，这个码可以接收多次支付。这是怎么做到的呢？</p><p>LNURL-pay 核心就是一条 URL，连接到一个使用 HTTPS 网络协议（或者 Tor 协议）的服务端，这个 URL 是用 bech32 编码格式编码过的。从用户体验上看，它有很大的优势，因为从人的角度看，不同的 QR 码没有什么分别，因此普通的用户不需要知道他们是在支付一个发票，还是在使用 LNURL-pay。</p><p>例子：</p><p><img src="/../images/how-lightning-address-works/lnurl.png" alt="LN Invoice"></p><p>支付流程：</p><ol><li><strong>用户</strong>使用闪电网络<strong>钱包</strong>扫描 QR 码（LNURL-pay）。</li><li><strong>钱包</strong>解码 QR 码，然后解码这个 bech32 字符串，获得 URL 并使用 HTPPS 协议访问它。</li><li><strong>服务端</strong>响应钱包以一条消息，询问支付数额（也可以是固定数额）。</li><li>用户填入数额，并将信息发回给<strong>服务端</strong>。</li><li><strong>服务端</strong>返回<strong>用户</strong>选定数额的传统闪电网络发票。</li><li><strong>钱包支付发票</strong>。</li></ol><p>就是这样！所以，LNURL-pay 知识一种协议，用来（通过互联网服务端）协商要生成多大价值的发票。</p><h2 id="最后，闪电网络地址"><a href="#最后，闪电网络地址" class="headerlink" title="最后，闪电网络地址"></a>最后，闪电网络地址</h2><p>现在，我们已经知道发票和 LNRUL-pay 的原理了，那么理解闪电网络地址就变得轻而易举。回想一下，为什么我们需要通过 LNURL-pay 扫描 QR 码来获得原始的 HTTPS 链接？</p><p>有了闪电网络地址，你就不需要扫描 QR 码了。举个例子，如果你的地址是 <a href="mailto:heisenberg@stacker.news">heisenberg@stacker.news</a>，那么你的钱包会将它翻译成 <a href="https://stacker.news/.well-known/lnurlp/heisenberg%E3%80%82%E6%8D%A2%E5%8F%A5%E8%AF%9D%E6%9D%A5%E8%AF%B4%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%93%BE%E6%8E%A5%E4%B8%8D%E6%98%AF%E4%BB%8E">https://stacker.news/.well-known/lnurlp/heisenberg。换句话来说，这个链接不是从</a> QR 码中获得的，而是从闪电网络地址中 “编译” 出来的。你的钱包会访问这个 URL，然后得到的响应就是 LNULR-pay 请求，你要支付多少钱（见上述支付流程第三步）。后面的程序就是一样的了。就是这样！</p><h2 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h2><p>许多托管式 钱包/解决方案 现在会自动为你生成一个闪电网络地址，举例来说，每个用户都有一个形如 “<a href="mailto:username@stacker.news">username@stacker.news</a>” 这样的地址。如果你想给这个地址支付一些钱，你只需要在闪电网络钱包的 “发票字段” 填入这个地址。现在大部分钱包都支持这样做了。另一个解决方案是使用你自己的闪电节点运行的工具（比如 LNBits、LnMe 和其它），这样就可以无需托管地通过 LNURL 收账。</p><p><strong>希望你有所收获，并且能告诉我你对类似的文章有没有兴趣</strong>。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">从闪电网络发票出发</summary>
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/categories/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    <category term="LNURL" scheme="https://www.btcstudy.org/tags/LNURL/"/>
    
  </entry>
  
  <entry>
    <title>什么是比特币硬件钱包？</title>
    <link href="https://www.btcstudy.org/2022/12/19/what-is-bitcoin-hardware-wallet-by-unchained-capital/"/>
    <id>https://www.btcstudy.org/2022/12/19/what-is-bitcoin-hardware-wallet-by-unchained-capital/</id>
    <published>2022-12-19T07:21:59.000Z</published>
    <updated>2023-01-12T06:01:27.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Ted Stevenot</em></p><p><em>来源：<a href="https://unchained.com/blog/what-is-bitcoin-hardware-wallet/">https://unchained.com/blog/what-is-bitcoin-hardware-wallet/</a></em></p></blockquote><p>比特币硬件钱包是一种小型专用设备，会在断绝互联网的状态下为你生成可以保管比特币的公私钥并安全地存储。</p><p>比特币钱包软件使用你的密钥对为你生成地址、授权你的花费操作并确保你能安全访问链上资产。将比特币密钥离线（禁绝互联网连接）存储对保证比特币的安全性来说至关重要，可以最大程度上防范他人通过远程攻击和恶意软件窃取你的资金。硬件钱包通常会提供多样化保护机制，以防止任何能直接接触到你的硬件钱包的人获取保存在钱包内的密钥。</p><p>比特币硬件钱包（指设备本身）同样区别于 “比特币钱包”。比特币钱包是由单个主私钥生成的公私钥对集合。因此，一个比特币硬件钱包可以承载多个比特币钱包。</p><p>在本文中，我们将探讨以下几个问题：比特币硬件钱包是什么？有什么是它能做的？有什么是它做不了的？硬件钱包是如何签署交易的？硬件钱包具备哪些优势和劣势？</p><h2 id="哪些是硬件钱包做不了的？"><a href="#哪些是硬件钱包做不了的？" class="headerlink" title="哪些是硬件钱包做不了的？"></a>哪些是硬件钱包做不了的？</h2><p>一个常见的误区是，硬件钱包将比特币存储在硬件设备中。事实上，没有哪个比特币钱包 —— 无论软件还是硬件 —— 将比特币存储在内部。相反，所有比特币都存储在链上（译者注：所有比特币的归属都由比特币区块链上记载的交易决定，说穿了所有的比特币都是电子记录）。硬件钱包存储的仅仅是用来控制比特币的 <em>密钥</em>。</p><p>有太多人误信比特币就存储在硬件钱包内，比特币业内人士建议不再继续使用“硬件钱包”这样带有误导性的叫法。但是，其它更准确的叫法，如“签名设备”或“签名器”，一直没有流行起来。</p><p>另外，硬件钱包无法查看链上比特币余额，也不能广播和验证比特币交易。执行这些功能需要另外的比特币钱包软件。（所有比特币钱包都需要连接到<a href="https://unchained.com/blog/what-is-a-bitcoin-node/">比特币节点</a>，才能接收、传输和验证新的交易。）（译者注：硬件钱包是无法访问互联网的，所以读取不到交易的记录，也无法广播新的交易。）</p><h2 id="哪些是硬件钱包能做的？"><a href="#哪些是硬件钱包能做的？" class="headerlink" title="哪些是硬件钱包能做的？"></a>哪些是硬件钱包能做的？</h2><p>硬件钱包实现了接收、保护和花费比特币所需的多种功能。首次初始化时，（使用 <a href="https://en.bitcoin.it/wiki/BIP_0039">BIP 39 标准</a>的）硬件钱包会生成一个种子作为构建比特币钱包的基础。地址是基于种子生成的，用来在链上接收比特币。一旦收到比特币，你就可以使用硬件钱包签署（授权）比特币交易。硬件钱包还可以通过备份助记词找回之前创建的比特币钱包。</p><p>我们来逐一分析各个功能。</p><h3 id="生成种子"><a href="#生成种子" class="headerlink" title="生成种子"></a>生成种子</h3><p>在设置阶段，大多数硬件钱包会为你生成种子。这个种子是一个随机生成的巨大二进制数字字符串，可以使用人类可读的形式（<a href="https://unchained.com/blog/what-is-a-bitcoin-seed-phrase/">助记词</a>）来表示。在钱包设置阶段，你会看见一组由 12 或 24 个单词组成的助记词。请你务必将这些单词按正确顺序抄写下来，<a href="https://unchained.com/blog/how-to-store-bitcoin-seed-phrase-backups/">并离线存放在一个安全的地方</a>。</p><p><img src="/../images/what-is-bitcoin-hardware-wallet-by-unchained-capital/0x670px.png" alt="A bitcoin seed phrase"></p><p style="text-align:center">- 比特币助记词备份 -</p><p><a href="https://unchained.com/blog/what-is-a-bitcoin-seed-phrase/">助记词</a>不同于生成比特币地址的私钥。助记词生成“主私钥”，主私钥生成钱包的所有地址以及与它们相关的公私钥对。现如今，<a href="https://en.bitcoin.it/wiki/Deterministic_wallet">确定性钱包</a>可以生成几乎无限多的比特币地址（并为每个地址生成了公私钥对），这些地址都源自同一个助记词。（译者注：从逻辑上来说，主私钥是先生成公私钥对，再生成对应的地址的；当然，最终的结果是，主私钥可以生成无数个地址。这也是软件钱包生成地址的原理。）</p><p><strong>硬件钱包如何生成助记词？</strong></p><p>硬件钱包首先生成一个种子，然后将其映射到<a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">一个包含 2048 个单词的单词表</a>上得到助记词。硬件钱包利用<a href="https://bitcointalk.org/index.php?topic=5317199.0">多种方法</a>来实现随机性，例如，随机数生成器（RNG）。很多硬件钱包都内置了一个独立的微处理器（叫作<a href="https://unchained.com/blog/bitcoin-what-is-a-secure-element/">安全元件</a>），RNG 固件就在安全元件上运行。有些钱包则将内外部资源结合起来生成熵，最常见的一个例子就是<a href="https://coldcard.com/docs/verifying-dice-roll-math">掷骰子</a>。</p><h3 id="存储种子、助记词和私钥"><a href="#存储种子、助记词和私钥" class="headerlink" title="存储种子、助记词和私钥"></a>存储种子、助记词和私钥</h3><p>完成初始化之后，你的比特币钱包种子（以及对应的助记词）就存储在硬件钱包内。如果你的硬件钱包使用了安全元件，种子通常就存储于设备内部，无法以明文形式从设备中导出。</p><p>对导出种子的限制正是硬件钱包安全性的来源之一。硬件钱包是一种“冷存储”形式，因为它们将种子存储在与互联网隔绝的环境中。由于攻击面较少，硬件钱包从理论上来说可以连接到一个感染了病毒的计算机（不建议这么做！）。即使在这种情况下，硬件钱包仍旧能保护好你的种子。</p><h3 id="签署交易"><a href="#签署交易" class="headerlink" title="签署交易"></a>签署交易</h3><p>硬件钱包的主要用例是安全签署交易，即，授权花费你的比特币钱包里的比特币。如果你使用的是单签钱包，只需一个硬件钱包的一个签名就足以转移你的比特币。如果你使用的是<a href="https://unchained.com/blog/why-multisig/">多签</a>钱包，通常需要来自两个或以上不同硬件钱包的签名来转移你的比特币。</p><p><img src="/../images/what-is-bitcoin-hardware-wallet-by-unchained-capital/d-prev4.png" alt="2 of 3 multisig with coldcard hardware wallets"></p><p style="text-align:center">- 包含 2 个 Coldcard 和一个协同托管方的 2/3 多签机制 -</p><p>为了签署交易，硬件钱包必须与桌面或智能手机上的钱包软件通信。不同类型的硬件钱包可能会通过不同方式与你的设备连接，例如，USB、蓝牙或 <a href="https://en.wikipedia.org/wiki/Near-field_communication">NFC</a>。完全无接触的（即，不直接连接到互联网）解决方案同样可用，包括使用相机、二维码或 SD 卡在硬件钱包和设备之间传输数据。</p><p>就离线“冷存储”解决方案而言，将你的硬件钱包连接到联网设备似乎是违反常理的。但是，正如上文所言，即使是在联网的情况下，你的钱包种子连同对应的公私钥对也是与网络隔离的，可以确保安全性。</p><p><strong>硬件钱包是如何签署交易的</strong></p><p>使用硬件钱包签署交易需要完成一系列步骤。在整个过程中，私钥不会离开硬件钱包或接触联网设备。只有（已签署和未签署的）交易数据在硬件钱包和软件钱包之间转移。</p><p>典型的交易签署步骤：</p><ol><li>在钱包软件中创建一个未签署交易：指定金额、交易费和收款地址。此时，由于该交易尚未签署，我们无法将其发送至比特币网络。</li><li>钱包软件通过你正在使用的连接方式（有线连接、非联网方式、二维码等）将未签署交易发送给硬件钱包。</li><li>硬件钱包会向你展示交易细节以便你再次检查软件是否篡改了任何交易细节，比如更换了地址。你能借此机会发现问题。</li><li>点击硬件钱包上的按钮确认交易。</li><li>硬件钱包使用相应私钥签署交易。</li><li>硬件钱包将已签署交易传回钱包软件。软件可以看到交易已签署，但是无法通过签名提取私钥。</li><li>一旦必要签名全部集齐，交易变得有效。钱包软件会将该交易广播至比特币网络。</li></ol><h3 id="复原钱包"><a href="#复原钱包" class="headerlink" title="复原钱包"></a>复原钱包</h3><p>硬件钱包也可以用来复原钱包。假设你设置了一个比特币硬件钱包，记下了助记词。然后，你的硬件钱包遭遇了意外，如，火灾、盗窃、水灾、故障、丢失等等。找回比特币的一种方式是，使用你的助记词通过新的硬件钱包复原你的钱包。在设置新的硬件钱包时，你可以选择是创建一个新的钱包还是找回已有钱包。如果你选择找回已有钱包，可以输入该钱包的助记词，找回你的比特币。</p><h3 id="验证地址"><a href="#验证地址" class="headerlink" title="验证地址"></a>验证地址</h3><p>比特币交易是无法改变的。也就是说，如果你将比特币发送到了错误的地址上，就会永远失去这些比特币。幸好硬件钱包可以让你在发送比特币之前检查你的比特币地址。在你的硬件钱包上检查你的地址：</p><ol><li>你可以确认地址是否正确。如果你使用的是多签模式，设备将告诉你是 2/3、3/5 还是其它阈值（不能是 2/5，否则只要其中有两个私钥是攻击者的，攻击者就能控制你的比特币）。</li><li>你可以确认你所使用的计算机没有遭到攻击者的恶意软件入侵。恶意软件会向你展示错误地址。</li><li>你可以极度确信自己持有设备所显示的地址的密钥。这个地址就在你的控制下（因为这个地址就由你的设备控制）。</li></ol><p>在向某个地址发送一定数量的比特币之前，请你务必检查硬件钱包上的收款和找零地址。</p><h2 id="硬件钱包软件"><a href="#硬件钱包软件" class="headerlink" title="硬件钱包软件"></a>硬件钱包软件</h2><p>大多数硬件钱包需要制造商的钱包软件来初始化设备。很多人也会为了钱包功能而选择使用原始设备制造商的软件。不过，只要你愿意，一旦初始化完成，你就可以使用第三方比特币钱包软件与你的硬件钱包一起管理你的比特币。常见的选择有 Sparrow、BlueWallet 和<a href="http://unchained.com/vaults?_gl=1*1ih67pr*_up*MQ..*_ga*NzM3MDU3NDc1LjE2NzA5MDExMjg.*_ga_N2E2DZCQWE*MTY3MDkwMTEyNy4xLjAuMTY3MDkwMTEyNy4wLjAuMA..">我们自己的多签钱包解决方案</a>。</p><p><img src="/../images/what-is-bitcoin-hardware-wallet-by-unchained-capital/ed-demo.png" alt="unchained wallet"></p><p style="text-align:center">- Unchained Capital 钱包用户界面 -</p><p>当你将硬件钱包连接到钱包软件时，你主要是会跟安装该软件的设备（惦念或智能手机）交互。但是，如上文所述，硬件钱包绝对不会将你的私钥与该设备共享。所有交易签署都发生在硬件钱包上，然后再（把签好的交易）传给钱包软件。</p><h2 id="硬件钱包的取舍"><a href="#硬件钱包的取舍" class="headerlink" title="硬件钱包的取舍"></a>硬件钱包的取舍</h2><p>就安全存储你的比特币公私钥对而言，硬件钱包的优势远远大于其劣势。相比在线存储公私钥对的<a href="https://www.investopedia.com/terms/h/hot-wallet.asp#">热钱包</a>等替代方案，硬件钱包具有的优势更大。</p><p>我们还需要注意以下几点：</p><ul><li><p>硬件钱包虽然适用于冷存储，却未必是大量交易（例如，高频交易或购买咖啡）的最佳选择。</p></li><li><p>硬件钱包可以抵御多种形式的恶意软件，但是有一些恶意软件专门针对硬件钱包（即，<a href="https://unchained.com/blog/21-ways-lose-bitcoin/#:~:text=and%20bitcoin%20wallets-,Clipper,-which%20changes%20a">clipper</a> 恶意软件）。</p></li><li><p>硬件钱包有购买成本，通常是 75 至 150 美元。相比之下，很多软件钱包不会产生任何成本。</p></li></ul><h2 id="开启你的比特币自托管之旅"><a href="#开启你的比特币自托管之旅" class="headerlink" title="开启你的比特币自托管之旅"></a>开启你的比特币自托管之旅</h2><p>硬件钱包在保护你的比特币的安全性方面起到了关键作用，但是新手用户难免望而生畏。好消息是，即使你是新手，也不需要摸石头过河了。Unchained Capital 提供个性化服务 Concierge Onboarding，可以通过视频通话指导你使用硬件钱包创建多签保险柜。 </p><p>（完）</p>]]></content>
    
    
    <summary type="html">比特币硬件钱包是什么？硬件钱包具备哪些优势和劣势？</summary>
    
    
    
    <category term="比特币主网" scheme="https://www.btcstudy.org/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BB%E7%BD%91/"/>
    
    
    <category term="入门系列" scheme="https://www.btcstudy.org/tags/%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    <category term="钱包" scheme="https://www.btcstudy.org/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>评估 CoinJoin 实现的框架</title>
    <link href="https://www.btcstudy.org/2022/12/18/navigating-bitcoin-coinjoin/"/>
    <id>https://www.btcstudy.org/2022/12/18/navigating-bitcoin-coinjoin/</id>
    <published>2022-12-18T07:41:31.000Z</published>
    <updated>2023-01-12T06:04:58.582Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Thibaud Maréchal</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/navigating-bitcoin-coinjoin">https://bitcoinmagazine.com/technical/navigating-bitcoin-coinjoin</a></em></p></blockquote><p>“离间计” 是一种久经考验的军事策略，意思是通过让人们产生分歧、自相残杀而不是一致对外，从而分裂一群人。Wasabi 和 Samourai 这两种流行的比特币钱包，各有各的 Coinjoin 实现，一直在彼此拆台。JoinMarket 是另一种 Coinjoin 实现，也跟其它的隐私特性开发者有过激烈的辩论。</p><p>随着不断开展的戏剧事件，了解比特币的隐私和 coinjoin 技术变得非常困难。应该信任谁？如何验证他们说的话？都是不清不楚的。这些戏剧到底为比特币的观望者、普通的比特币用户和虔诚信仰者带来了什么呢？无尽的困惑、恐惧、不确定和怀疑（FUD）。比特币本身令人尴尬的隐私状况，和一直在发生的闹剧，赶走了新的用户。开发者、布道者和普通 用户在上面浪费了宝贵的时间，随便干点什么，都比追踪他们的闹剧要强。</p><p>显然，关于 “如何正确实现 coinjoin” 本身，人们还没有达成共识；那么，应该如何实现 coinjoin 以尽可能优化用户的隐私性和比特币的区块空间效率呢？不同的实现之间有何取舍？哪一些实现有明显的缺陷吗？未来几年，数十亿的用户将转向 使用比特币，coinjoin 又如何跨越从寥寥数人问津到主流用户采用的鸿沟呢？</p><p>我们要通过追问根本的问题和提出一些假设来了解 coinjoin 技术并建立一些心智模型，这些模型将在后续的文章中评估不同的 Coinjoin 实现时派上用场。</p><h2 id="并非所有的-Coinjoin-实现都一个样"><a href="#并非所有的-Coinjoin-实现都一个样" class="headerlink" title="并非所有的 Coinjoin 实现都一个样"></a>并非所有的 Coinjoin 实现都一个样</h2><p>区块空间效率是一个重点，因为要确保 coinjoin 交易能够随比特币一起扩展，被全世界越来越多人所用。但它很少被当作第一优先级来讨论。任何忽略区块空间稀缺性的 Coinjoin 设计都是在没有必要地轰炸区块链，同时积累技术债 —— 随着更多用户到来，这种债务会变得越来越难以偿还。在区块链上留下尽可能少的足迹似乎是一个很合理的目标：少量的交易即可达到可接受的匿名程度，听起来很不错。</p><ul><li>那么，什么样才是可以接受的匿名程度？</li><li>匿名性在比特币隐私的语境下是什么意思？</li><li>特定的 Coinjoin 设计是如何处理区块空间稀缺性的？</li></ul><h2 id="收回你的隐私"><a href="#收回你的隐私" class="headerlink" title="收回你的隐私"></a>收回你的隐私</h2><p>在比特币中，匿名性意味着没有突出的、异常的特征，让给定的一笔交易跟账本上的其它交易有区别。当然，比特币网络在设计上不能保证这一点，它只是一个准匿名系统，其资金的形式（UTXO，未花费的交易输出）因为有独一无二的历史，一般来说不是同质化的。</p><p>Coinjoin 技术给比特币网络增加了一点匿名性，因为它打破了交易的输入与输入的关联、让输出看起来都没有分别。区块链分析公司还使用其它的线索来观察比特币网络，比如交易输入所有权同一性假设、左手倒右手假设、整数假设、时区分析，等等，这些线索不一定能被 coinjoin 掩盖。</p><p>Coinjoin 帮助比特币用户收回了一些隐私性，但不是一切隐私问题的灵丹妙药。如果隐私被理解为分享信息的自主选择权，更好的隐私性可以通过 coinjoin 技术来实现，但选择正确的 Coinjoin 实现至关重要。</p><ul><li>使用 coinjoin 的时候，我的隐私性目标是什么样的？</li><li>Coinjoin 实现可以帮我抵御什么样的线索分析？</li><li>我想要避免哪些风险？</li></ul><h2 id="参与者的数量"><a href="#参与者的数量" class="headerlink" title="参与者的数量"></a>参与者的数量</h2><p>现有的 Coinjoin 实现使用了不同的办法来提高隐私性。但不管这些实现在设计上如何考量，“匿名集”（匿名程度的一种度量）似乎是最传统的评估 Coinjoin 收获的办法。其它文章可能会使用别的办法。这里的假设是，要么你可以通过参加一笔较大的 Coinjoin 交易来实现更高的匿名性，要么你可以通过参加多次较小的 Coinjoin 交易来实现。这两个参数（参与者数量、参与次数）都有意义，但是否某一个会比另一个更重要？</p><p>从区块空间效率的角度来说，这里的假设应该是单笔较大的（参与者较多）交易比多次较小（参与者较少）的交易要好。</p><ul><li>单笔较大的 coinjoin 交易和多笔较小的 coinjoin 交易，哪个隐私性更好？</li><li>如何进行真实、严格的验证？多小的 coinjoin 交易就算 “太小了”？</li><li>有无估算你从一笔 coinjoin 交易中得到的隐私性好处的真实指标？</li><li>关于 coinjoin 交易的体积和次数，偏重何者的区块空间效率更高？</li><li>预期币会随着越来越多人开始使用 coinjoin 而参与多次 coinjoin，是现实的吗？参加多少次算是足够？会不会过犹不及？</li></ul><p>简而言之，coinjoin 通过给予用户合理推诿的能力，让他们可以收回一些隐私性。推诿的可信度是对概率的度量 —— 你的比特币到底是被花掉了，还是放到了你依然控制的另一个地址？可能性有多大？某一个输入跟某一个输出有关系的概率有多大？</p><p>显然，作为一个囤币者，多个选项的概率越平均，你的合理推诿能力就越强。这种能力是很难保持的，因为需要处处提防。找零输出对在乎隐私的比特币用户来说常常是个问题，也是持续不断的讨论和批评的中心。为什么找零输出在 coinjoin 技术的语境下争议如此之大？</p><h2 id="找零输出"><a href="#找零输出" class="headerlink" title="找零输出"></a>找零输出</h2><p>这都是因为确定性的关联。如果为比特币交易的隐私性设计一条光谱，那么最左边是绝对的合理推诿能力，意思是完全没有办法知道输入和输出之间的关联。Coinjoin 的语境中也有所谓的 “随机性” 或者 “熵”。这里的假设是，越是随机，或者说熵越高，就越好。而光谱的另一端则是一笔交易有 100% 的确定性关联 —— 每一个输入中的价值去到了哪个输出都一清二楚。</p><p>反直觉的是，高熵并不必然意味着交易提供了良好的隐私性。如果一笔交易有三个输入和三个输出，每个输出的价值都相等，那么从技术上来说它有 100% 的熵，意思是无法辨别这三个输出有什么区别；但是，依然有 33.33% 的概率猜中一个输入关联着哪个输出。高熵并不意味着良好的合理推诿能力。</p><p>找零输出几乎总是跟其前序交易有非常高的确定性关联。换句话来说，几乎没有疑问，找零输出跟产生它的交易是有关的。如果一个找零输出跟其它的经过 coinjoin 的匿名输入一起花费，那可能会变成一个重大的隐私问题（虽然某些情况可能有例外）。这样的联合花费通常被称为 “UTXO 整合”，如果毛毛躁躁就做了，可能会对隐私性造成致命影响。</p><p>如果拿找零输出跟经过 coinjoin、获得了一些合理推诿能力的输出一起花费，找零输出可能会让它们去匿名化。这种失误很常见，有时候当事人还后知后觉。几年的隐私加强活动，就此功亏一篑。那么如何避免这种找零输出问题？</p><p>现有的 Coinjoin 实现有三种处理找零输出的办法：将找零隔离到另一个不参与 coinjoin 的钱包中；将找零输出放在参与 coinjoin 的同一个钱包中；通过不设找零，完全放弃掉找零输出。最后一者从隐私性 和区块空间效率的角度看是最好的选择，但我们还需要进一步的探究才能证实或者证伪这个假设。</p><ul><li>熵的分数足以量化一笔 coinjoin 交易对你的隐私性的影响吗？</li><li>将找零输出隔离对另一个钱包 vs. 完全放弃找零，哪一种做法更好？</li><li>找零输出对你的隐私只有负面影响吗？</li></ul><h2 id="币的面额"><a href="#币的面额" class="headerlink" title="币的面额"></a>币的面额</h2><p>在 coinjoin 交易中去除找零输出，将要求币的面值是可变的。换句话说，参与这样的 coinjoin 交易的输入就不能是（例如）0.1 BTC 这样的固定面额（译者注：原文在这里使用的是 “input（输入）”，但疑应为 “输出”），否则就无法（至少非常难）不设找零而消耗掉输入，因为大部分的 UTXO 都没有整数（例如，在输出等面额的 coinjoin 交易中输入 0.19572394 BTC 将产生 0.1 BTC 的输出和 0.09572394 BTC 的找零）。</p><p>找零输出可能对你的隐私性有害，还记得吗？在 coinjoin 交易中使用多个不等面额的输入和输出，似乎也是个糟糕的想法，因为它会让输入和输出之间的确定性关联更清晰，对不对？其实，既对又不对，这样看情况。如果一笔 coinjoin 只有寥寥几位参与者（输入和输出都很好）那么使用不同的面额就会是一个糟糕的想法。但如果有很多个输入和输出呢，那会怎么样？</p><p>在较大的 coinjoin 交易中，使用多个面额可以为每一个结果输出带来更强的合理推诿能力，无需创建找零输出、也不需要发起额外的交易，因此它对区块空间的利用效率更高。当前似乎已经有不少选择了。</p><ul><li>Coinjoin 交易使用固定的面额还是多种面额更好？</li><li>如果要使用多种面额的币，coinjoin 交易应该有多少参与者呢？</li><li>使用多种面额是去除 coinjoin 交易的找零输出的最好方法吗？</li></ul><p>不必说，不论币的面额是否可变、coinjoin 交易是大是小，多次 Coinjoin 之间产生相互关联都是不可接受的，对吧？这里又有一个需要理解的重要细节。</p><h2 id="Coinjoin-轮次间的相互关联"><a href="#Coinjoin-轮次间的相互关联" class="headerlink" title="Coinjoin 轮次间的相互关联"></a>Coinjoin 轮次间的相互关联</h2><p>据说，让曾经加入过同一笔 Coinjoin 交易的输入再次参加同一笔 Coinjoin 交易，是毫无合理性可言的。已经共享过 Coinjoin 交易的参与者们，似乎无法从共同参与另一次 Coinjoin 中获益。这对隐私似乎有害，也经常受到批评。</p><p>但要是一笔 Coinjoin 交易很大、其一些输入来自其它的 Coinjoin 交易、并且这些 Coinjoin 交易又来自其它 Coinjoin 交易呢？在这种情况下，一起再次混币的参与者依然能提升自己的隐私新，哪怕他们都来自同一笔 Coinjoin 交易。如果每一次 Coinjoin 交易都足够大，那么用户就不需要多次混币，虽然他们可以这样做以进一步提升他们的匿名性。</p><p>如果许多大型的 Coinjoin  交易产生连接，最终的匿名集应该能提供大量的合理推诿能力，即使这些资金以前曾经参与过共同的 Coinjoin。</p><ul><li>Coinjoin 轮次之间的相互关联，也就是使用了过去 Coinjoin 交易的结果，就其本身而言是坏事吗？</li><li>当需要再次混合以往 Coinjoin 的结果时，这笔 Coinjoin 应该要多大，才是安全的？</li></ul><h2 id="个人全节点"><a href="#个人全节点" class="headerlink" title="个人全节点"></a>个人全节点</h2><p>在参与 coinjoin 的时候，你应该运行自己的比特币全节点吗？从表面上看，这是个好主意，而且实际上也往往是。一些 Coinjoin 实现让用户可选，而另一些则要求用户这样做。还有一些甚至不让你使用自己的全节点。要谴责他们吗？你已经读到了这里，那么你应该猜到了，答案是微妙的，而且打开了一个很深的兔子洞。</p><p>运行自己的全节点也意味着可用性上的取舍，而且如果不是所有用户都使用，可能不会增加很多隐私性。甚至，运行全节点会给你一种安全性和隐私性的错觉，如果很少 coinjoin 参与者使用全节点，你这样做是极为有害的。如果你把 Tor 用作 coinjoin 技术的一种匿名方法（我们这里先提一句），那么使用可信的全节点来广播 Coinjoin 交易是好的，就像一般情况一样。这里面有非常多的细节，而且，当然，你不应该相信我说的，你要自己验证。</p><p>为了不要落入自我表扬隐私性好的人的陷阱，我们有一些根本的问题要问他们：</p><ul><li>你的 Coinjoin 是允许使用全节点呢，还是要求使用全节点，还是不允许使用全节点？</li><li>如果个人全节点不是强制性的，你们采取了什么隐私保护措施呢？Tor？区块过滤器？</li><li>如果我运行自己的全节点，但预计绝大部分用户都会使用受信任的第三方节点来参与 Coinjoin，这对我的隐私性有什么样的影响？协调员可以让我去匿名化吗？</li></ul><p>关于隐私性上的忧虑，始终关键的一点是，搞清楚你想保护什么、你想对抗谁。运行全节点并让自己的钱包使用它，是使用比特币的正确方式，因为它让你无需信任任何人，就可以验证你的钱包余额、把你的交易广播到网络中。但如果你要参与 coinjoin，那就总会有一个 “协调员”。协调员是干什么的、怎么选出来的？往下读。</p><h2 id="协调员"><a href="#协调员" class="headerlink" title="协调员"></a>协调员</h2><p>Coinjoin 的协调员负责让每个参与者注册自己的输入和输出、在广播交易之前签名协商好的交易。大部分的 Coinjoin 实现都默认设置了一个中心协调员，它是协议的一个单点故障。迄今为止，社区中的绝大部分人都认为这是一种可以接受的权衡。那么，中心化的协调员会出错吗？当然会啊。有一些实现允许任何人来充当协调员，每一次的 Coinjoin 交易都可以使用不同的协调员，但这也面临其它的一些取舍，我们后面再说。</p><p>Coinjoin 是非托管的，即使协调员出错，资金也不会损失。协调员永远不应当知道比公开在比特币网络中的信息更多的东西。为什么呢？因为如果协调员知道的比公开的多，那么协调员就会变成攻击的目标，因为它有大量敏感的数据，可以挖掘出来针对信任这项服务的比特币用户。</p><p>你永远不应该信任你的 Coinjoin 协调员。如果一个 Coinjoin 协调员无法作恶，那是好事。要是它能作恶，那么它最终会消亡，因为错误、疏忽、被迫或彻底的不诚实等等原因。</p><p>敏感数据的一个例子是 XPUB（比特币钱包的主公钥），会确定无疑地泄露一个钱包的所有信息：这个钱包所控制的地址、过去现在和未来的所有比特币交易。另一个例子是运行自己的全节点的用户跟信任协调员的全节点的用户的比例，因为这可以去匿名化运行自己的节点的用户，因此可以确定地知道这些用户的输入与输入的关联。不过这是另一个微妙的话题，需要进一步的研究和讨论。</p><ul><li>协调员知道比公开在比特币网络上的信息更多的东西吗？</li><li>用户是否向协调员泄露了敏感信息，比如他们的 XPUB，或者他们是否运行了自己的全节点？</li><li>协调员是否声称因为有法律机制所以用户可以信任他们（即：法院警告、监管措施，等等）？</li></ul><h2 id="手续费"><a href="#手续费" class="headerlink" title="手续费"></a>手续费</h2><p>最后，谁来为 Coinjoin 交易支付手续费？这样的比特币交易可能体积很大，因此手续费昂贵，而且有时候手续费的结构对用户来说是不清楚的。很难知道你为了更好的隐私性需要付出多大的代价，甚至你不知道自己到底能不能从中获得更好的隐私性。一些 Coinjoin 实现允许一个输入从其它输入处购买隐私性 —— 这些其它输入只是为了提升自己的匿名集而无偿参与的。可以通过 coinjoin 来获得报酬？你没看错，是可以的。</p><p>某一些模式依赖于共同分担手续费，只有一些 UTXO 会支付手续费，其它的不会。另一些模式依赖于邀请越来越多的新的干净的输入（没有混合过的）来为现有的 Coinjoin 交易注资、混合当前匿名性不够高的输入。从长期来看，一些模式似乎是不可持续的，也有一些是很幼稚的，或者对大部分用户来说太贵了。</p><p>而且，我们讲的手续费到底指什么？一般来说，参与 Coinjoin 交易的输入需要支付协调费（或者叫吃单者费用，是为了获得一定程度的匿名性而支付的服务费）以及比特币网络的手续费。特定的 Coinjoin 模型可以在某些情况下免除这些费用。Coinjoin 的经济模式是很深的话题，也需要进一步的探究，才能获得更深的理解。</p><ul><li>谁，给 Coinjoin 交易里的什么东西付费？总的费用包括什么？</li><li>Coinjoin 协调员的经济激励在哪？</li><li>每一轮 Coinjoin 都要付费吗？还是什么时候可以免费呢？</li></ul><p>你已经读到了这里，那么，我的希望是，不求你在选择 Coinjoin 方案是能做到事事了然，但能问出合理的问题。一套评估不同 Coinjoin 实现的思维模式，或者说框架，对于考量使用 Coinjoin 拿回自己的隐私性的用户是非常有用的。分辨社交媒体上的噪音需要智性上的诚实，以及严格运用正确的评估系统。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">用户到底如何屏蔽噪音，发现最好的 coinjoin 办法、混合自己的比特币交易？</summary>
    
    
    
    
    <category term="CoinJoin" scheme="https://www.btcstudy.org/tags/CoinJoin/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin Core 24.0 更新了什么</title>
    <link href="https://www.btcstudy.org/2022/12/10/bitcoin-core-24-0-released-what-is-new/"/>
    <id>https://www.btcstudy.org/2022/12/10/bitcoin-core-24-0-released-what-is-new/</id>
    <published>2022-12-10T11:46:58.000Z</published>
    <updated>2023-01-12T06:01:27.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Namcios</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/bitcoin-core-24-0-released-what-is-new">https://bitcoinmagazine.com/technical/bitcoin-core-24-0-released-what-is-new</a></em></p></blockquote><p>最早由<a href="https://bitcoinmagazine.com/guides/who-created-bitcoin">中本聪</a>在 2009 年发布的软件，现在发布了一个新版本。</p><p>Bitcoin Core 24.0 由 112 名开发者，耗时约 7 个月开发而成，给 Bitcoin Core 的钱包模块、点对点（P2P）通信、图形用户界面等等，带来了可观的提升。</p><p>本文介绍了一些重要的变更。</p><h2 id="钱包模块升级"><a href="#钱包模块升级" class="headerlink" title="钱包模块升级"></a>钱包模块升级</h2><h3 id="初步的-Miniscript-支持"><a href="#初步的-Miniscript-支持" class="headerlink" title="初步的 Miniscript 支持"></a>初步的 Miniscript 支持</h3><p>Bitcoin Core 24.0 通过拓展 <code>wsh()</code> 输出操作符，引入了对 Miniscript 的支持。虽然这还是初步的集成，但也为在比特币上更简单、更安全地部署更复杂的脚本提供了帮助。</p><p><a href="https://bitcoin.sipa.be/miniscript/">Miniscript</a> 可以被认为是 <a href="https://en.bitcoin.it/wiki/Script">Bitcoin Script</a>（比特币的原生编程语言）的一种框架（或者说模板）。Bitcoin Script 负责支持比特币可用的所有编程功能，其中就包括（举个例子）可能是最简单的一种程序（脚本）：决定谁可以花费某一笔资金。对每一笔比特币交易，发送者都要请求接收者的地址，并使用这一信息构造一个脚本，将支付的数额锁定，使得只有接收者可以花费它。虽然用 Bitcoin Script 可以很容易构造这样的简单脚本，但更复杂的脚本就有更大概率遇上人力出错。这就是为什么我们需要 Miniscript。</p><p>Miniscript 允许我们以 <em>结构化</em> 的方式编写 Bitcoin Script 的子集。它支持分析、组合、通用签名，等等，让开发者可以更安全地编写更高级的脚本。换句话来说，Miniscript 将预定义的 Bitcoin Script 的一些功能模块 “装载” 到了一套符合预期的行为模式中，从而限制了最终的风险，因为尽可能地减少了意外的行为。在实践中，它为开发者修补和创建更高级、更复杂的比特币脚本提供了一个 “工具箱”，而不是只能手动操作 Bitcoin Script。</p><p>从 Bitcoin Core 24.0 开始，用户将可以创建包含一段 Miniscript 脚本的钱包、为之创建地址并充值资金。但 Bitcoin Core 的钱包模块还不支持从这些地址中花费，意思是就当下而言，Bitcoin Core 中启用了 Miniscript 的钱包只能用作观察。</p><h3 id="不设找零的交易"><a href="#不设找零的交易" class="headerlink" title="不设找零的交易"></a>不设找零的交易</h3><p>Bitcoin Core 24.0 引入了一种新的 RPC， <code>sendall</code> ，允许用户完全花费掉特定的 UTXO。这个 RPC 将把指定 UTXO 中的价值完全转移到一个或多个接收者处，而不会产生找零。（默认情况下， <code>sendall</code> 会花掉钱包中的所有 UTXO。）</p><p>这种行为在一些情况下是有用的。第一种自然是用户想要清空自己的钱包的时候。调用这个新的 PRC，仅使用默认的配置，就可以轻松完成清空钱包的操作。其次，客户可能希望通过放弃找零来提高隐私性。</p><p><a href="https://en.bitcoin.it/wiki/Change">找零地址</a>是很棘手的，因为用户经常不知道它们是怎么来的，而且用可能会在未来的交易中跟其他 UTXO 一起作为输入；这会因为 “<a href="https://en.bitcoin.it/wiki/Common-input-ownership_heuristic">输入所有权同一启发法</a>” 导致隐私性风险 —— 这是一种在区块链分析中常用的工具，它假设一笔交易的所有输入都来自于同一个用户。如果找零输出跟别的输出混在一起，用户就会制造出这种关联，产生让自己的多笔资金去匿名化的风险，因为分析师会将这多个地址都归类为同一个钱包。</p><p>不设找零的支付，通过创建完全花费选定的 UTXO 的交易，解决了这个问题。因为没有找零，用户就不会犯上面提到的错误。而且，无找零的支付给区块链分析带来了一个合理的疑难：新输出到底是由发起支付的人自己拥有的（即只是转移了资金到新的地址）呢，还是变换了所有者。</p><p>（译者注：作者这里的推理是不成立的。因为找零地址跟普通收款地址没有任何区别，找零输出不是因为其地址上的特征而被辨认为找零的；而找零输出之所以要跟收款输出混用，是因为其面额不足。所以，就算不使用找零地址，也一样会有被辨认为找零的输出（除非输入的面额刚刚好）；而这样的输出一旦面额不足以支付，一样会跟别的输出混用，从而被启发式分析捕捉。事实上，这个功能只有管理上的便利 —— 用户可以手动避免使用 “找零地址”，也即跟收款地址的推导路径不一样的地址 —— 但不可能因此就不再产生找零输出。）</p><h3 id="找零输出随机化，以避免留下痕迹"><a href="#找零输出随机化，以避免留下痕迹" class="headerlink" title="找零输出随机化，以避免留下痕迹"></a>找零输出随机化，以避免留下痕迹</h3><p>如上所述，<a href="https://en.bitcoin.it/wiki/Privacy#Change_address_detection">找零输出可能会泄露隐私</a>。虽然 <code>sendall</code> 可以减少对找零地址的使用，但在现实中，很少时候用户会刚好持有跟支付数目相等的面额的 UTXO。保证观察者无法辨认哪个输出是找零可以帮助用户获得少许隐私性，因为将难以把新创建的输出（找零输出）跟现在被花费的输入关联起来。</p><p>通常，当没有一个 UTXO 的面额恰好相当于支付的需要事，大部分钱包和用户会按直觉选择面额最接近于支付需求的 UTXO。结果是，观察者可以很清楚的看出哪个输出是支付（通常是更大的那个）、哪个输出是找零（更小的那个）。这带来了上面提到的许多风险。</p><p>为了降低观察者分辨出找零输出并归集用户地址的可能性，Bitcoin Core 现在会随机化找零输出的面额。</p><p>从 Bitcoin Core 24.0 开始，钱包模块将在支付数额与支付数额的三倍值之间选出一个随机数。这个数字将为 UTXO 选择提供指引。本质上，这意味着有时候宣发会选出一个 UTXO，其面额跟支付额是很接近的，但有时候，它会选出一个 UTXO，其面额会跟支付额的三倍更接近。前者会产生一般化的、找零输出面额低于支付输出的交易；而后者会产生相反的情形，找零输出会大于支付输出。因为区块链观察者无法辨别一笔交易到底是哪一种情形，用户自然就获得了更好的隐私性保证。</p><h3 id="升级-“手续费替换（RBF）”"><a href="#升级-“手续费替换（RBF）”" class="headerlink" title="升级 “手续费替换（RBF）”"></a>升级 “手续费替换（RBF）”</h3><p>在比特币用户将交易发送到网络中时，RBF 给用户提供了选择权。通常，用户不想给矿工太多手续费，因此在手续费和区块确认速度之间选择一个平衡点。但是，如果用户选择的手续费数值太低，或者说交易池正在拥堵，那么交易可能要花很长时间才能得到确认（甚至会卡在交易池里面）。RBF 让用户可以追加手续费，通常都能更快处理。</p><p>从原理上来说，RBF 并没有 “追加” 手续费，只是软件会广播一笔 <em>新</em> 的交易，使用跟原版交易同样的输入以及大部分相同的输出（一些输出的面额改变了，因此手续费的数值自然也改变了）。</p><p>在以前，节点只会转发它们见到的交易的第一个版本。而有了 RBF 之后，就出现了一种机制（译者注：即 BIP125），让用户可以自己用标签表示发起的这笔交易是否能被追加手续费，也即被带有更高手续费的版本替换。这是对节点的提醒，让他们知道可能后面会出现同一笔交易的更高手续费的版本，而且他们也应该转发。更高手续费的替换版本有概率会被矿工认为有吸引力，因此打包到下一个区块。替换版本得到确认之后，更低手续费的版本就会从节点的交易池中剔除，因为它们变成了重复花费的交易。</p><p>Bitcoin Core 24.0 给 RBF 模块引入了两种更新。</p><p>首先，它让用户可以配置节点，转发一切交易的替换版本，<em>不论</em> 交易本身是否使用了 RBF 标签。这可以通过新的 <code>mempoolfullrbf</code> 选项来配置。这个选项默认是 <em>关闭</em> 的，但有兴趣的人可以打开它。</p><p>其次，RBF 现在变成了 Bitcoin Core 钱包模块的标准，交易会默认使用 RBF 标签，而且 <code>-walletrbf</code> 选项默开启。用户可以在交易构建流程中改变 RBF 选项，也可以将 <code>-walletrbf</code> 启动选项设为关闭。</p><h3 id="描述符钱包迁移"><a href="#描述符钱包迁移" class="headerlink" title="描述符钱包迁移"></a>描述符钱包迁移</h3><p><a href="https://bitcoinmagazine.com/technical/bitcoin-core-23-0-released-whats-new">Bitcoin Core 23.0</a> 让描述符钱包变成了标准。描述符可以帮助用户以标准化的格式备份钱包以及恢复备份。</p><p>在描述符出现之前，用户需要知道自己的钱包的派生路径，这个路径指明了钱包的主私钥如何推导出地址，用户接收和发送比特币。因为钱包可以有不同的推导路径，所以光备份种子词已经不足以保证能恢复钱包了。有时候用户比较幸运，新钱包软件跟老钱包软件恰好使用了相同的派生路径，所以种子词备份能顺利复原钱包；但也有小概率用户无法顺利恢复，因此出现了<a href="https://walletsrecovery.org/">一个网站</a>专门帮助用户搞清楚不同软件所用的派生路径。</p><p>描述符通过 <em>描述</em> 备份所用的派生路径，解决了这个问题、显著优化了用户体验。它背后的理念是，一个描述符钱包备份，自身就包含了让任意的软件正确恢复钱包的所有必要信息（只要这个软件支持描述符）。</p><p>现在，Bitcoin Core 24.0 引入了一种新工具，将传统的钱包迁移成描述符钱包，让用户能够利用这种新兴的标准，更好地保护用户的珍贵的比特币。虽然它还是一个实验性的功能，它也有一种新的 RPC（ <code>migratewallet</code> ）。<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/managing-wallets.md#migrating-legacy-wallets-to-descriptor-wallets">这份文档</a>提供了更多细节。</p><h2 id="图形用户界面（GUI）变更"><a href="#图形用户界面（GUI）变更" class="headerlink" title="图形用户界面（GUI）变更"></a>图形用户界面（GUI）变更</h2><p>众所周知，Bitcoin Core GUI 没能提供媲美远程过程调用（PRC）和命令行工具的功能。Bitcoin Core 24.0 为此采取了一些措施。</p><p>Bitcoin Core 24.0 给 GUI 带来了一个新的菜单，让用户可以从备份中恢复一个钱包，因此不懂技术的用户也更容易复原钱包了。以前，这个功能还只存在于命令行中。</p><p>与 RPC 接口相比，GUI 的另一个缺点是 Bitcoin Core 客户端的设定。以前， <code>bitcoin.conf</code> 文件可以说是 Bitcoin Core 配置的圣杯，但它也主要是通过命令行来调整的。GUI 中也存在一个调整设定的选项，但一个警告明确指出，如果文件和 GUI 尝试设置同一项设定，文件的优先级高于 GUI。因此，虽然 GUI 提供了改变设定的简单选项，但配置文件依然是定制化你的 Bitcoin Core 客户端的最可靠的方法。</p><p>Bitcoin Core 24.0 改变了这一点。这次的更新将 GUI 的设定页与  <code>bitcoin.conf</code> 文件统一了起来。现在，当用户在 GUI 打开客户端设置时，其中的内容是从配置文件中拉取过来的。类似地，GUI 中作出的配置变更，也会反映在  <code>bitcoin.conf</code> 里面。（值得一提的是，两者的关系是间接的，因为 GUI 作出的变更会写在 <code>settings.json</code> 文件里面，这个文件优先于 <code>bitcoin.conf</code> 。）</p><h2 id="P2P-通信的变更"><a href="#P2P-通信的变更" class="headerlink" title="P2P 通信的变更"></a>P2P 通信的变更</h2><h3 id="下载区块头的新逻辑"><a href="#下载区块头的新逻辑" class="headerlink" title="下载区块头的新逻辑"></a>下载区块头的新逻辑</h3><p>Bitcoin Core 24.0 为节点在网络中捕捉区块链顶端的方式带来一种升级；不论节点是第一次加入网络，还是因长时间离开网络而必须捕捉最新区块。</p><p>在本次更新以前，刚加入比特币网络的新节点要先寻找对等节点，然后从对等节点开始下载区块头。这些新节点一开始不会下载完整的区块，因为节点被引导在下载一条链的区块之前先检查这条链是不是最值得信任的一条。不然，节点就会承担下载错误链上的区块、从而浪费资源的风险。</p><p>虽然下载区块头的目的是节约时间和资源，依然有可能出现一种资源耗尽攻击，就是恶意的对等节点发送大量的假区块头给请求区块头的节点。因为节点需要下载和保存区块头在硬盘上，大量的数据可能导致节点的硬件过载。</p><p>为了缓解这种威胁，Bitcoin Core 在几年前引入了 “<a href="https://bitcoin.stackexchange.com/questions/1797/what-are-checkpoints">检查点</a>” 的概念。检查点决定了一条链 <em>必须</em> 包含 某一些区块，才是有效的。但是，这种解决方案会带来一种新问题 —— 检查点可能被滥用，导致实质上的最长链被否定。这种可能性在比特币中是不受欢迎的，所以我们必须提出另一种解决方案。这就是这次的升级。</p><p>在 Bitcoin Core 24.0 中，节点会下载区块头两次。在第一轮中，节点只会下载，但随后就抛弃掉（不会保存在硬盘中），知道发现足够多的工作量证明 —— 表明这条链是对的那一条。这时候，节点就会重新开始下载区块头，但这一次，节点会将区块头保存在硬盘中。先确保自己所下载的区块头是具有足够多的工作量证明的链的一部分、再保存区块头到硬盘上，节点避免了在可能的攻击（例如资源耗竭攻击）中花费大量存储资源。这也移除了设置检查点的需要，而且可以说是一种更优雅的解决方案，因为它不依赖人力输入来决定链的有效性。</p><p><em>感谢 Aaron van Wirdum 的反馈。</em></p><p><em>要了解更多细节和其它变更，请看 Bitcoin Core 24.0 <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-24.0.md">更新说明</a>。要下载 Bitcoin Core 24.0，请到<a href="https://bitcoincore.org/bin/bitcoin-core-24.0/">这个网页</a>。关于 Bitcoin Core 24.0 的细节，也在 Bitcoin, Explained 播客的<a href="https://nadobtc.libsyn.com/bitcoin-explained-65-bitcoin-core-240">第 65 期</a>有解释。</em></p><p>（完）</p>]]></content>
    
    
    <summary type="html">比特币历史最悠久的客户端软件的最新版本，带来了可用性、隐私性和安全性的提升。</summary>
    
    
    
    <category term="比特币主网" scheme="https://www.btcstudy.org/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BB%E7%BD%91/"/>
    
    
    <category term="开发" scheme="https://www.btcstudy.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>比特币多签指南</title>
    <link href="https://www.btcstudy.org/2022/12/09/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/"/>
    <id>https://www.btcstudy.org/2022/12/09/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/</id>
    <published>2022-12-09T06:13:35.000Z</published>
    <updated>2023-01-12T06:01:27.432Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Mi Zeng</em></p><p><em>来源：<a href="https://github.com/zengmi2140/multisig/blob/main/README.md">https://github.com/zengmi2140/multisig/blob/main/README.md</a></em></p></blockquote><p>多签钱包，顾名思义，指需要多把私钥签名才能控制的钱包。作为一种更安全的资产保管方案，多签钱包诞生已久。但由于流程复杂，目前多签主要被企业/交易所等机构用于管理大量资产。实际上，只要理解了它的基本原理，每个人都可以通过多签来进一步提升资产的安全等级。</p><p>本文旨在提供一份详细的比特币多签钱包实践指南，主要面向对钱包、私钥、交易等概念有基本了解的用户（因此文中不会介绍这些基础知识）。对这些概念尚不清楚的读者，文末的扩展阅读部分精选了一系列资料，供您查阅。</p><p>本指南在写作过程中大量参考了 Michael Flaxman 的<a href="https://btcguide.github.io/">《比特币十倍安全指南》</a>，Michael 在他的指南中详细地列出了比特币多签涉及到的几乎所有细节。本指南对多签钱包的关键概念进行了梳理，总结了一套比特币多签的基本操作框架，引入了更简洁高效的描述符作为钱包备份方案，并在不牺牲安全性的前提下尽可能地简化了操作流程。读者可遵循本指南提供的方法一步步创建比特币多签钱包，完善自己的资产保管方案。</p><h2 id="为什么您应该考虑多签钱包？"><a href="#为什么您应该考虑多签钱包？" class="headerlink" title="为什么您应该考虑多签钱包？"></a>为什么您应该考虑多签钱包？</h2><p>在开始多签实践之前，明确我们为什么需要使用多签钱包至关重要。</p><p>“我已经用上了硬件钱包来保管资产，这还不够安全吗？” 这是关于钱包安全的一个常见误解。不可否认的是，使用硬件钱包比起在线钱包而言，资产的安全性已经上升了一个等级。但实际上，硬件钱包可能遭受的攻击要远比您想象的多，感兴趣的读者可以看下<a href="https://www.youtube.com/watch?v=P5PI5MZ_2yo">这个视频</a>。</p><p>硬件钱包的意义仅在于将私钥与在线设备分离，使得资产免受诸如在线设备遭到攻击/恶意软件 等因素造成的损失，但依然无法消除单签钱包可能导致的其它单点故障，而这些故障对于资产安全而言是致命的。这些单点故障包括但不限于：</p><ul><li>助记词丢失/损坏</li><li>助记词被盗</li><li>硬件钱包遭到供应链攻击/使用了被做过手脚的硬件钱包</li><li>硬件钱包自身存在安全漏洞</li><li>计算机/手机被攻击，向硬件钱包传递恶意的待签名交易</li><li>用于生成私钥的随机数生成器有问题</li><li>······</li></ul><p>针对第一点：助记词丢失/损坏，用户可以通过 多抄录几份助记词/异地备份/使用更坚固的保存介质（比如钢板）等途径来避免其造成的破坏。</p><p>针对第二点：助记词被盗，不少用户会采用一些组合策略，包括以下四种形式：</p><p>1.助记词乱序保存+单独存放混乱的顺序</p><p>2.助记词拆成两份，分开保存</p><p>3.助记词使用某种算法加密（比如 AES256）+ 单独保存加密密钥</p><p>4.助记词 + 密语（passphrase），使用隐藏钱包</p><p>方案一的实际效果非常糟糕，由于助记词的最后一个单词是前面所有单词的校验和，因此暴力破解乱序的助记词难度并不高。即便在真实的助记词中插入了其他单词来混淆视听，也起不到多大帮助，熟练的攻击者甚至只需几个小时便可破解出正确的顺序。针对这一方案的安全性，可以看看 Jameson Lopp 写的这篇<a href="https://blog.lopp.net/bitcoin-seed-security-analysis/">分析文章</a>。</p><p>方案二的安全性和方案一次相比提升并不大。以 12 位的助记词为例，可能的单词排列一共有 2048^11 种（BIP39 定义的单词表包含 2048 个单词，12 位助记词中的最后一位由前 11 位计算得出），当前的技术水平基本不可能破解。一旦攻击者拿到了其中一半，剩余可能的单词排列<strong>最多</strong>只有 2048^6 种，而实际上由于校验和的存在，可能的排列数要比这还少得多，因此破解的工作量会指数级下降。</p><p>方案三和方案四在一定程度上提高了安全性，攻击者即便拿到了部分助记词，在缺失剩余组件的情况下依然无法盗取资产，可以看作<strong>简陋</strong>的 “2-2 多签 ”，但这些方案的另一面是更糟糕的容错性，钱包所有者一旦丢失备份中的任一部分，就会丢失资产。并且这些方案无法避免诸如 随机数生成器漏洞/硬件钱包漏洞 等因素带来的安全性风险。</p><p>到这里，我们可以看出，尽管这些方法在一定程度上提高了助记词的安全性，但在遭遇其它的单点故障时，单签钱包就无能无力了。</p><p>相较于以上这些方案，<strong>多签钱包的意义在于提供了一个可以抵御单点故障的保管方案，为资产提供更高的安全性和容错性</strong>。只要遵守了基本的安全原则（<strong>m-n 多签，n&gt;m&gt;1，使用不同品牌的硬件钱包且分开放置</strong>），即便是最简单的多签钱包，其安全性也远胜采用了上述众多方案的单签钱包。攻击者要想盗取您的资产，至少需要破坏两道防线。当然，没有 100% 完美的安全方案。两次以上的致命故障，仍然会让您丢失所有资产。</p><p>那么，如何开始创建您的第一个多签钱包呢？</p><blockquote><p>由于不同的区块链上实现多签钱包的原理并不相同，本指南提供的方法仅适用于比特币多签钱包，要创建其它区块链上的多签钱包，读者需自行寻找资料。如果读者想通过单一方案来为助记词提供更高的容错性，可以考虑 shamir 助记词分片方案（将助记词分成三份，集齐任意两份即可恢复出完整的助记词）。但针对上文提到的其它单点故障，该方案依然无济于事。</p></blockquote><h2 id="如何开始多签？"><a href="#如何开始多签？" class="headerlink" title="如何开始多签？"></a>如何开始多签？</h2><p>如果您对多签钱包的基本概念尚不了解，请先阅读<a href="https://www.btcstudy.org/2021/10/18/what-is-multi-signature-wallet-and-recommend-choices/">这篇文章</a>，然后再进入下文的实践部分。</p><h3 id="选定多签规则（m-n）"><a href="#选定多签规则（m-n）" class="headerlink" title="选定多签规则（m-n）"></a>选定多签规则（m-n）</h3><p>在开始创建多签钱包之前，首先需要选择适合您的多签规则（m-n）：即多签钱包的私钥总数（n）和成功发起交易所需的私钥数量（m）。例如：一个 2-3 的多签钱包代表这个钱包一共由 3 把私钥控制，只需动用其中任意两把私钥即可花费资金。</p><p>多签规则的选择因使用场景而异，不同场景的安全需求和风险偏好都不一样，企业用来管理资金而选用的多签规则和个人使用多签来保护资产的规则也不尽相同。并非更多的私钥数量就会带来更高的安全性，它也会带来更高的使用成本和备份难度，同时降低使用时的便利性。此外，m-n 的比例对于钱包的安全性也有重大影响。<a href="https://www.btcstudy.org/2022/05/11/bitcoin-multisig-2-of-3-vs-3-of-5/#%E5%AE%89%E5%85%A8%E6%80%A7%E7%A6%BB%E4%B8%8D%E5%BC%80%E5%8F%96%E8%88%8D">这篇文章</a>分析了不同多签规则的权衡。</p><p>对于个人用户而言，使用 2-3 多签钱包来保护资产安全是在安全性和便利性之间的一个很好的平衡。 2-3 多签在提供了高安全性和容错性的同时，也使得您所需保管的私钥备份数量最少，采购硬件签名器的成本最低。</p><h3 id="多签基本元素"><a href="#多签基本元素" class="headerlink" title="多签基本元素"></a>多签基本元素</h3><p>在 2-3 多签方案中，一共需要 3 把私钥来创建多签钱包。其中任意两把私钥作为签名私钥，用于平时发送交易。第三把私钥则作为恢复私钥，仅在前两把私钥中任意一把发生安全问题时用于恢复多签钱包，转移资产。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/3-key.png"></p><p>为了实现安全的多签，我们需要以下基本元素：</p><ul><li>计算机上的软件钱包：用于创建多签钱包、收款、构造和发送交易</li><li>硬件钱包：用于离线生成及保存私钥、并作为签名器签署交易</li><li>钱包备份：用于恢复多签钱包，包括助记词的备份和扩展公钥的备份</li></ul><blockquote><p>由于硬件钱包实际上并不具备完整的钱包功能，它的主要作用是签名交易和离线保存私钥。在下文中，改用硬件签名器来称呼硬件钱包，和其它钱包区分开来。</p></blockquote><h4 id="选择合适的软件钱包"><a href="#选择合适的软件钱包" class="headerlink" title="选择合适的软件钱包"></a>选择合适的软件钱包</h4><p>当前对比特币多签支持较好的软件钱包有：<a href="https://specter.solutions/">Specter</a>、<a href="https://sparrowwallet.com/">Sparrow</a>、<a href="https://electrum.org/">Electrum</a>、<a href="https://nunchuk.io/">Nunchuk</a> 等。综合考虑便利性和使用体验后，本文选用 Sparrow 作为示范。文末的扩展阅读部分提供了利用其它软件钱包实现比特币多签的教程。</p><p>请注意，无论选用哪款软件钱包，请务必从官网下载并进行验证。在每种钱包的官网，您都可以找到相应的验证方法。</p><h4 id="选择合适的硬件签名器（Signer）"><a href="#选择合适的硬件签名器（Signer）" class="headerlink" title="选择合适的硬件签名器（Signer）"></a>选择合适的硬件签名器（Signer）</h4><p>为比特币多签选择硬件签名器有两条核心原则：</p><ol><li><p><strong>务必</strong>选用来自不同制造商生产的硬件签名器，这样，即便您的多签方案中有一款硬件签名器存在安全问题，资产依然可以安然无恙。如果都选用同一款硬件签名器，那么面对硬件问题这一单点故障，多签也无济于事。</p></li><li><p>选择支持 PSBT 的硬件签名器。PSBT （部分签名的比特币交易）是一种标准格式，用于传递待签名的比特币交易，它可以帮助硬件签名器理解和验证当前正在签名的这笔交易信息。每个签名方对 PSBT 签名后，将相应的 PSBT 合并起来，即可形成一笔完整签名的交易，实现跨越不同硬件和软件钱包的多签。PSBT 使得比特币多签更加简单和安全，更详细的介绍可以看<a href="https://www.btcstudy.org/2022/08/15/what-are-partially-signed-bitcoin-transactions-psbts/">这篇文章</a>。当下在售的支持 PSBT 的硬件签名器有：BitBox、Coldcard、Jade、Keystone、Ledger、NGrave、Passport、Seed Signer。</p></li></ol><p>在符合以上两点原则的前提下， 我们可以根据以下标准来挑选硬件签名器。</p><ol><li>尽量选用带有安全芯片的硬件签名器</li><li>尽量选用开源的硬件签名器</li><li>选用有比特币专属（BTC-Only）固件的硬件签名器：支持山寨币会使得代码库变得更加复杂，引入安全漏洞的可能性也就越大。</li><li>尽量选用完全离线（Air-gapped）的硬件签名器（没有 USB、蓝牙、NFC 等和在线设备直接连接的方式）</li></ol><p>不过即便您选用的硬件签名器未能满足上述所有标准，比如选用了尚未开源的 Ledger，或者没有安全芯片的 Seed Signer，并非完全离线的 BitBox 等，由于多签钱包强大的容错能力，资产的安全性依然远高于单签钱包。</p><p>现阶段，符合上述所有标准的硬件签名器有：</p><ul><li><a href="https://coldcard.com/">Coldcard</a></li><li><a href="https://keyst.one/">Keystone</a></li><li><a href="https://foundationdevices.com/">Passport</a></li></ul><p>请注意：购买硬件签名器唯一靠谱的渠道就是官网。在多签钱包的使用过程中，硬件签名器一定要分开保存在不同的地方。</p><h4 id="多签钱包的备份方法"><a href="#多签钱包的备份方法" class="headerlink" title="多签钱包的备份方法"></a>多签钱包的备份方法</h4><p>多签钱包的备份有别于普通的单签钱包（一般通过助记词即可恢复），除了需要备份三把私钥的助记词以外，还需要备份私钥对应的扩展公钥。当恢复多签钱包时，需要 m 份私钥的助记词和 n  份扩展公钥，才能花费钱包内的资金。</p><p>关于助记词的备份方式，已经有非常多的相关文章，因此本文中不再展开说明。</p><p>备份多签钱包的扩展公钥主要有两种方式：多签配置文件和描述符。</p><h5 id="多签配置文件"><a href="#多签配置文件" class="headerlink" title="多签配置文件"></a>多签配置文件</h5><p>在描述符出现之前，一般通过多签配置文件来备份扩展公钥。多签配置文件包含了构建多签钱包所需的所有信息，包括：</p><ul><li>多签钱包的地址类型（传统地址还是隔离见证地址）</li><li>多签的规则（m-n）</li><li>BIP32 路径：从助记词到扩展公钥的派生路径</li><li>每个签名方的的扩展公钥（xpub）</li><li>每个签名方的私钥标识符（Master Fingerprint ）</li></ul><p>多签配置文件长下面这个样子（不同软件导出的多签配置文件格式上会有出入）：</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/multi-confi.png"></p><p>有了这些信息，就可以在软件钱包上恢复出完整的多签钱包。</p><h5 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h5><p>描述符（Descriptor）是一串包含上述所有关键信息的字符串，精确地描述了如何通过扩展公钥派生出钱包的流程，极大地方便了用户在不同钱包软件之间导入导出钱包的操作。尤其是当我们在使用多签钱包时，描述符可以提升我们在不同软件之间迁移多签钱包的效率，简化备份文件的复杂程度。</p><p>描述符长下面这个样子：</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/descriptor-example.png"></p><p>目前主流的比特币软件钱包均已支持描述符，因此本指南更推荐您使用描述符作为多签钱包的备份方案。</p><p>注意：任何获得您多签配置文件或者描述符的人，都可以在他的计算机上恢复出您的多签钱包，这并不会影响您的资金安全（因为没有满足条件的私钥就无法签名交易），但会泄漏钱包余额和交易历史等私人信息。因此，建议将钱包备份文件离线保存，或保存在密码管理器中。</p><h3 id="多签的基本流程"><a href="#多签的基本流程" class="headerlink" title="多签的基本流程"></a>多签的基本流程</h3><p>一笔多签交易的基本流程如下：</p><ol><li>在计算机上利用软件钱包构造交易</li><li>将待签名的交易传递给硬件签名器进行签名（通过 PSBT 格式）</li><li>硬件签名器验证交易信息，签名交易。</li><li>将已签名的交易传回计算机</li><li>计算机收集到足够的签名后（在 2-3 多签中为 2 份签名），广播交易</li><li>交易被打包上链</li></ol><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/multisig-step-by-step.png" alt="multisig-step-by-step.png"></p><h2 id="动手实践吧（以-2-3-多签为例）"><a href="#动手实践吧（以-2-3-多签为例）" class="headerlink" title="动手实践吧（以 2-3 多签为例）"></a>动手实践吧（以 2-3 多签为例）</h2><blockquote><p>下文旨在给出一份以极致安全为目的的多签方案，因此两个签名方都使用了硬件签名器。实际上，由于多签提供了额外的安全保障，即便您使用了离线手机，甚至是联网的热钱包来作为其中一个签名器，资产的安全性依然高于使用硬件签名器的单签钱包。</p></blockquote><h3 id="设备清单"><a href="#设备清单" class="headerlink" title="设备清单"></a>设备清单</h3><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/equipment.jpeg" alt="设备清单"></p><ol><li>硬件签名器两台，本指南选用的硬件签名器为 Coldcard MK3（$157） 和 Keystone Pro（$169）</li><li>一台带有摄像头的计算机，用于安装比特币钱包作为观察钱包，来协调多签交易</li><li>一粒标准骰子，作为私钥生成过程中的随机数来源</li><li>一张 Micro SD 卡（存储空间 &lt;= 32GB，FAT32 格式）及对应的读卡器</li><li>纸和笔，用来备份钱包助记词</li></ol><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="计算机端"><a href="#计算机端" class="headerlink" title="计算机端"></a>计算机端</h4><p>在计算机上下载、验证和安装最新版的 Sparrow 钱包作为观察钱包（Windows/Mac/Linux 均适用）：<br><a href="https://www.sparrowwallet.com/download/">https://www.sparrowwallet.com/download/</a></p><p>按照此指南快速设置 Sparrow 钱包：<br><a href="https://www.sparrowwallet.com/docs/quick-start.html">https://www.sparrowwallet.com/docs/quick-start.html</a></p><blockquote><p>在 Sparrow 初始设置阶段，会让您选择 Sparrow 连接的服务器。对于只想体验多签钱包，或者管理的资金不多的用户而言，可以选择公共服务器（Public Server），但这会泄漏您的隐私。公共服务器的运营者可以很容易地将您的钱包地址和身份联系起来。如果打算存储大量的资金，强烈建议连接到自己运行的比特币节点。</p></blockquote><h4 id="硬件签名器"><a href="#硬件签名器" class="headerlink" title="硬件签名器"></a>硬件签名器</h4><p>1.从<strong>官网</strong>购买硬件签名器：</p><ul><li>Coldcard 官网： <a href="https://coldcard.com/">https://coldcard.com/</a></li><li>Keystone 官网： <a href="https://keyst.one/">https://keyst.one/</a></li></ul><p>2.收到钱包后，首先验证是否被动过手脚，查验真伪，然后进行初始化设置，熟悉钱包的使用。Coldcard 和 Keystone 都采用了优秀的防伪机制，方便用户进行验证。教程如下：</p><p>Keystone 产品验证和初始化设置教程： <a href="https://support.keyst.one/v/traditional-chinese/kai-shi-shi-yong/kai-shi-shi-yong-keystone-qian-bao-new#di-1-bu-guan-wang-yan-zheng">https://support.keyst.one/v/traditional-chinese/kai-shi-shi-yong/kai-shi-shi-yong-keystone-qian-bao-new#di-1-bu-guan-wang-yan-zheng</a></p><p>Coldcard 产品验证和初始化设置教程： <a href="https://coldcard.com/docs/ultra-quick">https://coldcard.com/docs/ultra-quick</a></p><p>3.升级钱包到最新固件</p><p>Coldcard 固件升级教程： <a href="https://coldcard.com/docs/upgrade">https://coldcard.com/docs/upgrade</a></p><p>固件验证教程： <a href="https://www.youtube.com/watch?v=RYcB5HpfcaE">https://www.youtube.com/watch?v=RYcB5HpfcaE</a></p><p>Keystone 出厂默认为多币种固件，请切换为比特币单币种（BTC-Only）固件，在<a href="https://keyst.one/firmware">此处</a>下载固件，并按照此教程进行升级： <a href="https://support.keyst.one/v/traditional-chinese/kai-shi-shi-yong/ru-he-sheng-ji-gu-jian">https://support.keyst.one/v/traditional-chinese/kai-shi-shi-yong/ru-he-sheng-ji-gu-jian</a></p><p>固件验证教程： <a href="https://support.keyst.one/v/traditional-chinese/kai-shi-shi-yong/ru-he-sheng-ji-gu-jian/ru-he-jian-cha-guan-wang-sheng-ji-bao-de-sha256sum">https://support.keyst.one/v/traditional-chinese/kai-shi-shi-yong/ru-he-sheng-ji-gu-jian/ru-he-jian-cha-guan-wang-sheng-ji-bao-de-sha256sum</a></p><h3 id="创建及备份多签钱包"><a href="#创建及备份多签钱包" class="headerlink" title="创建及备份多签钱包"></a>创建及备份多签钱包</h3><h4 id="创建三个私钥并导出扩展公钥"><a href="#创建三个私钥并导出扩展公钥" class="headerlink" title="创建三个私钥并导出扩展公钥"></a>创建三个私钥并导出扩展公钥</h4><p>此过程需要注意如下三点：</p><ol><li>三把私钥都要在完全离线的环境中创建，然后导出扩展公钥（创建多签钱包时要用到，下文会给出导出方法）。</li><li>为了避免随机数生成器可能存在漏洞而造成安全影响，同时简化操作流程，本指南中两把签名私钥分别由 coldcard 和 keystone 生成，恢复私钥的创建则使用掷骰子来生成随机数。</li><li>三把私钥创建好后都要执行验证流程（创建钱包 &gt; 抄下助记词 &gt; 删除钱包 &gt; 重新导入抄好的助记词 &gt; 验证地址是否一致 &gt; 完成验证），并做好备份，分开存放。</li></ol><blockquote><p>Keystone 验证流程：设置 &gt; 恢复出厂设置，然后重新初始化钱包，通过助记词导入钱包</p><p>Coldcard 验证流程：Advanced &gt; Danger Zone &gt; Seed Functions &gt; Destroy Seed，然后重新通过助记词导入钱包</p></blockquote><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/generate-key.png"></p><p>首先，我们通过掷骰子生成恢复私钥（下文用 Key3 指代恢复私钥）:</p><p>出于操作上的便利性，本指南选用 Keystone 来完成掷骰子生成私钥的操作，方法如下：<br><a href="https://support.keyst.one/v/traditional-chinese/gao-ji-gong-neng/zhu-ji-ci/shi-yong-tou-zi-chuang-jian-zhu-ji-ci">https://support.keyst.one/v/traditional-chinese/gao-ji-gong-neng/zhu-ji-ci/shi-yong-tou-zi-chuang-jian-zhu-ji-ci</a></p><blockquote><p>Coldcard 也同样支持<a href="https://www.youtube.com/watch?v=Rc29d9m92xg">掷骰子生成私钥</a>，另一款常用的工具是 <a href="https://seedpicker.net/">SeedPicker</a>。</p></blockquote><p>在完成 Key3 的创建、备份和验证后，将 Micro SD 卡插入 Keystone，点击 “多签钱包”，选择 “通用钱包”，按照下图所示步骤导出 Key3 对应的扩展公钥后，保存到计算机上。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/keystone-export-xpub-0.png"></p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/keystone-export-xpub.png"></p><p>接着，将 Keystone 恢复出厂设置，重新完成初始化设置后，创建新的种子助记词，作为第一把签名密钥 （Key1），然后按照上面的方法再次导出扩展公钥文件，保存至计算机。</p><p>最后，在 Coldcard 上生成新钱包，作为第二把签名密钥（Key2）。然后将 Micro SD 卡插入 Keystone，按照下图所示步骤导出扩展公钥，保存到计算机。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/export-xpub-form-coldcard.jpeg"></p><blockquote><p>如果不嫌麻烦的话，您也可以选择通过掷骰子的方式来生成三把私钥的助记词，彻底断绝随机随机数生成器可能带来的安全影响。</p></blockquote><p>在完成上述步骤后，我们有了：</p><ul><li>三把 Key 对应的助记词备份，请分开保存</li><li>三份与 Key 对应的扩展公钥文件</li></ul><p>有了这三份扩展公钥文件，下面开始创建多签钱包。</p><h4 id="在-Sparrow-上创建多签钱包"><a href="#在-Sparrow-上创建多签钱包" class="headerlink" title="在 Sparrow 上创建多签钱包"></a>在 Sparrow 上创建多签钱包</h4><p>在计算机上打开 Sparrow，在菜单栏中依次选择 “File” &gt; “New Wallet”，然后在弹出的窗口中自定义钱包的名称，点击 “Create Wallet”：</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/sparrow-new-wallet.png" alt="sparrow-new-wallet.png"></p><p>接下来会进入 Sparrow 的主界面：</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/sparrow-1.png" alt="sparrow-1.png"></p><p>首先，在 Policy Type 中选择 Multi Signature，即表明当前创建的为多签钱包。确认您的界面和上图中第 2、3 部分一致，即脚本类型为 P2WSH（原生隔离见证地址），多签规则为 2/3，这是 Sparrow 默认的设置。</p><blockquote><p>交易中包含签名越多，手续费就越高，使用隔离见证交易可以降低手续费。</p></blockquote><p>然后在图中下方 Keystore 部分导入我们前面准备的三份扩展公钥文件。方法：依次选择 Keysotre1、2、3 选项卡，点击 “Airgapped Hardware Wallet” ，在弹出的界面中根据扩展公钥的来源选择对应的导入方式，然后导入相应的文件。</p><p>以 Keystone 为例：</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/sparrow-import-from-keystone-1.png" alt="sparrow-import-from-keystone-1.png"></p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/sparrow-import-from-keystone-2.png" alt="sparrow-import-from-keystone-2.png"></p><p>导入后界面如下：</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/import-json.png" alt="import-json.png"></p><p>依次导入三个扩展公钥后，点击右下角 “Apply”。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/apply-multi-wallet.png" alt="apply-multi-wallet.png"></p><p>Sparrow 会弹出一个窗口让您刚创建的这个钱包设置密码，该密码仅用于在计算机上解锁这个多签钱包（即在每次打开 Sparrow 进入该钱包时使用），也可选择 No Password 跳过。</p><p>接下来 Sparrow 会弹出备份窗口，提醒我们备份多签钱包。</p><p>下图中蓝色方框内这一长串字符（以 wsh 开头）便是刚创建的这个多签钱包的描述符，我们需要妥善保存。当我们想要恢复多签钱包时，除了要用到上面备份的三把私钥外，还需要加上钱包描述符一起，才能完成恢复。</p><p>点击 “Save PDF” 保存描述符（一份包含二维码和描述符的 PDF），同时可以复制蓝框内的描述符，保存一份到密码管理器中。</p><blockquote><p>对于重要文件的保存，应该遵循 “3-2-1” 原则。即：至少保存三份备份 —— 存储于两种不同的介质中 —— 至少一份存放在异地。</p></blockquote><p>然后点击右下角 “确定”。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/save-sparrow-descriptor.png" alt="save-sparrow-descriptor.png"></p><p>至此，我们的多签钱包创建完成。</p><h4 id="验证多签钱包备份"><a href="#验证多签钱包备份" class="headerlink" title="验证多签钱包备份"></a>验证多签钱包备份</h4><p>在正式使用钱包之前，我们需要检验一下是否正确备份了用于恢复钱包的描述符。</p><p>在 Sparrow 中按照新建一个钱包，依次选择 “File” &gt; “New Wallet” &gt; “Create Wallet”，流程和上文一致。</p><p>在钱包主界面点击 Descriptor 输入框右侧的 ”Edit…“ </p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/backup-test-1.png" alt="backup-test-1.png"></p><p>在弹出的窗口中，删除蓝框内原有字符串，然后将前面备份好的描述符粘贴进蓝框，最后点击 “确定”。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/backup-test-2.png" alt="backup-test-2.png"></p><p>点击确认后，Sparrow 会根据输入的描述符自动设置好钱包的各项参数。比对新钱包里各项参数和之前创建的多签钱包是否一致。（比对 Keystore1、2、3 的 Master Fingerprint、Derivation、xpub，Keystore 的先后排序可能会乱，但没有影响。）参数一致的话，证明描述符备份无误。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/backup-test-3.png" alt="backup-test-3.png"></p><p>最后，删除新建的钱包。</p><h4 id="将多签钱包导入硬件签名器："><a href="#将多签钱包导入硬件签名器：" class="headerlink" title="将多签钱包导入硬件签名器："></a>将多签钱包导入硬件签名器：</h4><p>在 Sparrow 里创建多签钱包后，我们需要将多签钱包导入硬件签名器。</p><p>在 Sparrow 中点击左下角 “Export…”，然后选择对应的导出方式：</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/sparrow-export.png" alt="sparrow-export.png"></p><p>将多签钱包导入 Keystone：</p><p>点击 “Export” 后，在弹出的窗口中选择 Keystone Multisig，点击 “Show…”</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/export-to-keystone.png" alt="export-to-keystone.png"></p><p>此时计算机屏幕上会出现一个动态二维码。打开 Keystone，点击 “多签钱包” &gt; “导入多签钱包” &gt;扫描计算机屏幕上的动态二维码。</p><p>扫描完成后，此时 Keystone 会显示正在导入的多签钱包的具体信息， 将 Keystone 屏幕上的信息和 Sparrow 的信息进行一一比对，确认无误后在 Keystone 上点击 “确认”，至此，导入完成。</p><blockquote><p>点击 “确认” 后，Keystone 屏幕上可能会出现钱包验证码，直接点击 “验证码一致，继续导入” 即可。此校验码仅用于在两台不同的 Keystone 上配置多签钱包时使用，在本文提供的方案中可以忽略。</p></blockquote><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/keystone-import-multisig.png" alt="keystone-import-multisig.png"></p><p>需要注意的是：导入过程中 Keystone 屏幕上显示的多签钱包信息中扩展公钥以 Zpub 开头，Sparrow 上默认以 Xpub 开头。为方便比对，可以在 Sparrow 里按下图所示点击右下角转换图标，切换 xpub 和 Zpub 显示。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/xpub-zpub.png" alt="xpub-zpub.png"></p><p>将多签钱包导入 Coldcard：</p><p>点击 “Export” 后，在弹出的窗口中选择 Coldcard Multisig，点击 “Export File…”，此步骤会导出一个 .txt 文件。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/export-to-coldcard.png" alt="export-to-coldcard.png"></p><p>将该文件存入 Micro SD 卡，然后将 Micro SD 卡插入 Coldcard，按下图所示步骤依次选择 Setting &gt; Multisig Wallets &gt; Import form SD &gt; 选择刚刚的文件名 &gt; 和 Sparrow 比对钱包信息是否无误 &gt;  按照 Coldcard 的提示确认导入。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/coldcard-import-multisig.jpeg" alt="coldcard-import-multisig.jpeg"></p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/coldcard-save-address.jpeg"></p><h3 id="开始交易"><a href="#开始交易" class="headerlink" title="开始交易"></a>开始交易</h3><p>完成上述所有步骤后，就可以使用比特币多签钱包了。使用前务必先用小额资金进行测试。多签钱包使用方式如下：</p><h4 id="验证收款地址"><a href="#验证收款地址" class="headerlink" title="验证收款地址"></a>验证收款地址</h4><p>在使用多签钱包接受资金之前，我们首先需要验证接收地址。为了安全地接收资金，我们应当默认联网的计算机是不安全的，即计算机上显示的地址可能是黑客给的虚假信息。因此，我们需要分别在 Keystone 和 Coldcard 上验证收款地址：</p><p>首先，查看 Sparrow 的 收款地址。</p><p>在 Sparrow 中点击左侧的 “Receive”，可以看到 Sparrow 给出的接收地址。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/verify-address.png" alt="verify-address.png"></p><p>选择左侧的 “Addresses” 可以看到更多地址。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/verify-address-all.png" alt="verify-address-all.png"></p><p>在 Keystone 上验证收款地址。</p><p>解锁 Keystone 后，点击 ”多签钱包“，即可看到接受地址（点击某个地址可以看到完整的地址信息）。可以点击左下角 “+” 号创建多个地址，和 Sparrow 上的地址进行比对。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/keystone-verify-address.jpeg" alt="keystone-verify-address.jpeg"></p><p>在 Coldcard 上验证收款地址。</p><p>解锁 Coldcard 后，依次选择 Address Explorer &gt; 按照屏幕上的指示继续 &gt; 往下滚动选择您导入的多签钱包 &gt; 往下滚动即可看到接收地址。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/coldcard-verify-address.jpeg" alt="coldcard-verify-address.jpeg"></p><blockquote><p>您还可以按照屏幕上的指示将接收地址存储到离线的 micro SD 卡中（一次可导出 250 条地址信息），这样就不用每次接收资金时都打开 coldcard 验证接收地址。毕竟两个硬件签名器在日常使用时是分开存放的，每次收款前都打开两个硬件签名器验证地址过于麻烦。但应在至少一处硬件签名器的屏幕上验证接受地址。</p></blockquote><p>至此，我们完成了接收地址的验证流程，可以使用该地址接受比特币啦。</p><h4 id="发送交易"><a href="#发送交易" class="headerlink" title="发送交易"></a>发送交易</h4><p>首先，我们需要在 Sparrow 中创建交易。</p><p>在 Sparrow 中点击左侧的 “Send”，依次填写交易信息，设置合理的手续费后，点击右下角的 “Create Transaction”。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/create-tx.png" alt="create-tx.png"></p><p>此时，Sparrow 会新建一个页面，展示交易的详细信息，验证无误后，点击 “Finalize Transaction for Signing”。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/finalize-tx.png" alt="finalize-tx.png"></p><p>至此完成了交易的创建。接下来需要将这笔待签名的交易传给 Keystone 和 Coldcard。分别在 Keystone 和 Coldcard 上完成签名，再将签名好的交易传回 Sparrow。</p><p>使用 Keystone 签名交易：</p><p>点击下图中的 “Show QR”，此时计算机屏幕上会出现一个动态二维码，这个二维码展示的就是待签名的交易信息。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/show-qr-to-keystone.png" alt="show-qr-to-keystone.png"></p><p>解锁 Keystone，选择 ”多签钱包“，按照下图所示点击右上方扫描图标，出现扫码界面。扫描计算机屏幕上的二维码，完成后 Keystone 屏幕上会出现交易确认界面。确认交易信息无误后点击 ”签名“，验证密码后，Keystone 的屏幕上会出现一个动态二维码，这个二维码展示的就是已完成部分签名的交易信息。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/keystone-sign-tx.png" alt="keystone-sign-tx.png"></p><p>在 Sparrow 中点击 “Scan QR”，Sparrow 会调用计算机的摄像头，扫描 Keystone 屏幕上的二维码，将 Keystone 上已经签名好的交易传给 Sparrow。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/scan-qr-from-keystone.png" alt="scan-qr-from-keystone.png"></p><p>使用 Coldcard 签名交易：</p><p>在 Sparrow 中点击 “Save Transaction”，此时 Sparrow 会生成一个 “xxxx.psbt” 的文件（xxxx 为创建交易时自定义的 “Label” 字段），将该文件存至 Micro SD 卡，插入 Coldcard。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/save-tx-to-coldcard.png" alt="save-tx-to-coldcard.png"></p><p>解锁 Coldcard，选择 “Ready to Sign”，屏幕上会展示 Micro SD 卡内这笔交易的详情，上下滚动确认无误后，按屏幕提示选择确认，Coldcard 会完成签名，生成一个新的 PSBT 文件。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/coldcard-sign-tx.jpeg" alt="coldcard-sign-tx.jpeg"></p><p>从 Coldcard 中拔出 Micro SD 卡，插入计算机。在 Sparrow 中点击 “Load Transaction”，选择刚刚签名好的文件（以 xxxx-part.psbt 格式命名）。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/load-tx-form-coldcard.png" alt="load-tx-form-coldcard.png"></p><p>最后，点击 “Broadcast Transaction” 即可广播交易。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/sparrow-boardcast-tx.png" alt="sparrow-boardcast-tx.png"></p><p>至此，我们已经走完了发送交易所需的所有步骤。</p><h3 id="从测试网开始！"><a href="#从测试网开始！" class="headerlink" title="从测试网开始！"></a>从测试网开始！</h3><p>对于初次尝试比特币多签的读者，强烈建议您先使用测试网走一遍完整的流程。熟悉各项操作后，再创建自己的多签钱包，以免操作失误造成资金损失。以下为使用比特币测试网（Testnet）进行演练的方法。</p><h4 id="各钱包打开测试网模式的方法："><a href="#各钱包打开测试网模式的方法：" class="headerlink" title="各钱包打开测试网模式的方法："></a>各钱包打开测试网模式的方法：</h4><p>Sparrow<br>菜单中找到 “Tools”，选择 “Restart in Testnet”，Sparrow 会重新打开，进入测试网模式。</p><p>Coldcard</p><p>解锁 Coldcard，依次选择 Advanced &gt; Danger Zone &gt; Testnet Mode &gt; Testnet: BTC。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/coldcard-testnet-mode.jpeg" alt="coldcard-testnet-mode.jpeg"></p><p>Keystone</p><p>打开设置 &gt; 区块链网络 &gt; 测试网 ，此时界面顶部会变成黄色。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/keystone-testnet.png" alt="keystone-testnet.png"></p><p>以下网站均可领取测试网比特币：</p><ul><li><a href="https://bitcoinfaucet.uo1.net/">https://bitcoinfaucet.uo1.net/</a></li><li><a href="https://onchain.io/bitcoin-testnet-faucet">https://onchain.io/bitcoin-testnet-faucet</a></li><li><a href="https://testnet.qc.to/">https://testnet.qc.to</a></li><li><a href="https://tbtc.bitaps.com/">https://tbtc.bitaps.com</a></li><li><a href="https://testnet.help/en/btcfaucet/testnet">https://testnet.help/en/btcfaucet/testnet</a></li></ul><blockquote><p>测试网比特币并无实际价值，请使用完后发回水龙头，供其他人继续使用。</p></blockquote><h3 id="紧急恢复"><a href="#紧急恢复" class="headerlink" title="紧急恢复"></a>紧急恢复</h3><p>当在使用多签钱包的过程中遇到以下情况时，需要对多签钱包进行恢复操作。</p><h4 id="助记词没有出现安全问题的情况"><a href="#助记词没有出现安全问题的情况" class="headerlink" title="助记词没有出现安全问题的情况"></a>助记词没有出现安全问题的情况</h4><p>硬件签名器故障：比如硬件签名器遭到物理损坏或出现硬件/软件上的故障，无法正常使用。</p><p>解决方式：买一个新的同款的硬件签名器，导入原来的助记词。然后按照上文的步骤将多签钱包导入新的硬件签名器，即可使用新钱包来进行签名。如果买不到同款钱包，则按照上文的硬件签名器选择标准购买其它款的硬件签名器。</p><h4 id="助记词出现了安全问题的情况"><a href="#助记词出现了安全问题的情况" class="headerlink" title="助记词出现了安全问题的情况"></a>助记词出现了安全问题的情况</h4><p>此情况包括如下几种情形：</p><ol><li>助记词备份破损，无法恢复</li><li>助记词备份丢失，无法找回</li><li>助记词被盗，或已经被他人看过（在线存储过的助记词应默认已被他人看过）</li><li>硬件签名器被曝出存在安全问题</li><li>硬件签名器丢失或被盗</li></ol><p>当遇到以上情况时，应当视为助记词已出现/即将出现安全问题。我们需要立刻执行紧急恢复。如果是硬件签名器存在安全问题导致的助记词安全隐患，还需在紧急恢复的过程中替换掉有问题的硬件签名器。</p><p>紧急恢复流程如下：</p><ol><li>创建一把新的私钥，替换原来三把私钥中出现安全问题的那把私钥</li><li>使用新的私钥和原有的两把安全的私钥按照上文的流程创建新的多签钱包</li><li>将原多签钱包内的资金转至新的多签钱包</li></ol><p>下图使用 Key3 代表出现安全问题的私钥，注意和前文中的恢复私钥区分。</p><p><img src="/../images/a-guide-for-bitcoin-multi-sig-wallets-by-mi-zeng/recovery-multisig.png" alt="recovery-multisig.png"></p><blockquote><p>在创建新的多签钱包时，由于使用的三把私钥中有两把与原多签钱包相同，因此在花费资金时会暴露出新钱包和原多签钱包的关联性。如果您追求更高级别的隐私，则应该使用三把全新的私钥来创建新的多签钱包。具体方法：</p><ol><li>将原多签钱包的资金转移进安全的单签钱包</li><li>使用三把全新的私钥按照上文给出的流程创建新的多签钱包</li><li>将资金从单签钱包转入新的多签钱包</li></ol></blockquote><h4 id="额外的安全措施（可选）："><a href="#额外的安全措施（可选）：" class="headerlink" title="额外的安全措施（可选）："></a>额外的安全措施（可选）：</h4><p>为了能够第一时间发现安全问题，可以在每个私钥对应的单签钱包内放入少量资金，并将对应的地址添加到观察钱包。这样一旦三把私钥中某一把私钥被盗（可能是助记词被盗，也可能是存放该私钥的硬件签名器出了安全问题），就能及时发现，然后迅速转移多签钱包内的资金。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>感谢您能读到这里。</p><p>我们常说 “复杂性是安全的敌人”。相较于单签钱包而言，多签钱包对使用者提出了更高的要求，比如更麻烦的使用流程，更多的备份管理工作，更高的成本 ······</p><p>实际上，想要实现完美无缺的单签钱包比多签钱包更为困难，而后者要比起前者要安全得多。其实，多签钱包烦琐的设置主要集中在创建钱包这一过程，只要理解了它的基本原理，就可以消除对于其复杂性的恐惧。</p><p>复杂性不一定是安全的敌人，但怕麻烦一定是。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>感谢 <a href="https://twitter.com/AurtrianAjian">@Ajian</a> 对本文提出的改进建议，感谢 <a href="https://twitter.com/BitcoinLixin">@Lixin Liu</a> 解答了我关于多签的诸多疑惑。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol><li><a href="https://www.btcstudy.org/2021/10/18/what-is-multi-signature-wallet-and-recommend-choices/">什么是多签钱包？</a></li><li><a href="https://www.btcstudy.org/2020/09/04/understand-bitcoin-public-and-private-keys-encode-and-extend/">比特币的私钥：转码与使用</a></li><li><a href="https://www.btcstudy.org/2022/09/29/how-does-a-bitcoin-transaction-actually-work/">比特币交易工作原理简介</a></li><li><a href="https://www.btcstudy.org/2022/07/27/21-ways-lose-bitcoin/#19-%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E5%A4%9A%E7%AD%BE%E4%BA%BA%E6%95%B0%E9%98%88%E5%80%BC">囤币路上的 21 个坑</a></li><li><a href="https://www.btcstudy.org/2021/10/07/multisig-and-split-backups-two-ways-to-make-your-bitcoin-more-secure/">多签和拆分备份：让您的比特币更安全</a></li><li><a href="https://www.btcstudy.org/2022/05/07/how-to-back-up-a-seed-phrase/">助记词备份指南</a></li><li><a href="https://mirror.xyz/keystonecn.eth/fhdm_LSTt3SEg5DkV0M8_b4Ix5kC5E4bhwcFLQx9iUc">深冷存储：如何更安全保管您的助记词</a></li><li><a href="https://www.btcstudy.org/2022/05/11/bitcoin-multisig-2-of-3-vs-3-of-5/">2-of-3 vs. 3-of-5：更多密钥一定更安全吗？</a></li><li><a href="https://mirror.xyz/keystonecn.eth/jngKwNznJARo5PdAlYxzuibDT9DWyvDkkSMpgjsBwQM">Keystone 為什麼要增加分片助記詞功能</a></li><li>利用 Specter 实现比特币多签<a href="https://btcguide.github.io/">教程1</a>、<a href="https://bitcoiner.guide/multisig/">教程2</a></li><li>利用 Electrum 实现比特币多签<a href="https://armantheparman.com/msig/">教程1</a>、<a href="https://support.keyst.one/v/traditional-chinese/di-san-fang-qian-bao/bi-te-bi-qian-bao/electrum/electrum-23-psbt-duo-qian-jiao-cheng">教程2</a></li><li>利用 Nunchuk 实现比特币多签<a href="https://www.youtube.com/watch?v=yWLzkaxI7og">教程</a></li><li><a href="https://btcguide.github.io/known-issues/multisig">多签钱包的已知问题</a></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://btcguide.github.io/">10x Security Bitcoin Guide</a></li><li><a href="https://bitcoiner.guide/multisig/">Bitcoin Multisig Guide</a></li><li><a href="https://walletsrecovery.org/">https://walletsrecovery.org</a></li><li><a href="https://www.btcstudy.org/2022/08/20/overview-of-soft-wallets-and-hard-wallets-signers/">软硬钱包概说</a></li><li><a href="https://unchained.com/blog/what-is-a-multisig-wallet-configuration-file/">What is a multisig wallet configuration file and what is it for?</a></li><li><a href="https://www.btcstudy.org/2022/08/15/what-are-partially-signed-bitcoin-transactions-psbts/">什么是 “部分签名的比特币交易（PSBT）”？</a></li><li><a href="https://www.btcstudy.org/2022/05/10/what-are-output-descriptors/">什么是输出描述符？</a></li><li><a href="https://unchained.com/blog/replace-key-multisig-wallet/">When do I need to replace a key for my bitcoin multisig wallet?</a></li><li><a href="https://blog.thebitcoinhole.com/best-hardware-wallets-31141ed1aa05">Best Hardware Wallets in 2022</a></li></ol><p>（完）</p>]]></content>
    
    
    <summary type="html">本文旨在提供一份详细的比特币多签钱包实践指南</summary>
    
    
    
    
    <category term="钱包" scheme="https://www.btcstudy.org/tags/%E9%92%B1%E5%8C%85/"/>
    
    <category term="实践" scheme="https://www.btcstudy.org/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>BOLT 12 是沉睡的巨人：隐私篇</title>
    <link href="https://www.btcstudy.org/2022/12/08/bolt-12-will-it-ever-be-as-private-as-cash/"/>
    <id>https://www.btcstudy.org/2022/12/08/bolt-12-will-it-ever-be-as-private-as-cash/</id>
    <published>2022-12-08T04:22:54.000Z</published>
    <updated>2023-01-12T06:01:27.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：LN Capital</em></p><p><em>来源：<a href="https://twitter.com/ln_capital/status/1594408238539218956">https://twitter.com/ln_capital/status/1594408238539218956</a></em></p></blockquote><p>闪电网络将统治世界。但是，它能够提供媲美现金的隐私性吗？让我们从隐私性的角度来看 BOLT 12 这个沉睡的巨人。</p><p>为防你还不知道 BOLT 12 是什么，我来简单介绍一下。BOLT 是 “Basis of Lightning Technology（闪电网络技术基础）”的缩写。BOLT 就像是针对闪电网络提出的 BIP。BOLT 12 可以通过 <a href="https://twitter.com/Blockstream">@blockstream</a> 的 <a href="https://twitter.com/Core_LN">@core_LN</a> 获取，<a href="https://twitter.com/acinq">@acinq</a> 和 <a href="https://twitter.com/lightningdevkit">@lightningdevkit</a> 两个团队也正在实现。</p><p>如果你还没有看过 BOLT 12 的第一篇，可以点击该链接：<a href="https://twitter.com/LN_Capital/status/1589321548133203968">https://twitter.com/LN_Capital/status/1589321548133203968</a> （<a href="https://www.btcstudy.org/2022/11/13/bolt-12-is-a-sleeping-giant/">中文译本</a>）</p><h2 id="当前的闪电网络规范（BOLT-11）存在哪些隐私问题？"><a href="#当前的闪电网络规范（BOLT-11）存在哪些隐私问题？" class="headerlink" title="当前的闪电网络规范（BOLT 11）存在哪些隐私问题？"></a>当前的闪电网络规范（BOLT 11）存在哪些隐私问题？</h2><ol><li>任何公开发布的 BOLT 11 发票都可以被解码。解码后的发票包含关于接收方的敏感信息，包括：<ul><li>公钥和节点别名</li><li>IP 地址和位置（仅限于非洋葱网络）</li><li>公开通道的容量和节点余额</li></ul></li><li>在 BOLT 11 上退款并不私密。退款接收方必须泄露私人信息才能接收退款。这导致了不可接受的折中。用 <a href="https://twitter.com/rusty_twit">@rusty_twit</a> 的话来说，“你是想要拿回自己的钱还是保持匿名？”</li><li>支付通道导致链上 UTXO 曝光。在闪电网络上开启支付通道需要完成一笔 2/2 多签交易。目前，闪电网络支付通道开启交易看起来与普通比特币交易不同。这会将你的链上交易历史与闪电网络关联起来，让你容易遭受去匿名化攻击。</li></ol><p>（译者注：人们之所以能发现一个 UTXO 跟某条闪电通道之间的关联，有多方面的原因。详见这篇文章：《<a href="https://www.btcstudy.org/2022/09/29/lightning-privacy-from-zero-to-hero/">闪电网络隐私性：从局限到超越</a>》）</p><h2 id="BOLT-12-是如何解决这些隐私性问题的？"><a href="#BOLT-12-是如何解决这些隐私性问题的？" class="headerlink" title="BOLT 12 是如何解决这些隐私性问题的？"></a>BOLT 12 是如何解决这些隐私性问题的？</h2><p>主要通过三种方式：盲路径、付款方证明、Schnorr 签名</p><h3 id="盲路径"><a href="#盲路径" class="headerlink" title="盲路径"></a>盲路径</h3><p>盲路径可以让用户在不知道接收方的情况下通过网络发送代币。盲路径交易的最后几跳是加密的，因此只有前一跳才知道下一跳的目的地。</p><p>发送方只知道交易是否到达了目的地，不知道目的地和付款路线。对于闪电网络用户而言，这极大地提高了隐私性，因为用户无需为了收款而泄露自己的敏感信息。</p><p>你可能会想，“这听起来很复杂。存在任何折中吗？”闪电网络上的盲路径不会牺牲速度。但是，它们在付款失败时返回的信息较少（保证接收方的匿名性），使得了解付款失败的原因变得更加困难。</p><p>盲路径不是解决隐私性问题的灵丹妙药。它们仍无法抵御计时攻击（timing attacks），但无疑是朝着正确的方向迈出了一步。</p><h3 id="付款方证明"><a href="#付款方证明" class="headerlink" title="付款方证明"></a>付款方证明</h3><p>每个 BOLT 12 offer 都包含一个“付款方密钥”。这个密钥可以用来证明你创建了一个发票。这使得退款变得更加容易，因为商家可以验证顾客的退款请求是否有效。</p><p>由于 BOLT 12 offer 实际上是默克尔树，你可以证明自己在<strong>没有</strong>泄露个人敏感信息的情况下完成了付款。</p><p>与盲路径结合后，BOLT 12 offer 可以保证退款的隐私性，提供比 BOLT 11 更优质的用户体验。</p><h3 id="Schnorr-签名"><a href="#Schnorr-签名" class="headerlink" title="Schnorr 签名"></a>Schnorr 签名</h3><p>BOLT 12 规范从头到尾都使用了 Taproot Schnorr 签名。这意味着在闪电网络上开启支付通道的交易（2/2 多签交易）看起来与普通的比特币交易完全相同。Schnorr 签名斩断了链上比特币和闪电网络之间的关联。</p><p>但是，Taproot 和 Schnorr 只解决了问题的一部分。（节点间的）通道开启交易不会泄露隐私，但是（节点对网络的）通道公告会。这与闪电网络的 gossip 架构的运作方式有关。Gossip 2.0 正在开发中，我之后会另写一篇文章介绍。</p><h2 id="太长不看"><a href="#太长不看" class="headerlink" title="太长不看"></a>太长不看</h2><p>BOLT 11 存在三大缺陷：在收款方隐私保护上有所欠缺，无法保证退款的隐私性，并且会将链上比特币与闪电网络相关联。</p><p>BOLT 12 利用盲路径、付款方证明和 Taproot Schnorr 签名减轻了隐私性问题。闪电网络的隐私保护仍需改进，但 BOLT 12 是个很好的开始。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">它能够提供媲美现金的隐私性吗？</summary>
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/categories/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>限制条款的概念与前景杂谈</title>
    <link href="https://www.btcstudy.org/2022/12/07/jeremy-rubin-andrew-poelstra-covenants-tabf-2021/"/>
    <id>https://www.btcstudy.org/2022/12/07/jeremy-rubin-andrew-poelstra-covenants-tabf-2021/</id>
    <published>2022-12-07T14:47:05.000Z</published>
    <updated>2023-01-12T06:04:09.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Jeremy Rubin，Andrew Poelstra</em></p><p><em>来源：<a href="https://btctranscripts.com/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/">https://btctranscripts.com/tabconf/2021/2021-11-05-jeremy-rubin-andrew-poelstra-covenants/</a></em></p><p><em>本文为 Jeremy Rubin 和 Andrew Poelstra 在 TABConf 2021 上的演讲文字稿，由 Jeremy Rubin 转写。</em></p></blockquote><p>根据 “苏格拉底村” 规则，（除了演讲者之外）所有与会者都使用了假名；音频也不会公开，以保护提问者的匿名。</p><h2 id="限制条款的概念"><a href="#限制条款的概念" class="headerlink" title="限制条款的概念"></a>限制条款的概念</h2><p>Shaun Apps（SA）：我先做个开场吧。Andrew 和 Jeremy 都会来。然后我们就以问答的形式开展，最后再回答观众的提问。这就是本场演讲的形式。</p><p>SA：言归正传，限制条款（covenant）。这个术语有宗教和法律方面的历史语境。大多数人理解的可能是物权法范畴内的概念，比如使用限制条款来约束土地的用途。但是，你们有多少人听知道它在比特币领域内的意思？好的，看来很多人都听过。所以，基本上，限制条款给予了比特币脚本内省的能力，例如你可以通过预先定义的约束来限制一个输出的花费方式。我不太清楚限制条款可以追溯到多久远以前。但是这一篇影响力很大的 BitcoinTalk <a href="https://bitcointalk.org/index.php?topic=278122.0">论坛帖子</a>，作者是 Greg Maxwell，就介绍了限制条款的概念，并提出了一些假想的案例。举个例子，一种 Smashcoin 限制条款，在花费由此种条款锁定的资金时，必须提供攻击另一种密码货币的证据；甚至是一种 adultcoin 限制条款，必须提供某人的生日才能花费，它会限制接收者的年龄必须大于 18 岁。当然，这些都只是假设的、博君一笑的例子，这篇帖子也只是一个玩笑。但是，今天我们能够看到，限制条款有一些非常激动人心的用途。有请 Andrew Poelstra 和 Jeremy Rubin。Andrew 准备从 CHECKSIGFROMSTACK（也叫 “CSFS”）的视角出发，理解限制条款。Jeremy 的演讲则讨论 CHECKTEMPLATEVERIFY（也叫 “CTV”）。其实，有不止一种办法可以在比特币中实现限制条款。不同的想法、不同的提议，都有自己的取舍也应用场景。所以，我们来好好探究一番。Andrew，你想先来吗？</p><p> Andrew Poelstra（AP）：当然。如 Shaun 所说，某种程  度上我代表着限制条款的 CHECKSIGFROMSTACK 流派。这种流派似乎代表着一种更普遍的视角。所以，为了帮助大家建立限制条款的概念 —— 我认为，这个概念确实肇始于那个 BitcoinTalk 帖子 …… 我不知道有什么讨论比这个更早 ……</p><p>Jeremy Rubin（JR）：那也是我所知最早的。</p><h2 id="递归和非递归的限制条款"><a href="#递归和非递归的限制条款" class="headerlink" title="递归和非递归的限制条款"></a>递归和非递归的限制条款</h2><p>AP：有两种类型的限制条款，我把它们叫做 “递归型限制条款” 和 “非递归型限制条款”。我想这两个术语可能也源自那篇文章。“限制条款” 是且只是一种限制资金可以花到哪里去的办法。使用比特币脚本，你可以决定在什么条件下一笔资金可以移动，然而，一旦条件满足，资金就可以去任何地方。而限制条款则更进一步，允许你限制它的去向，实现上面说的种种傻事。</p><p>非递归的限制条款和递归的限制条款有一个区别。在非递归的限制条款中，你可以限制一笔资金的曲线。你可以把它引到另一个限制条款中，从而进一步约束其去向，等等。但是，你必须规划出这笔资金的全部未来，你可以让它经历很多个限制条款，但你必须在一开始就把所有的限制条款写出来。递归型限制条款则不同，你可以让资金回到一个本质上与其来源相同的限制条款中；这就创造了一种有限的状态机，资金可以在不同的状态中移动。要么资金可以只待在一个地方，只是改变一些常数；要么它们可以移动到不同的状态，甚至它们可以返回原来的状态。凭借它，你可以创建一种让资金无法逃离的限制条款。甚至我的用词，“无法逃离”，也反映出其内在的危险性，同时也反映了许多年来人们对启用递归限制条款的恐惧。</p><h2 id="不同的限制条款提议"><a href="#不同的限制条款提议" class="headerlink" title="不同的限制条款提议"></a>不同的限制条款提议</h2><p>AP：这些年出现了许多的限制条款提议。其中一个是 Jeremy Rubin 的 OP_CTV，曾用名 “OP_SECURETHEBAG”。在它的整个生命中，它有过多个名称，也经历了几次迭代。OP_CTV 被有意设计成规避递归型限制条款，以避免所有这些看似是玩笑、某个层面上又不是玩笑的东西。不过，另一种非常著名的限制条款提议，是非常通用的，它基于两种新的操作码，CHECKSIGFROMSTACK 和 CAT。 还有一种更为高效的变种，它增设的操作码可以直接检查正在花费这笔资金的交易。也就是说你可以直接把花费资金的交易本身拉取到堆栈中，然后执行你的脚本、直接地约束它们。一定程度上，你是在直接检查花费资金的交易、为之施加任意的约束。尤其是，如果你限制了交易的输出，那你就实现了一种递归型限制条款，可以永久困住这笔资金。这两种方法之间存在取舍。如果你尝试做一些事情来避免递归型限制条款 ……</p><p>比特币的限制条款有一段挣扎的历史，令人惊讶的是比特币中实际上不存在任何限制条款。脚本的本性意味着它必须检查交易。而比特币脚本的 CHECKSIG（检查签名）操作码让你可以检查交易的一个签名。脚本必须能够获得签名数据，这样 CHECKSIG 操作码才能访问签名。但从数学上来说，数字签名工作的方式内在地跟交易数据本身有关。使用一些聪明的数学技巧，你可以迫使一笔签名 “往回走”、获得交易的一个哈希值并推入堆栈，然后开始分析它。事实上，你可以使用比特币的 CHECKSIG 操作来表示 “这笔资金只有在你提供的签名全都是 0 的时候才能花费”；这是一个有效的签名，其中有一些元数据，但本质上就是特定位置有一些 1 和 2 的全部为 0 的数据；脚本中不包含公钥。也就是说，正常情况下，你的脚本的意思是：“我需要这个公钥对花费它的交易的一个签名”；而在这种情况下，你是在说 “我需要拥有某一个公钥，其对花费这笔资金的交易的签名拥有这样的形式”。这样编写脚本之后，为了满足它的条件，你就必须提供一个能够让这个签名有效的公钥。而这个公钥，事实证明，在代数上是一笔交易的哈希值的奇怪混合。因此，你可以在脚本中约束花费这笔资金的交易的哈希值是什么样的，也就是你得到了一种限制条款。这种脚本无法工作的理由是，比特币中的所有 sighash 标签，除了其中一种，全部都覆盖了用来签名的公钥，所以你尝试这样做会遇到循环。但是，如果我们拥有 SIGHASH_ANYPREVOUT，一种热门的提议，那么你就可以像上面说的。靠 CHECKSIG 获得一种限制条款。</p><p>这个故事的重点不是提出一种严肃的限制条款实现，而是证明要避免实现递归型限制条款是非常困难的。所以我的立场是 —— 这不是一场辩论哈，但我的立场是，我们应该拥有一种非常通用、专门设计的方法来实现递归型限制条款，而不是尝试窄化一些东西。因为首先，如果你实现了一种窄化的限制条款提议，你就损失了一些灵活性。然后，该要经历的共识变更流程，你也一样要精力，但你只得到了更少的收益。不过，也有可能你最后会得到递归型限制条款。我打赌你会，我认为这是非常难以避免的。这就是我的部分。</p><p>JR：我认为，可能除了结论，AP  讲的大部分东西我都同意。完美的电视节目少不了戏剧，但现实生活没有那么多戏剧。我认为，Andrew 和我可能并不是比特币社区的绝对中心，但我们都认为限制条款对比特币是好事。我的观点之所以不同、我之所以开发 CHECKTEMPLATEVERIFY，都是出于工程师视角的实用主义（后面我会花点时间解释一下 CTV 的行为）。得到这种完美的元件 —— 给我们安全又有表达力的递归型限制条款 —— 是非常困难的。社区里也有人反对这种东西。所以，在 CHECKTEMPLATEVERIFY 上，我尝试的事情是不断寻找更狭窄的协议设计，让最反对限制条款的人也能接受。在一定程度上，这就是 CHECKTEMPLATEVERIFY 的目标。我们可以用来解决一些重要问题的最小方案是什么样的？我认为这就是人们会混淆的东西，我这样做不是因为我认为我们只应该实现这样的最小方案，而是因为我要的东西是比特币渐进式升级的一部分。与其一次搞得天翻地覆，也许我们应该用简单的元件引入可以实现许多有趣事物的能力。我们可以依据最小方案，先培育跟限制条款开发有关的工具链和基础设施。随着时间推移，当我们知晓了人们希望用限制条款来实现的更多应用之后，可以再实现一些充分通用的、对广泛的其他用途都有用的东西，而不至于引入漏洞，也不会为了设计对开发者基础设施、工具链、用户接口的限制条款框架性而一次性消化大量工程任务。</p><p>所以，尤其是 CHECKTEMPLATEVERIFY，它实际上非常接近于 Andrew 所谓的 “你可以使用公钥来做的复杂的事”。实际上它还要更简单一些，它做的事情仅仅让你限定你要用哪一笔交易来花费这笔资金。比如，我准备把钱打到这个地址，然后让这个地址可以给我的 100 个朋友支付，这就是一个你可以用 CHECKTEMPLATEVERIFY 来实现的东西。你在这个地址中承诺的，就是你接下来准备使用的交易。那么，什么使用你会想要我说的这种功能呢？这就是 CHECKTEMPLATEVERIFY  的主要用场之一，拥堵控制。</p><p>在开发过程中，我思考这些问题的方式是，我希望找出具体的一个用途，是 CHECKTEMPLATEVERIFY 绝对可以克服的，同时为人们需要这种（或这一小组）功能给出可靠的论述，然后设计出可以安全地满足这种需求的东西。然后再回到原点，看看还有没有别的东西可以做。但我希望确定的是 CHECKTEMPLATEVERIFY 作为一种解决方案，在产品市场上可以满足最终用户的需要。我给出的这个例子，是非常巧妙的，它将分割交易的任务从支付端转移到了接收端（from a spending side to expanding side）。举个例子，如果现在交易池很慢、网络手续费很贵，如果你想获得区块确认，你可以让你的交易只有一个输出，但你的 100 个朋友都可以完全验证，他们将随着限制条款的拆解，在未来收到支付。这对（比如说）交易所来说是非常棒的，而且这种思路可以通过利用 CHECKTEMPLATEVERIFY 可以实现的其它东西、扩展成复杂得多的形式，比如免交互地创建闪电通道。我认为，总的来说，当你开始深入思考你可以用这种非常简单的限制条款来做什么，甚至有一种我为 Sapio 编写的编译器。它可以制作基于 CHECKTEMPLATEVERIFY 的智能合约，可以用来制作所有基于限制条款的奇妙事物。这个编译器自身是通用的，对未来可能定义的限制条款也兼容。如果有人走过来说 “我发明了一种新的限制条款”，我们就有机会开发可以在未来、我们扩展出更多类型的限制条款时使用的工具链。</p><p>这就是我的观点。从现在来看，我不知道我们要多久才能实现充分通用的限制条款，Andrew 可能会说你只需要 CHECKSIGFROMSTACK，但这些限制条款的体积都非常非常大，在链上展开它们是非常昂贵的。CHECKTEMPLATEVERIFY，因为其简洁性，以及你要知道自己想把资金发送到哪里的提前编译的概念，其链上足迹是非常少的。就链上效率而言，稍微复杂一点点的限制条款都很难打败基于 CHECKTEMPLATEVERIFY 的限制条款。就像有一条河需要限制条款造的桥才能渡过，而 CHECKTEMPLATEVERIFY 做的事情就是砍倒一棵树，我把它扔到河上并表示 “现在你可以走过去了”。我感觉许多开发者会说 “不，我们想造一座华丽的桥，花点时间吧”。而我表示，“靠这个我们今天就可以过河了，也许日后我们可以用它造出更高效的东西，甚至于在未来我们可以双管齐下，等等。”</p><h2 id="哪些情况会搬起石头砸自己的脚"><a href="#哪些情况会搬起石头砸自己的脚" class="headerlink" title="哪些情况会搬起石头砸自己的脚"></a>哪些情况会搬起石头砸自己的脚</h2><p>SA：提醒一下，在我们提问的时候，观众也可以自由回答这些问题。那么，你们能不能多谈谈，在设计限制条款的时候，哪些因素会导致搬起石头砸自己的脚？哪些部分需要最仔细的考虑、哪些地方可能会出错？</p><p>JR：我认为，基本上，只要你搞错一笔交易的任何一个细节，你就完蛋了。比如，在 CHECKTEMPLATEVERIFY 中，有一种情形是你发送了错误数量的资金到一个限制条款中（其实所有类型的限制条款在这种情况下都会出错）；你制作了一个限制条款，预期它会使用 1 BTC，但你只发送了 1 BTC减 1 聪 到这个限制条款中，那么整个限制条款就没法按你预期的方式执行了。这个领域对任何开发限制条款的人都是一个大挑战。另一个大问题是 —— 我自己已经有某种程度的解决方案了，但在社区中还不是那么知名 —— 支付手续费。假定你有一个限制条款，你限制了资金只能以某一种规定得很细致的方式花费，那么你怎么支付手续费呢？如果你必须支付比自己预期更多的手续费，那么你可能会过量消耗限制条款的资金，导致它无法正确执行。所以，支付手续费也是一个非常棘手的问题。我的通用解决方案是，在这里讲可能有点离题哈，我们应该建立一种手续费支付方法，可以完全独立于交易的执行。不论你使用的是限制条款还是别的智能合约代码（比如闪电通道），直接执行你想要的交易图，另外考虑手续费支付。</p><p>AP：关于手续费问题，我绝对我们不必在细节上过度纠缠。但我认为，应该有一种应用 “子为父偿（CPFP）” 的办法，跟当前建构交易的方法没有很大差别。</p><p>但是，回到最初的问题，交易的哪一部分最危险、哪些部分相对没那么危险？不论你限制你的资金花费到哪个输出，那个输出就是最危险的部分。就像 Jeremy 说的，你可以让你的输出变成没法执行的东西。 输出的具体数值，在你建构限制条款所用的交易时可能是无法预计的。如果你的限制条款要求你构建一个太大、违反共识限制的脚本签名，这个输出也将变得无法花费。或者，你的执行步骤可能超出脚本签名的余量（balance）。也许你的限制条款 会要求你把两个数相加得出一个大于 32 位的数，等等。在一些奇怪的状态下，你的限制条款可能会让你受到惊吓：这些钱变成无法花费的了。即使你可以看到结局，限制条款也会强迫你往那个方向走。输出本身就是最危险的东西。</p><p>限制条款还可以约束交易的其余部分。比如你可以约束时间锁必须是某一个区高度。就算你搞砸了，你也必须等待网络达到这个区块高度。我猜，如果你搞砸了，你可能会让资金锁定几年乃至几十年 —— 可能没有什么安慰作用，但至少从原理上说它是可以恢复的。或者，如果你要求交易的版本号是一些奇怪的、非标准的数值，虽然这样的交易是可以被区块链接受的，但你就必须直接找到矿工，因为这样的交易是无法通过网络来传播的（尽管可以得到区块链确认）。诸如此类的东西还有你的输入的 sequence 字段，这个字段会约束交易的 “手续费替换行为”；等等。但实际上这些都是输出。当我们讨论限制条款时，我们真正在讨论的是限制输出，虽然在我看来从，这是一种更通用的限制交易的形式的做法。最终来说，无论你是要做出酷炫的应用，还是危险的影响，都必须限制输出。</p><p>JR：我补充一点我的解释：输出也包括了的交易的输入。如果你的一笔交易有两个输入，你可以让两者都约束被创建的一个输出，这会得到一些让人惊喜的结果。所以，你可以设置两个输入，两个输入都表示需要创建一个价值 1 BTC 的输出，然后一个输出就能同时满足这两个输入。因此你在两个不同的限制条款中都丢失了一半的价值。所以，两个限制条款之间可能存在某些令人惊喜的互动，这也是为什么至少在目前，我对 CHECKTEMPLATEVERIFY 的做法是尽可能缩减它的范围，这样我们就能做出一些我们知道它一定程度上可以工作的东西。更令人意外的是，随着时间的推移、我们得到全部的复杂性之后，会更难得出正确的东西。</p><h2 id="限制条款提议对-Layer-2-协议的影响"><a href="#限制条款提议对-Layer-2-协议的影响" class="headerlink" title="限制条款提议对 Layer 2 协议的影响"></a>限制条款提议对 Layer 2 协议的影响</h2><p>SA：Jeremy，你提到限制条款的用途之一是拥堵控制。你们能不能从它们会如何影响 Layer 2 解决方案（比如闪电网络）的角度讲讲这些提议？我们能从这些提议中得到什么？它们能不能优化现有的东西、如何优化？</p><p>JR：Layer 2 加上限制条款会非常精彩。当前，Layer2，额，好吧，Layer 2，管它呢。现在开发 Layer 2 会遇到很多问题。不要误会，我认为 Layer 2 是许许多多问题的良方，包括闪电网络，侧链，等等。我希望将比特币和区块链想象成 CPU，而 Layer 2 就是操作系统。那么，如果你给基础层增加了新功能，你的操作系统自然能利用这些新的工具、取得很棒的成果。</p><p>我喜欢的一个跟闪电网络有关例子是创建通道。当前这有点困难，因为双方都必须在线。如果你想用存放在 Coinbase 交易所中的钱开启一条通道，那么你必须先从 Coinbase 交易所取出资金，然后跟某人开设一条通道。如果我们能做到直接说 “Coinbase，请为我开设一条通道”、然后就离线、等待 Coinbase 给你发送一条通道呢？这里面无需对 Coinbase 的信任假设。这会给吸引流动性带来非常大的影响。</p><p>还有一种情况，是拥堵控制跟 Layer 2 有密切关系的地方。假设你想一次性创建 10000 条通道。现在，你必须消耗大量的区块空间才能做到。如果有 CHECKTEMPLATEVERIFY 或其它限制条款，你可以推迟产生链上负载，在你想要关闭通道的时候才懒洋洋地释放。如果你开启了一条通道，而且无意关闭它，你可能在一年以后才实际关闭它。这对于吸引流量有很大的影响。</p><p>还有关于退出的。在某一些侧链中，你可能要同时给大量用户支付，我知道 Stacks 在共识协议中安排了一些措施，以应对要给一定数量的用户支付、又无法让交易得到确认的情形。但结果是产生了一种共识错误。有了 CHECKTEMPLATEVERIFY，你的 Layer-2 侧链就可以无视交易池的天气。你总是可以为你的单输出交易支付很高的手续费，然后让人们慢慢取走它们。</p><p>限制条款也对 Layer 2 和个人的保管问题又很大帮助，我们可以分别讲讲。Blcokstream，是一家出色的公司了，在他们的 Liquid 联盟侧链中留下了 bug：在你将资金存入他们的 Liquid 托管服务之后，资金必须每隔几周就移动一次，以刷新时间锁。如果你有限制条款，就不需要这样移动资金了。现在，因为他们有这样的限制，Liquid 网络中需要运行一项服务，保证资金定期移动了、时间锁刷新了、错误的情形不会出现。有一次这项服务没有正确运行，Andrew 也许可以给出详细的解释，但可能这也离题了。然后时间锁的保证就被打破了。限制条款可以解决这个问题：你可以更多表达关于必须按构造发生的行动的逻辑，而不是自动化保证行动发生。</p><p>还有不同类型的存款。你可以设置让资金自动返回给存款人，而不是出错、交给另一个签名人。所以限制条款有许许多多可以帮助 Layer 2 的地方，要是能够部署，我们都会觉得很激动。</p><p>AP：这是一个非常棒的问题。说回那个 bug，问题在于资金必须每 2 周移动一次，而我们设置定时器的方式是错的。在比特币网络上你没法即时响应。创建交易之后你也没法期待它们会在下一个区块立即确认。计时器到期之后你还必须等待生成一个新区块。后来我们改变了逻辑，将移动资金的时间提早了一些。我记得我们好像提早了 300 个区块，差不多吧。但这是一个很棒的例子，说明了限制条款在哪些方面有帮助，因为它也有点特别：a）不断清扫资金有点烦人，也很昂贵；b）当你在处理签名和时间锁时，希望矿工能及时接受你的交易，是非常令人挫败的体验。你没办法保证它会工作，而且它导致了这样令人尴尬的 bug，然后就被 Telegram 上的人注意到了。</p><p>在 Jeremy 前面说的东西 —— 理论上你可以让资金原地不动，等待 Coinbase 为你开启一条支付通道 —— 的基础上，你可以将它通用化。在许多情况下，你都不必在乎是不是 Coinbase，你可以说，“任何人，只要有足够多的通道容量、可以连接到我的支付目标，都可以拿走这些钱并开启一条支付通道”。你可以将大量操作都外包出去，而在常规情况下你必须跟通过身份验证的对等节点在线交互。你可以形式化表达你对时间段的需求、把一些代码丢在区块链上，然后等待一些人捡起它。</p><p>感谢你给出了这么漂亮的回答。我本来以为限制条款跟 Layer 2 没什么关系，主要跟 “保险柜（vault）” 和保管方案有关。但你讲出了一些我通常不会想到的，很棒的应用。</p><p>SA：你们想回答观众的问题吗？</p><h2 id="保险柜应用"><a href="#保险柜应用" class="headerlink" title="保险柜应用"></a>保险柜应用</h2><p>Q：我想听听你们对保险柜应用的看法。</p><p>AP：我的想法吗？坦率地说，我认为保险柜对比特币的大规模采用是必要的。那么，保险柜是什么呢，它们是一种限制条款构造，你可以约束资金的流向，使它们除了去往某个特定的目的地，哪儿也去不了。资金就呆在这种限制条款脚本中，如果你想移动它们，你必须创建一笔定义了目的地的交易，然后将资金移动到一个暂存区域，然后在三天（或者限制条款逻辑规定的别的条件满足）后，资金就可以移动到目的地。在三天的等待期中，任何拥有特定私钥的人都可以重设定时器，或者可以改变目的地，而且改变目的地时必定重设定时器。这背后的想法是，如果你的私钥脱离了你的控制，盗走你的私钥的人无法拿走你的比特币。他们可以尝试并移动资金到这个为期三天的定时器中。你可以不断重设这个定时器，然后你们两个会有一场手续费竞争。如果攻击者的目标是阻止你拿回资金，那么他们可以做到，只是要不间断地在线、花钱来维持攻击。但无法拿走资金，应该就能阻遏这种昂贵的攻击，私钥也就没那么敏感了。</p><p>关于保险柜，虽然你控制着你的私钥，你可能还想要限制资金取走的速度。也许这些私钥受到外部的法律的限制，也许因为输出中的钱属于公司，你的董事不允许你一次性花太多的钱。又或者，你安排了一些严密保管的冷私钥。热私钥可能被盗，因此你希望这些热私钥只能一点一点地拿走资金。你可以使用相同的金库构造，指定资金只能在一段时间后移动并且只能移动特定的数量。</p><p>在当前的比特币中，如果你授权的资金的移动，那么移动任意数量到任意目的地都可以，它是完全二元化的，要么什么也拿不走，要么全部都可以拿走，对于尝试保管比特币的个人用户，这真的很吓人。如果有人要从事道富银行（State Street）这样的业务，或者保管大量的比特币，那真的很吓人。</p><p>我认为保险柜是比特币被广泛采用的必要条件，希望我们能做到这一点。</p><p>JR：我也喜欢保险柜，CHECKTEMPLATEVERIFY 可以做出稍有区别的变种，但也是很有意义的。我认为我制作的保险柜有 一种最重要的属性，就是它有故障应对机制，它可以说是一种 “不冷不热” 的钱包。热钱包的意思是你可以随时随地花费，而冷钱包要设计得难以动用。比如说，你去了三个不同的沙漠，然后把刻有你的种子词的金属板埋在沙子底下，需要获得其中两个才能恢复你的多签名钱包。或者你可以埋在混凝土底下，对抗核辐射什么的，这个我们改天再说。完成了这些困难的操作之后，有一天，你说，“我要把钱取出来！我要把钱从这个 2-of-3 多签名钱包取出来”，这你是做不到的。需要安排一种紧急取款流程。你可以模拟你的备份流程，因为你每次访问它都会泄露熵。每一次你动用紧急取款，一些人就能意识到“Andrew 又在整理他的资金了”。另一方面，做起来越困难，你就越是不想经常做。沙漠可能会换成你的书桌的三个抽屉，降级了，但这样你才愿意为之付出一次性的成本。你可能会想：“随便吧，等我去一个新城市时，我再带上 GPS，把种子词埋在某个地方”。而有了这种不冷不热的钱包，你可以把你的资金设置成年金。假设里面有 10 BTC，在上一次取款的一个月后，你可以取出 1 BTC。这样就可以从保险柜中取出流动资金。但是，如果你被攻击了，你也可以将它们紧急发送到深冷存储中。它所做的是将你对备份的两种担心 —— “我希望我的资金是安全的” 和 “可以花费但我也想要在紧急的时候恢复它们” —— 分离开来。很好地分切两者之后，我认为，会有多得多的用户接受这种更安全的冷存储备份。</p><h2 id="重新启用-OP-CAT-的提议"><a href="#重新启用-OP-CAT-的提议" class="headerlink" title="重新启用 OP_CAT 的提议"></a>重新启用 OP_CAT 的提议</h2><p>SA：一部分围绕限制条款的讨论是重新引入一个被中本聪在 2010 年禁用的操作码，叫做 “OP_CAT”。你们能不能讲讲这会对限制条款的提议有什么样的影响？我们从种可以得到什么？它在限制条款中有什么作用？</p><p>AP：OP_CAT 是我最喜欢的操作码。CAT 是 “拼接（concatenate）” 的缩写。OP_CAT 的功能就是把你的脚本解释器环境堆栈中的两个对象拼接在一起。现在你有了一个元素，是两个对象前后相接而形成的。在比特币中，执行就是验证，所以你也可以反过来运行。如果你有一个很大的数据，那么你可以要求用户在花费时提供两半数据，然后你再 CAT 它们，检查是否相等。你总是可以这样逆转每一个操作。</p><p>就 CAT 自身，你可以用来打碎所签名。从代数上来说，不论 ECDSA 签名还是 Schnorr 签名，都有两个不同的部分，一个是数字的部分，我们通常称为 <code>s</code> ，另一部分是一个公钥，我们通常称为 <code>R</code>。 如果没有 OP_CAT，如果你尝试实现一些有趣的限制条款技巧，比如通过发现代数上的后门来把限制条款藏进协议中，那是很难做到的，因为你无法分割签名，因此无法将  <code>s</code> 跟  <code>R</code> 分割开来、专门限制某一样。   <code>s</code> 和 <code>R</code> 是完全不同的两种东西，而且 <code>R</code> 更难限制。</p><p>在 Taproot 中，我们已经有 Schnorr 签名了；事实证明，使用 OP_CAT 和 Schnorr 签名验证操作码，   你就可以做出一种形式的非递归型限制条款，你可以确确实实得到一条交易的哈希值。你得到的甚至不是什么有趣的、扭曲了的交易哈希值，而就是堆栈中的交易数据的 SHA2 哈希值。我不想涉及太多代数，但这真的非常酷，所以我要说清楚一些。Schnorr 签名的生成方式是： <code>s</code> 等于  <code>k</code> 加一个哈希值乘以  <code>x</code>，这里的  <code>k</code> 是一次性私钥，而  <code>x</code> 是你的真实私钥。使用限制条款和 CAT，你可以约束 <code>k</code> 等于  <code>1</code>，而且  <code>x</code> 也等于 <code>1</code>，这样一来，等式就化约成了 <code>s = e + 1</code>。在比特币中，你没法真的对大数字作几何运算，但使用 CAT，你可以把大数字打碎成小数字。你要做的事情就是取得签名、约束它，使你的  <code>s</code> 值必须等于你的交易的哈希值加 <code>1</code>，你可以使用 CAT 拉取 <code>s</code> 值的最低几个字节，然后使用普通的操作码从中减去 1，然后使用 CAT 把结果再放回去。这样，你就得到了所有交易数据的 SHA2 值。然后，你要求用户将显式的交易数据放到堆栈中，然后使用 SHA2 操作符来压缩它、检查它跟你从签名中抽取的部分是否相等。现在，你再使用 OP_CAT 来打散刚刚被你哈希的交易的组成部分，然后你就能约束它们了。这就是限制条款，你所需的只是 CAT。</p><p>JR：不知道这样说能不能让你们好受一点 —— 我只听懂了一半。你得读<a href="https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298">这篇博客</a>才能真的理解。我会这样讲解 CAT：它有点像一个骨瘦如柴、只有 80 磅的孩子，因为每次都能投中三分球而被首选为篮球运动员。你肯定会问：“你这运动天赋是怎么来的” CAT 也可以让比特币神奇地变成量子安全的，因为你可以加入 Lamport 签名。你知道这个吗？</p><p>AP：我忘了这回事。</p><p>JR：有很多这样没有关联的事。如果我们有 CAT，我们也可以得到一个 CHECKSIGFROMSATCK 的变种。很多很多。我认为这也是 Andrew 签名的观点的一个很好的例子，也许我们会在未来意外地得到递归型限制条款，因为 CAT 这样不起眼的东西也能给比特币带来可怕的复杂性。力量都来自最让人意外的地方。</p><p>Q：你怎么使用 CAT 来分割数据呢？</p><p>JR：你把它转变成一种验证操作码，验证你传入见证数据的两个东西正是某个东西的碎片。</p><p>Q：可以处理签名数据这么大的东西？</p><p>JR：是的，在理论上是可以做到的。而且有一些代码技巧可以使之缩小。</p><p>Q：为什么当初中本聪要禁用 CAT？</p><p>AP：最初的 CAT 实现有一个内存膨胀问题，它并没有约束输出的大小。你可以把 0 字节或者别的什么东西推进去，然后使用 OP_DUP 来复制它，再使用 CAT 把它们拼再一起。只要重复使用 DUP 和 CAT，很快数据量就能长到天上去。这就是它被禁用的原因。如果当时只破坏了 OP_CAT，而且只有这个问题的话，我想我们可能已经正确地修复了它。只需要一次软分叉，表示从此开始不允许 CAT 太大的数据，就没问题了。但是，这是一个更大的、审计所有操作码的项目的一部分。有许多的操作码都被禁用了，而且各自都有一些表明需要重新评估的小问题。中本聪当时决定单方面全部禁用它们。我认为那时候还没有人真正思考过软分叉和硬分叉的区别，以及加入东西和移除东西在难度上的不对称。当时使用的语言是我们可以现在禁用它们，未来再重新启用。但实际上它们直接就被移除了。代码库里只剩下了名字。这就是 CAT 被禁用的原因，它会导致内存膨胀。</p><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><p>Q：你能直观地告诉我计算这些程序的代码运行在哪儿吗？</p><p>JR：这取决于你使用的限制条款提议。对于通用的限制条款，代码基本上都运行在脚本内部。然后这个脚本路径的创造者也要遵循一些逻辑，比如如何创建满足脚本的数据、如何生成满足这些要求的见证数据和交易。这些代码可能比放在脚本中的验证代码更为复杂。尤其是 CHECKTEMPLATEVERIFY，它是一个极端例子，脚本里面只有交易的哈希值。所有的逻辑 —— 怎么处理交易、怎么广播交易，以及其它你可能会做的事 —— 都要作为一个单独的东西，由你自己维护。</p><p>Q：非常简单，在你可以看到一个多签名脚本的地方，常常会有一种等价的脚本，它有各种更高级的约束。</p><p>Q：但是，如何触发一笔新交易呢？</p><p>JR：推动它前进的所有东西都必须是用户创建的。没有自我执行这回事。比特币中没有代码表示 “根据共识，这笔交易必须在某个时间触发另一笔交易”。</p><p>Q：我猜递归型限制条款会更加复杂。问题是，相同的脚本，跟什么一起转移呢？</p><p>AP：没错，确实如此，必须由用户来采取行动、移动资金，但基本上，他们可以做的唯一操作就是移动资金到原始脚本的另一份拷贝中。所以限制条款会限制的你的行动，但必须有人才能发起积极操作。</p><p>Q：可以有多种脚本能满足同一个限制条款吗？</p><p>AP：简单的回答是，有。限制条款不必非得限制得很死。你可以表示一笔资金可以移动到任意数量的具体脚本中。你可以表示资金可以转移到任意脚本中，只要那个脚本以某些具体的条件开头，后面是什么条件则全无限制。都取决于具体的限制条款构造，但理论上，你在这里有完全的计算自由。</p><p>Q：在应用层，我知道关于 “coin pool” 这种概念的研究。假设我有一笔资金，我可以把它扔进一个跟其他 100 个人形成的免信任托管合约种。 随着人们花费资金，这个 UTXO 会逐块逐块地变化。也许有人会运行潜水艇互换服务器，在闪电网络上把钱接回来。有点像 Green Wallet 正在使用的架构，不带限制条款。缺点之一是其交易的图谱可能会剧烈膨胀？我想听听你对这方面的进展的看法。</p><p>JR：当然，coin pool 是可以实现的。最近出现了一些别的限制条款操作码。一种叫做 “TLUV（TapleafUpdateVerify）”。我认为 coin pool 是一个非常棒的机会。一定程度上它需要一个声誉层，我认为闪电网络也有相同的忧虑。你肯定不想进入一个人们的手机经常离线的 coin pool 中。你需要确信无论什么时候你要求一笔交易，而且你的交易满足更高阶的业务逻辑 “这个人正在请求发送资金，这是 TA 的余额的一部分”，你都可以默认签名交易。你希望得到参与者的活性保证。但这样会让交易图保持较小规模，因为人们需要共享 UTXO。不同的提议有不同的取舍。我认为，人们应该忽略掉交易的数量，只从字节的数量来考虑，因为有时候人们会认为 “这样做只需使用更少的交易”，我认为这就是人们的 TLUV 的感觉，类似于 “这种提议只有 N 笔交易需要存储，而 CTV 将需要 1.2N 笔，所以 CTV 更糟一些”。但如果你计算字节数，CTV 的体积小 6 倍。所以，对于某些事情，如果你统计交易的数量 vs 字节数，小体积交易 vs 大体积但数量更少的交易，你会感到惊讶。</p><p>Q：活性需求需要 coin pool 的每个人都在线吗？还是说可以实现一种阈值，只需一些人在线？</p><p>JR：看你想要什么样的保证。想象你有一个 coin pool，每个人在其中都有一个死党，然后你说，“我相信我的死党和其他人会保持诚实。”然后你就可以做一个一半人参与的门限机制【注：例如， <code>AND(OR(Key(A),Key(B)), OR(Key(C),Key(D)), OR(Key(E), Key(F))</code> ，任意 N/2 的组合】。这样你可以做一些更复杂的事情了，但他们也就能偷盗你的资金了。在 CTV 的世界里，我思考它的方式是，只要你遇到了一个故障，你就希望这个池子分成两半。所以，当你的池子遇到了一个活性故障，你就分割它；然后，如果又有一个人离线，那么一半的池子会恢复在线，但另一半就必须再次分割。你可以自己算一下，使用两笔交易，你就让 75% 的池子恢复了在线。发起另一笔交易你就可以让人们很快回到线上。唯一一个不走运的人是那个在交易树上跟离线者靠得特别近的人，TA 必须发起 O(log(N)) 笔交易才能退出，但这也不坏。因为 O(log(N)) 非常小。</p><p>Q：交代一下背景，我问这个问题的原因是，现在我们都看到了，闪电网络已经大大扩展了，许多用户共用一个节点，但许多用户在链上都没有公钥。多名用户共用一条通道，这并不理想，而且没有人会感到高兴。但 Green Wallet 做的一个有趣的事情是，他们让多个用户都在链上拥有公钥，但依然使用同一个节点，这个节点只做从链上到链下的潜水艇互换。拓展这个模型、使之能容纳许多用户，而且不要求【语音不可分辨】在池子内部实现分布式，是非常有意思的概念。</p><p>JR：在闪电网络语境下考虑这个问题时，我想补充的另一件事情是，这是 CTV 对 TLUV 的一个优势：无需加入 ANYPREVOUT，一个基于 CTV 的 coin pool 就可以拥有嵌套的通道。所有这些东西，只有在你想要重新平衡流动性，或者发起对外支付时，才需要做一次更新。不然的会，你可以在你的交易树的叶子节点中实现所有东西，就像闪电支付一样。我认为，这是一个非常强大的元件组合，你可以跟许多人创建通道，而且只需要偶尔更新。</p><p>SA：最后一个问题。</p><p>Q：这是给 Andrew 的问题。你觉得 CTV 的主要缺点是它让我们必须审核过于狭窄的东西，还是说你真的看到了一些有问题的故障模式？</p><p>AP：不是这个原因，主要就是因为在我看来它实在太过有限了。有一种稍微接近的观点是，如果我们在未来发现了一种很酷的应用，需要更通用的限制条款来实现，但因为我们 90% 的功能都已经在 CTV 里实现了，那么就会更难通过（通用的限制条款），因为这需要大家往回走并再来一遍。同样地，也许 CTV 会跟未来某一种如无 CTV 就会得到推行的提议不兼容。或者，可能存在一些效率因素或者某种交互，是复杂得难以分析的。实际上，如果我们要给比特币增加新东西，我会倾向于得到尽可能通用的东西。我猜我们的分歧在于什么东西才是我们可以得到的最通用的东西？我认为 Jeremy 已经表示了怀疑：即使我提出了正确的东西，也无法让我的提议全部加进比特币。</p><p>JR：仅仅从社区的观点看，有一些人，比如 Shinobi 就公开表示，他不会接受任何比 CTV 更复杂的东西。我不同意这种立场，也不认为这是好的，但他有他的理由，而且社区是一位严厉的女主人。我不知道我们能否让每个人都参与进来，但我想尝试一下，甚至连 CTV，都很难让人们 “受到触动”。有一个 <a href="https://utxos.org/signals/">utxos.org/signals</a> 网站，是那些充分审核过 CTV 并认为他们可以推动社区走向合并、释放软件然后激活的人留名的地方。看起来不错，但也不是一蹴而就的事，需要持续多年的努力，让每个人都感觉它已经得到充分审核了，而且它已经获得了足够多的应用场景。</p><p>SA：好的，我们到这里就结束了。感谢各位！</p><p>（完）</p>]]></content>
    
    
    <summary type="html">Jeremy Rubin 和 Andrew Poelstra 在 TABConf 2021 的对话</summary>
    
    
    
    
    <category term="CTV" scheme="https://www.btcstudy.org/tags/CTV/"/>
    
    <category term="covenant" scheme="https://www.btcstudy.org/tags/covenant/"/>
    
  </entry>
  
  <entry>
    <title>口令短语（passphrase）必知必会</title>
    <link href="https://www.btcstudy.org/2022/12/06/everything-you-need-to-know-about-passphrases/"/>
    <id>https://www.btcstudy.org/2022/12/06/everything-you-need-to-know-about-passphrases/</id>
    <published>2022-12-06T01:53:53.000Z</published>
    <updated>2023-01-12T06:01:27.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Coinkite</em></p><p><em>来源：<a href="https://blog.coinkite.com/everything-you-need-to-know-about-passphrases/">https://blog.coinkite.com/everything-you-need-to-know-about-passphrases/</a></em></p></blockquote><p><img src="/../images/everything-you-need-to-know-about-passphrases/oldcard.png" alt="Everything You Need To Know About Passphrases"></p><h2 id="什么是私钥和钱包"><a href="#什么是私钥和钱包" class="headerlink" title="什么是私钥和钱包"></a>什么是私钥和钱包</h2><p>在切入主题之前，我们先简单了解一下比特币私钥标准及其发展历程。私钥是一个长达 256 位的随机数字，由椭圆曲线（<a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a>）定义。你最终会得到一串很长的数字（64 个十六进制数字）。还有别样的私钥格式，比如 WIF 和 WIF-Compressed。</p><p>为便于阅读，我们使用 Base58 编码来缩短由数字和字母组成的字符串的长度，并去掉肉眼容易混淆的字母和数字。</p><p>你可以使用上述任意一种格式来表示你的私钥。 但是，涉及到钱包时，它们各自生成和表示的公钥和地址迥然相异：</p><h3 id="非确定性（随机）钱包"><a href="#非确定性（随机）钱包" class="headerlink" title="非确定性（随机）钱包"></a>非确定性（随机）钱包</h3><p>最初，钱包会随机生成几个私钥，每个私钥各对应一个公开地址。你可以将每个地址/私钥都用上一遍，还可以根据需要生成新的私钥和地址。但是，你必须备份每个私钥，否则就有可能失去私钥所关联的比特币。因此，人们倾向于重复使用同一个地址，尽量减少使用比特币的麻烦，但是这会带来隐私问题。Bitcoin Core 虽然提供这类钱包，但是我并不推荐，因为现在有更好的选择。这类钱包也叫作 0 型非确定性钱包。</p><h3 id="确定性（种子）钱包"><a href="#确定性（种子）钱包" class="headerlink" title="确定性（种子）钱包"></a>确定性（种子）钱包</h3><p>这类钱包可以让你通过唯一的（私钥）备份派生出多个私钥，每个私钥各对应一个比特币地址。这就意味着，无论你的钱包（设备）出于什么原因无法再使用，只要你持有初始备份，就可以一举找回所有比特币。</p><h3 id="分层确定性钱包（BIP-32-BIP-44）"><a href="#分层确定性钱包（BIP-32-BIP-44）" class="headerlink" title="分层确定性钱包（BIP 32/BIP 44）"></a>分层确定性钱包（BIP 32/BIP 44）</h3><p>由 BIP <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">32</a> 和 BIP <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">44</a> 提出的分层确定性钱包同样基于单个私钥生成多个私钥，就像上面提到的确定性钱包那样。分层确定性钱包与前述确定性钱包的区别在于，由主/父私钥生成的每个私钥都可以再生成一组私钥，以此类推。说到底，就是你有一个主/父私钥， 你可以用它生成一组子私钥，再用每个子私钥生成一组孙私钥，子子孙孙无穷尽也。</p><h3 id="BIP-39"><a href="#BIP-39" class="headerlink" title="BIP 39"></a>BIP 39</h3><p>无论是上文提到的哪类钱包，我们都要跟非常长的字母和数字字符串打交道，这些字符串完全超出了人的记忆和处理能力。<a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP 39</a> 应运而生，它提出了一种解决方案，可以将长串二进制或十六进制数字转化成更便于人类阅读和传输的东西。这是最受欢迎的私钥实现，大多数读者很可能已经体验过。</p><p>现在，你的私钥被表示为一组单词，通常从 <a href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">2048 个预定义单词</a>中取 12 个（128 位熵）或 24 个（256 位熵）组成。</p><p><strong>根据 BIP 39 的定义，助记词的创建规则如下</strong>：</p><ol><li>创建一个包含 128 到 256 位的随机序列（熵）。</li><li>取这个随机序列的 SHA 256 哈希值的头几位作为校验和。</li><li>将校验和添加到这个随机序列的末端。</li><li>将这个随机序列按 11 位一组进行切分，分别在 2048 个预定义单词中找到对应。</li><li>得到表示助记词的 12 到 24 个单词。（Antonopoulos 2017, ch.4）</li></ol><h2 id="口令短语是什么？"><a href="#口令短语是什么？" class="headerlink" title="口令短语是什么？"></a>口令短语是什么？</h2><p>介绍完基本知识，现在我们可以更好地理解口令短语是什么以及它在比特币钱包中是如何运作的。</p><p>多亏 BIP 39 引入了人类可读单词来表示私钥，并且与 BIP 32 兼容。现在，我们可以使用口令短语加强对私钥的保护。</p><p>口令短语可以包含字符、单词、数字乃至空格，用于扩展我们的私钥。口令短语完全由私钥持有者决定，而非随私钥一起由钱包生成。</p><p>使用口令短语之后，你必须输入口令短语才能访问你的钱包里的比特币，因为在原有助记词上添加一个口令短语会生成一个全新的钱包。</p><p>不同于密码和 PIN，口令短语没有 “输错了” 之说。每当你输入一个不同 的口令短语，你就会得到一个新的钱包。哪怕你只改变了一个口令短语中的一个字符，比如说，将大写改为小写，或添加一个空格，你也会得到一个新的钱包。</p><p>﻿<img src="/../images/everything-you-need-to-know-about-passphrases/image-20221206095137642.png" alt="image-20221206095137642"></p><p>口令短语的用途有很多，我们将在下文探索。</p><h2 id="为什么要使用口令短语？"><a href="#为什么要使用口令短语？" class="headerlink" title="为什么要使用口令短语？"></a>为什么要使用口令短语？</h2><p>只要使用并保管得当（详见下文），你的口令短语可以帮助你更好地保护比特币。通常情况下，如果有人看见了你的助记词，就能进入你的钱包，将你的比特币转走。</p><p>如果你启用了口令短语，窃贼知道了你的助记词也没用，因为他还要再输入口令短语才能偷走你的比特币。</p><p>口令短语还有另一个妙用，就是充当威胁检测系统。你可以将一小部分比特币放入由 12 个或 24 个助记词生成的标准钱包中，同时将绝大部分比特币放入使用口令短语生成的钱包中。如果你的私钥备份泄露，你会发现标准钱包中的比特币被盗走。这时，你尚有机会创建新的钱包并备份私钥，将剩余比特币转移走。</p><p>这个威胁检测系统还可以作弃车保帅之用。如果有人试图强迫你交出自己的比特币，你只要放弃自己的标准钱包，就有希望带着你的绝大部分比特币全身而退。你甚至可以做二手准备，将一个包含了比特币的口令短语用作障眼法，以防攻击者是个技术高手。</p><h2 id="BIP-39-口令短语是如何运作的？"><a href="#BIP-39-口令短语是如何运作的？" class="headerlink" title="BIP 39 口令短语是如何运作的？"></a>BIP 39 口令短语是如何运作的？</h2><p>BIP 39 兼容 BIP 32。BIP 32 允许用户构建由公钥和私钥组成的复杂的树。如果你在助记词的基础上增加了一个口令短语，就得到了一个主 BIP 32 钱包私钥。</p><p>这个新钱包以扩展指纹（XFP, Extended Fingerprint）作为标识。扩展指纹是一个由字母和数字组成的短字符串。请务记下它，因为它是你检验自己是否输对口令短语的唯一手段。</p><h2 id="关于使用口令短语的几点建议"><a href="#关于使用口令短语的几点建议" class="headerlink" title="关于使用口令短语的几点建议"></a>关于使用口令短语的几点建议</h2><h3 id="如何添加口令短语？"><a href="#如何添加口令短语？" class="headerlink" title="如何添加口令短语？"></a>如何添加口令短语？</h3><p>在不同钱包上使用口令短语的方法各不相同。如果你使用的是 <a href="https://coldcard.com/">Coldcard</a>，那就很简单了。你甚至可以直接从 BIP 39 单词表中选择单词添加，无需逐个添加字符。<a href="https://coldcard.com/docs/passphrase">欲知详情，可以阅读这篇指南。</a></p><h3 id="何时使用口令短语？"><a href="#何时使用口令短语？" class="headerlink" title="何时使用口令短语？"></a>何时使用口令短语？</h3><p>如果你持有大量比特币，而你理想中的钱包设置既要比标准钱包更安全，又要比多签钱包更容易创建、操作和存储，我推荐你使用口令短语。</p><p><strong>如果你还是新手，最好先熟悉普通钱包</strong>。随着你拥有比特币越来越多，对比特币的认识加深，用起比特币来也愈发得心应手，再探索这个功能才是明智之举。Coldcard 钱包的主界面上就有口令短语选项。别忘了，一旦你添加了口令短语，你就会得到一个全新的钱包，需要将你的比特币转移到这个钱包内！</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>口令短语可以帮助你轻松提高比特币私钥的安全性。但是，如果你决定使用口令短语，请牢记以下几点注意事项：</p><ol><li>口令短语要足够长，以防被人轻松暴力破解。如果有人拿到了你的助记词，你当然不希望他们一下子就猜出你的口令短语。<a href="https://blog.trezor.io/is-your-passphrase-strong-enough-d687f44c63af">欲知详情，查看这篇文章。</a></li><li><strong>务必保护好你的口令短语。一旦你弄丢了口令短语，就有可能丢失钱包里的所有比特币。</strong></li><li>不要将你的口令短语与你的助记词或钱包 PIN 或密码藏在同一个地方。</li><li>不要告诉任何人你有口令短语（当然也有例外，比如，你可以将口令短语告诉你信任的人，这样无论你发生任何事，他们都可以轻松找回你的比特币）。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Antonopoulos, Andreas M. 2017. Mastering Bitcoin: Programming the Open Blockchain. N.p.: O’Reilly.</p><p>（完）</p>]]></content>
    
    
    <summary type="html">私钥、钱包和口令短语的基本原理</summary>
    
    
    
    
    <category term="入门系列" scheme="https://www.btcstudy.org/tags/%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97/"/>
    
    <category term="钱包" scheme="https://www.btcstudy.org/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>解释 ItchySats 的 CFD 协议</title>
    <link href="https://www.btcstudy.org/2022/12/04/cfd-protocol-explained/"/>
    <id>https://www.btcstudy.org/2022/12/04/cfd-protocol-explained/</id>
    <published>2022-12-04T05:18:27.000Z</published>
    <updated>2023-01-12T06:01:27.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：lucas</em></p><p><em>来源：<a href="https://comit.network/blog/2022/01/11/cfd-protocol-explained/">https://comit.network/blog/2022/01/11/cfd-protocol-explained/</a></em></p></blockquote><p><img src="/../images/cfd-protocol-explained/unboxed.png" alt="img"></p><p>在 2021 年末，我们跟各位分享了创建<a href="https://itchysats.medium.com/itchysats-roadmap-to-the-most-awesome-bitcoin-dex-464a42bf4881">最出众的比特币去中心化交易所</a>的计划。在那篇文章中，我们罗列了如何在那一年剩余的时间里将<a href="https://comit.network/blog/2022/01/11/github.com/itchysats/itchysats">我们的解决方案</a>提升到更高层次。我们也承诺会给出我们的比特币 CFD（差价合约）的详细解释。这就是我们今天这篇文章的目的。</p><h2 id="开启一个-CFD"><a href="#开启一个-CFD" class="headerlink" title="开启一个 CFD"></a>开启一个 CFD</h2><p>如果你用过  <code>itchysats</code>，你可能看过这个 画面。在这个界面你可以吃掉挂单者创建的订单。</p><p><img src="/../images/cfd-protocol-explained/eenshot.png" alt="img"></p><p style="text-align:center">- 吃掉一个订单 -</p><p>你点击界面中的按钮，界面就会告诉你，一个新的差价合约建好了。几秒之后，这个 CFD 会转变成新的  <code>Open（开启）</code> 状态，然后你可以看到一笔交易广播出去了。看起来一切都好，但你可能对发生了什么一无所知。</p><h2 id="建立合约"><a href="#建立合约" class="headerlink" title="建立合约"></a>建立合约</h2><p>点击按钮会给挂单者发送一条消息，告诉他们你希望用一定的杠杆率和数量接受他们的 CFD。如果他们同意了这个请求，应用就会开启 <code>contract_setup</code> （“合约建立”）进程：利用多条消息，交换开启 CFD 所需的双方公钥、地址和签名。</p><p>为了文章的简明，在此我们就不细述这些消息了；如果你想了解更多细节的话，欢迎你阅读代码。我们的 CFD 代码放在一个专门的仓储中：<a href="https://comit.network/blog/2022/01/11/github.com/comit-network/maia">maia</a> 。</p><p>相反，我们会集中在这几轮通信的结果中：我们的差价合约实现的组成模块。</p><p><img src="/../images/cfd-protocol-explained/hot_cfd.jpg" alt="img"></p><p style="text-align:center">- 有限生命的差价合约 -</p><h3 id="锁定交易"><a href="#锁定交易" class="headerlink" title="锁定交易"></a>锁定交易</h3><p>参与一个差价合约的双方需要在区块链上锁定一些资金，这样协议才能强制执行打赌的结果 <sup><a href="#note1" id="jump-1">1</a></sup>。</p><p> <code>lock_transaction</code> （“锁定交易”）会从各方处获得一个或多个输入。它会产生一个由挂单者和吃单者的资金合并而成的共享输出。下文我们会把这个共享输出称为 <code>dlc_output</code> 。具体含义我们到下一章再说。锁定交易也可能会包括给各方的一个或多个找零输出。</p><p>在 <code>contract_setup</code> 结束的时候，双方都可以获得这个安全签名的交易的副本。也就是说，挂单者也签名了自己贡献的所有输入，吃单者也是如此。因此，在跑完 <code>contract_setup</code> 流程时，任何一方都可以通过广播锁定交易，从而开启 CDF。不论是谁来广播，或者都广播，都没有关系：被广播的交易是同一笔。</p><p>在锁定交易被广播之前，任何一方都有机会退出正在建立的 CDF。如果他们用在锁定交易中的某个输入被用于零一笔交易，这笔锁定交易自然就无法挖出了（因为会被当成重复花费）。</p><h3 id="DLC-输出"><a href="#DLC-输出" class="headerlink" title="DLC 输出"></a>DLC 输出</h3><p>如上所述，锁定交易的输入跟我们的协议有关的输出是 <code>dlc_output</code>（“DLC 输出”）。而 DLC（<a href="https://bitcoinops.org/en/topics/discreet-log-contracts/">谨慎日志合约</a>）是一种取决于一个受信任的第三方（通常称为 “断言机”）所播报的事件结果产生资金分配结果的输出。依靠它的机制，我们可以让交易的花费条件依赖于区块链外部的事件。在我们这个差价合约的案例中，就是 BTC 的价格运动；我们以 BTC 的价格运动来结算差价合约。</p><p>DLC 输出是一个简单的  <code>2-of-2</code> 多签名输出，一个公钥 <code>A</code> 来自挂单者，另一个公钥 <code>B</code> 来自于吃单者。也就是说，需要挂单者和吃单者各提供一个签名，才能花费这个输出。</p><p>让 DLC 得以工作的东西是预先计算好的、以不同方式花费 DLC 输出的交易。这样的基于事件的结果来花费 DLC 输出的交易称为 “合约执行交易（CET）”。而断言机可以为某一笔 CET 赋能的办法则来源于 “适配器签名”<sup><a href="#note2" id="jump-2">2</a></sup>。我们会用一个简单的例子来展示它是如何工作的。</p><p><strong>CET 案例解释</strong></p><p>在我们这个例子中，挂单者和吃单者建立了一个非常简单的差价合约：如果在合约到期时， BTC 的美元汇率超过 40000，吃单者就赢走所有资金；而另一方面，如果 BTC 的美元汇率低于 40000，则挂单者赢走所有资金。因为只有两种可能的结果，所以我们只需要创建两笔 CET：一笔将 DLC 输出中的所有资金交给吃单者；另一笔把所有资金交给挂单者。</p><p>为了防止 CET 在锁定交易被广播之后立即被广播，双方都只向对方分享自己对每一笔交易的 <em>适配器签名</em>。这样的适配器签名只有在断言机播报（“<em>见证</em>”）价格之后才能被解密 和转化为常规的签名。</p><p>具体到我们这个案例中，在双方开始合约建立流程之前，断言机就已经 <em>宣布</em> 自己将会见证 24 小时之后的 BTC 美元汇率。断言机的身份以公钥 <code>O</code> 来表示，TA 将使用 <code>O</code>  背后的私钥以及一套已知的见证方案<sup><a href="#note3" id="jump-3">3</a></sup>，播报这个汇率。 断言机的 <code>announcemnt</code>（“宣言”）中包含了一个公钥 <code>K</code>，这个公钥代表断言机的承诺 —— TA 会在这个事件的  <code>attestation</code> （“见证消息”）中使用 <code>K</code> 背后的随机数 <code>k</code> 。这个一次性使用的随机数（nonce）（<code>k</code>）让断言机可以无限次见证不同的事件，而无需变换其用于发布见证消息的私钥 <code>o</code> <sup><a href="#note4" id="jump-4">4</a></sup>。</p><p>有了宣言中的 nonce 公钥 <code>K</code>、断言机的见证公钥 <code>O</code> 以及对价格区间的一个标识符（可用于解锁具体的 CET），参与这个差价合约的两方就可以构造出适配点（adaptor point），适配点则可用于产生相应的适配器签名（如上所述，他们仅向对方分享自己公钥的适配器签名）。举个例子，吃单者使用 <code>K</code>、 <code>O</code> 以及一个代表 <code>0-40k USD</code>（0 ~ 40000 美元）的标识符，就可以产生一个适配器点 <code>Y_short</code>。然后，TA 就可以用 <code>Y_short</code> 来加密自己的公钥 <code>B</code> 对那一笔把所有资金都分配给挂单者的 CET 的签名。在合约建立流程期间，吃单者把自己的适配器签名分享给挂单者。如果断言机见证了 BTC 的美元汇率低于或等于 40000，挂单者就可以解密这个签名并发布对应的 CET。</p><p>在实际操作中，我们整合 <sup><a href="#note5" id="jump-5">5</a></sup> 的断言机 <code>olivia</code> 不会见证代表一个价格区间的标识符，也不会见证一个具体的价格。相反，它会见证价格的二进制表示数值，一个接一个。这使得我们可以大量减少 CET 的数量，因此双方需要构造的适配器签名数量也大量减少。上面这个案例是一个简化版本，因为现实世界中 CFD 的可能结果通常会形成一条平滑的曲线。如果我们使用具体的价格，那么 CET 的数量会非常多，导致协议的存储效率和时间效率非常低下。</p><p>将支付曲线离散成区间，并使用播报 BTC 价格的二进制表示的断言机，意味着我们可以实现相对清楚的支付曲线，而无需将合约建立的流程拖得很长并占用惊人的存储空间。我们可能还会撰文讲解实现这些节约的规范，但还是鼓励你看看代码。如果你想了解更多，欢迎<a href="https://matrix.to/#/!OSErkwZgvuIhcizfaI:matrix.org?via=matrix.org">向我们提问</a>。</p><h3 id="退款交易"><a href="#退款交易" class="headerlink" title="退款交易"></a>退款交易</h3><p>在上一节中，我们暗示了这个协议需要对第三方（断言机）的信任。即使你将这种信任分散到多个断言机，你也还是得准备应对在价格见证消息应该发布时太多断言机挂掉的情形。</p><p>如果只有 CET 能花费 DLC 输出，那么当 <code>olivia</code> 忘了发布对应于宣言的见证消息时，使用我们这套协议的资金就可能无法花费。</p><p>为了应对这种不太可能发生的情形，双方需要在合约建立流程中合作构造和签名一笔 <code>refund_transaction</code>（“退款交易”）。这笔交易会花费 DLC 输出，将挂单者和吃单者的资金按原比例返还。退款交易的输入会使用一个相对时间锁，从而保证这笔交易只能在锁定交易得到区块确认的一段时间之后才能挖出。这个相对时间锁的数值会设置得双方都有足够长的时间来发布 CET（即只要 <code>olivia</code> 发布了有效的见证消息，对应的 CET 就可以上链）。</p><h2 id="永续-CFD"><a href="#永续-CFD" class="headerlink" title="永续 CFD"></a>永续 CFD</h2><p>前面一个章节是对我们的 CFD 协议的第一个版本的准确描述。但是，在实现它的过程中，我们意识到我们还有一个尚未满足的要求：根据定义，CFD 必须没有到期日。</p><p>现在，我们还不能容易地选取来自传统金融世界的工具（例如差价合约）并在区块链上准确地重新制作出来。我们很可能总是需要预先定义出一个时间点，好让某一方能单方面结算 CFD（在见证消息发布后把 CET 发布上链）。要是没有这个终止点，不合作的对手方就可以无限期冻结你的资金。</p><p>但是，我们依然可以允许在双方一致同意时刷新合约的生命周期，从而越过此前约定的到期时间、模拟出传统差价合约的永续特性。</p><p><img src="/../images/cfd-protocol-explained/ual_cfd.jpg" alt="img"></p><p style="text-align:center">- 永续的差价合约 -</p><h3 id="延期"><a href="#延期" class="headerlink" title="延期"></a>延期</h3><p>给一个 CFD “延期（Rollover）”，就意味着我们将添加一组全新的 CET，它们将依赖于更遥远的未来被见证的事件结果。构造新 CET 的过程跟前面讲述的没有什么差别。然而，想要直接花费锁定交易，可就不行了。最初在合约建立流程中创建的那一组 CET 依然是完全有效的，所以，虽然理论上双方可以在相应的见证消息出现后也不发布 “旧” 的 CET，但这需要相互信任（即背叛的一方不会得到惩罚）。</p><p>幸运的是，这类问题在之前就已经有解决方案了，最著名的一个例子就是 “<a href="https://github.com/lightning/bolts/blob/93909f67f6a48ee3f155a6224c182e612dd5f187/05-onchain.md#revoked-transaction-close-handling">闪电网络的撤销机制</a>”。在开发出 “<a href="https://eprint.iacr.org/2020/476.pdf">广义的比特币兼容通道</a>” 的<a href="https://github.com/comit-network/thor/">一个实现</a>之后，我们确定了我们要在自己的 CFD 协议中使用相同的结构。</p><h3 id="承诺交易"><a href="#承诺交易" class="headerlink" title="承诺交易"></a>承诺交易</h3><p>现在，锁定交易的输出要改称为  <code>lock_output</code>（“锁输出”） 。这个输出存在的目的只是为了让 CFD 的创建更加清晰。在锁定交易发布之后，双方将不再能退出合约；其输出也不再被 CET 直接花费。相反，我们要引入一笔 <code>commitment_transaction</code> （“承诺交易”），由这笔交易将锁输出转化为 DLC 输出。</p><p>而 DLC 输出，在现在协议中虽然变成了另一笔交易的输出，但其花费方式与前面的协议没有区别：一组 CET 定义了 DLC 输出如何根据 BTC 的美元汇率来分割。承诺交易的目的是为了保证 DLC 输出只能被一起构造的 CET 花费。</p><p>重要的是，退款交易的作用跟原来一样：它会花费 DLC 输出（现在是承诺交易的输出）。我们这里着重讲解 CET，但前一个章节对退款交易的描述放到这里依然城里。</p><p>举个例子，我们可以设想挂单者和吃单者一致同意延期一个 CFD，因为他们都相信日后的 BTC 价格波动会有利于自己。在合约建立流程中，他们创建并签名 <code>commitment_transaction_0</code> 以及相应的一组 CET。而在 <code>Rollover</code> （“延期”）流程中，他们要制作新的一笔 <code>commitment_transaction_1</code> 交易，以及全新的一组基于 <code>olivia</code> 的新宣言的 CET。因为他们都可以发布完全签名的承诺交易，所以他们最终可以发布 <code>commitment_transaction_1</code> 并根据来自 <code>olivia</code> 的新见证消息来结算 CFD。</p><h3 id="惩罚交易"><a href="#惩罚交易" class="headerlink" title="惩罚交易"></a>惩罚交易</h3><p>那么，要是某一方决定发布旧的一笔承诺交易、使用断言机所见证的旧的 BTC 价格来结算 CFD，该怎么办呢？这就完全违背了 CFD 延期的意义。这就是我们需要撤销机制的地方。</p><p>承诺交易的 DLC 输出有不止一种花费方式。它总共有 3 种花费方式：</p><pre><code>1. 被 CET 花费（而双方手中的 CET 都只有对方的适配器签名，需要来自  `olivia` 的见证消息才能补成常规签名）2. 被一笔 “退款” 交易花费，这是应对没有 CET 被  `olivia` 解锁的安全机制3. 被各方的一笔  `punishment_transaction`（“惩罚交易”） 花费，当某一方发布一笔已被撤销的承诺交易时，另一方可单方面构造惩罚交易、取走 DLC 输出中的所有资金</code></pre><p>在合约建立以及后续每一次延期流程中，双方都要一起为 DLC 输出添加另一个花费条件。他们各生成一对（用于撤销的）密钥 <code>(r, R)</code>，以及一对（用于发布的）密钥 <code>(p, P)</code> ，并将公钥分享给对方。DLC 输出不再是一个使用公钥 <code>A</code> 和 <code>B</code> 的简单 2-of-2 多签名输出。它的脚本还包括：</p><pre><code>1. 挂单者知晓私钥 `a`、 `吃单者的 r` 和 `吃单者的 p` 就可以花费2. 吃单者知晓私钥 `b`、 `挂单者的 r` 和 `挂单者的 p` 就可以花费</code></pre><p>双方不是交换对承诺交易的常规签名，而且创建一个适配器签名并交给对方。举个例子，吃单者使用挂单者的 P 加密自己的公钥  <code>B</code> 对承诺交易的签名（从而生成一个适配器签名）。稍后，挂单者可以使用自己的 p 解密吃单者的适配器签名；但是，一旦他们使用这个解密后的签名发布了承诺交易，自己的 p 就泄露给了吃单者。</p><p>此外，每次完成延期流程时，双方都必须交换自己在 上一笔承诺交易中使用的撤销私钥（ <code>r</code> ）。如果一方不愿意分享这个私钥，另一方应该立即广播新的承诺交易。不然，对手就可以选择在任意时间发布某一笔承诺交易；这会给予他们选择更有利的结算结果的选择权。</p><p>安排好所有这些之后，挂单者和吃单者就知道他们可以应对对手尝试花费已被撤销的（并非最新的延期操作或合约建立操作所创建的）承诺交易的情形。只要对手敢于这样做，他们就能知晓对手的私钥 p，加上在延期过程中知晓的对手的 r，就可以签名一笔交易，将 DLC 输出中的所有资金收入囊中。</p><p>显然，这种机制要求双方几乎全时段在线（并且需要存储对手提供的每一个 r）。他们必须时刻关注对手有没有发布已经被撤销的承诺交易。 每个 CET 都有一个相对时间锁，所以被欺诈的一方有充足的时间可以发布惩罚交易。</p><h3 id="在区块链上合作"><a href="#在区块链上合作" class="headerlink" title="在区块链上合作"></a>在区块链上合作</h3><p>如你们所见，这套 CFD 协议是非常有用的。这套系统让我们可以模拟传统 CFD 的机制，并且保护所有相关方的资金，而且是在区块链这样你无需信任任何人的环境中。</p><p>但我们也必须指出另一重局限性：我们无法随时清空仓位；这是我们希望克服的另一点。在传统金融中，你可以随时关闭差价合约，拿走你的盈利或承担你的损失。而在我们的比特币 CFD 中，我们只能等待断言机发布对应于合约建立或延期中的宣言的 BTC 价格的见证消息。</p><p><img src="/../images/cfd-protocol-explained/ent_cfd.jpg" alt="img"></p><p style="text-align:center">- 合作式结算的 CFD -</p><p>看起来是没有办法让任何一方都能随时单方面关闭 CFD 了，但是我们引入了另一种机制，在双方 <em>一致</em> 同意之时，可以早于见证消息发布的时间关闭仓位。我们管这种机制叫  <code>collaborative_settlement</code>（“合作式关闭”）。如果挂单者和吃单者一致同意以某一种结果结算 CFD，他们可以一起创建和签名一笔交易，直接花费锁输出。这意味着双方都要在线，并一致同意提前平仓 CFD。但是，如果条件不能满足，双方都知道他们依然可以依赖于常规的结算操作（CET），这是由密码学保证的。</p><h2 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h2><p>虽然我们对这套比特币 CFD 协议的成果好自豪，我们也知道，还有很多工作要做。我们的<a href="https://itchysats.medium.com/itchysats-roadmap-to-the-most-awesome-bitcoin-dex-464a42bf4881">路线图博文</a>介绍了一些我们需要追踪的东西，但我们也在考虑别的一些优化和特性。</p><p>除了我们已经有想法的部分，我们也认为，实现不依赖于单个断言机的 CFD 非常重要。如前所述，基于 DLC 的协议需要信任断言机。但如果我们可以把这部分责任分散给多台断言机，它们勾结和故障的可能性都会大幅降低。更具体地说，有了多个断言机，通过 CET 来结算的 CFD 就不再依赖于单个断言机。相反，我们将使用多个断言机的见证消息来决定哪个 CET 可以执行。举个例子，我们可以实现一种 4-of-7 的机制，7 个断言机中的简单多数才能决定解锁哪一笔 CET。</p><p>这个领域还有许多我们密切关注的正<a href="https://github.com/discreetlogcontracts/dlcspecs/blob/master/MultiOracle.md">在进行的研究</a>。你可以在开源的代码库中跟进我们这个<a href="https://comit.network/blog/2022/01/11/github.com/comit-network/maia">协议</a>和  <code>itchysats</code> 的进展。如有问题，欢迎加入我们的公开频道：<a href="https://t.me/joinchat/ULycH50PLV1jOTI0">Telegram</a> 和 <a href="https://matrix.to/#/!OSErkwZgvuIhcizfaI:matrix.org?via=matrix.org">Matrix</a>。</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>1.<a id="note1"> </a>就其核心，差价合约就是对资产未来价格的打赌。 <a href="#jump-1">↩</a></p><p>2.<a id="note2"> </a>我们所用的、由适配器签名赋能的 DLC 输出基于 <em><a href="https://github.com/discreetlogcontracts/dlcspecs">dlcspecs</a>*，这个项目正在为谨慎日志合约开发一套规范。它跟 <a href="https://adiabat.github.io/dlc.pdf">Dryja 最初的工作</a> *不同</em>。 <a href="#jump-2">↩</a></p><p>3.<a id="note3"> </a>这样的见证方案通常是签名方案，比如 Schnorr 签名。实际上我们使用一种更简单的、由我们整合的独立断言机的方案。想了解更多信息，请在我们的 CFD 协议代码库中查找 <code>olivia</code> 以及<a href="https://github.com/comit-network/maia/blob/55ba9f2e4f0ff40b0b2e89458fbbbe2dadceb913/src/oracle.rs">这个模块</a>。 <a href="#jump-3">↩</a></p><p>4.<a id="note4"> </a>如果不使用 nonce（一次性随机数），或者更常见的，多次使用同一个 nonce，会导致这个断言机的见证私钥在见证结果后泄露。（译者注：即使用同一个 nonce、同一个私钥对不同消息签名会导致私钥泄露。） <a href="#jump-4">↩</a></p><p>5.<a id="note5"> </a>重点是保证断言机不属于参与 CFD（广义来说是 DLC）的任何一方。否则他们就有可能为了自己的利益而干预结果。 <a href="#jump-5">↩</a></p>]]></content>
    
    
    <summary type="html">一次性差价合约及永续差价合约的实现</summary>
    
    
    
    
    <category term="Discreet-Log-Contract" scheme="https://www.btcstudy.org/tags/Discreet-Log-Contract/"/>
    
  </entry>
  
  <entry>
    <title>闪电网络上的谨慎日志合约</title>
    <link href="https://www.btcstudy.org/2022/12/02/dlc-on-lightning-by-thibaut-le-guilly/"/>
    <id>https://www.btcstudy.org/2022/12/02/dlc-on-lightning-by-thibaut-le-guilly/</id>
    <published>2022-12-02T07:50:55.000Z</published>
    <updated>2023-01-12T06:01:27.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Thibaut Le Guilly</em></p><p><em>来源：<a href="https://medium.com/crypto-garage/dlc-on-lightning-cb5d191f6e64">https://medium.com/crypto-garage/dlc-on-lightning-cb5d191f6e64</a></em></p></blockquote><p><img src="/../images/dlc-on-lightning-by-thibaut-le-guilly/ndF_7g.png" alt="img"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们已经在主网上开启和关闭了第一条嵌入了一个谨慎日志 合约（DLC）的闪电通道。</p><p>我们 Crypto Garage 一直在开发可以在闪电通道中工作的 DLC，而我们最终也到达了一个重要的里程碑：我们成功开启了一条闪电通道并在其中建立了一个 DLC，最终关闭了整个通道。在本文中，我会解释闪电通道与 DLC 建立和关闭的技术细节。</p><h2 id="什么是闪电通道中的-DLC（以及什么不是）"><a href="#什么是闪电通道中的-DLC（以及什么不是）" class="headerlink" title="什么是闪电通道中的 DLC（以及什么不是）"></a>什么是闪电通道中的 DLC（以及什么不是）</h2><p>出于本文的目的，我们所谓的 “在闪电通道中开启 DLC”，意思是两个节点<strong>直接</strong>建立一条通道，并在通道内使用（部分）资金建立一个 DLC。这个 DLC 可以关闭（让通道回归常规的闪电通道），也可以更新，而且通道也可以在非合作情境下关闭（我们也正是这么做的，这样会让闪电通道和 DLC 合约的交易结构完完整整在链上展示出来）。</p><p>我们要强调的是，当前无法做到通过闪电网络来 <em>路由 DLC</em>（即无法跟没有直接通道的节点开设 DLC）。这份<a href="https://mailmanlists.org/pipermail/dlc-dev/2021-November/000091.html">邮件组帖子</a>提供了更多信息。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>为了热身以及让这篇文章自足，我们将历数在闪电通道中建立 DLC 所需的各种元素：<a href="https://docs.google.com/document/d/1SndejwtOQC93BieINox2Gg5HtnUgFcLTVQODL8MP5Z4/edit#heading=h.jbsgei7du8a5">闪电通道</a>、<a href="https://docs.google.com/document/d/1SndejwtOQC93BieINox2Gg5HtnUgFcLTVQODL8MP5Z4/edit#heading=h.cb0xldu0vqab">适配器签名</a>、<a href="https://docs.google.com/document/d/1SndejwtOQC93BieINox2Gg5HtnUgFcLTVQODL8MP5Z4/edit#heading=h.it41s33fig1">DLC</a>  和 <a href="https://docs.google.com/document/d/1SndejwtOQC93BieINox2Gg5HtnUgFcLTVQODL8MP5Z4/edit#heading=h.niw3p88jfsaz">DLC 通道</a>。</p><h3 id="闪电通道"><a href="#闪电通道" class="headerlink" title="闪电通道"></a>闪电通道</h3><p>如果对常规闪电通道的交易结构没有起码的理解，就很难理解如何在一条闪电通道中建立 DLC，所以我们快速回顾一下闪电通道的原理（若要获得更深入的理解，请看 <a href="https://bitcoinmagazine.com/technical/understanding-the-lightning-network-part-building-a-bidirectional-payment-channel-1464710791">Bitcoin Magazine 的系列文章</a>）。我们仅仅关注跟我们的需求相关的部分，所以跟路由相关的部分我们全部跳过。</p><p>当两个闪电网络节点要开设一条通道时，他们会合作构造和签名两种类型的交易，“<em>注资交易</em>” 和 “<em>承诺交易</em>”。</p><p>注资交易以其中一方的几个 UTXO 作为输入（如果支持<a href="https://bitcoinops.org/en/topics/dual-funding/">双向注资</a>技术，也可以双方都提供 UTXO），然后将资金锁入一个 2-of-2 的多签名输出中，为通道所用；这样的输出需要双方同时提供签名才能花费。</p><p>承诺交易则以注资交易的输出为输入，产生两个输出，这两个输出的面额对应双方的余额。注意，这些余额会在通道的生命周期中不断改变，所以，承诺交易需要不断更新以反映这些变化。这是通过让承诺交易变得 <em>可以撤销（revocable）</em> 来实现的。在实践中，这意味着每一方都保存着每一笔承诺的不同版本；在他们保管的承诺交易中，一个支付给他们自己的输出被锁定在这样一个脚本中：这个脚本即可以在一段事件后由他们自己解锁，也可以被掌握了某个秘密值的对手直接解锁。当双方都同意更新通道余额时（例如，一方希望给另一方支付一些钱），他们就构造并交换新的承诺交易和签名，并向对方揭晓在上一笔承诺交易中使用的秘密值，从而撤销掉上一笔交易。如果一方想要欺诈对手 —— 广播比较旧的承诺交易，对方有时间可以反击 —— 使用本地保存的秘密值，拿走通道中所有的资金。</p><p>整个交易结构如下图所示：</p><p><img src="/../images/dlc-on-lightning-by-thibaut-le-guilly/dIYJqUpLD3_.png" alt="img"></p><p style="text-align:center">- 闪电通道的交易结构 -</p><h3 id="适配器签名"><a href="#适配器签名" class="headerlink" title="适配器签名"></a>适配器签名</h3><p>适配器签名是一种加密过的签名（使用了某一个公钥），而且我们可以证明，在（使用对应的私钥）解密之后，可以得到对某条消息的有效签名。它还有一种属性：知晓了适配器签名、加密公钥和解密后的签名，就可以恢复出用来加密的秘密值。<a href="https://medium.com/crypto-garage/optimizing-numeric-outcome-dlc-creation-6d6091ac0e47#96e9">这里</a>对所设计的模块作了概要的介绍。</p><p>下图展示了加密、验证和解密适配器签名的不同操作，以及恢复秘密值的过程。</p><p><img src="/../images/dlc-on-lightning-by-thibaut-le-guilly/MRbdgVVq7wG.png" alt="img"></p><h3 id="谨慎日志合约"><a href="#谨慎日志合约" class="headerlink" title="谨慎日志合约"></a>谨慎日志合约</h3><p>DLC 让两方可以建立一个依赖于某些事件（体育比赛、资产价格 ……）的合约，并且直接在比特币区块链上结算。参与的双方需要提前选择一个播报事件的实体（“断言机”），这个实体会通过放出对结果的签名来见证事件的结果。</p><p>DLC 乍看起来可能跟闪电通道很像，但是它并不使用从注资交易中花费的承诺交易，而是 “合约执行交易（CET）”，每一笔 CET 都对应着事件的一种可能结果（以及支付数量）。双方都使用断言机会为不同事件结果创建的签名作为原像，加密自己的签名（从而产生适配器签名）（更多细节可见<a href="https://medium.com/crypto-garage/optimizing-numeric-outcome-dlc-creation-6d6091ac0e47#96e9">此处</a>），然后交换并验证它们。一旦断言机见证了某个结果，DLC 的任意一方都可以解密对方的某一个签名，然后广播对应的 CET、结算合约。注意，因为使用了适配器签名，双方手中的 CET 是一样的。一个 DLC 的交易结构如下图所示。</p><p><img src="/../images/dlc-on-lightning-by-thibaut-le-guilly/rinQigX8y2T.png" alt="img"></p><p style="text-align:center">- 链上 CDL 的交易结构 -</p><h3 id="DLC-通道"><a href="#DLC-通道" class="headerlink" title="DLC 通道"></a>DLC 通道</h3><p>那么，如果双方希望在上一个 DLC 到期后新建一个合约呢？当然，他们可以先关闭一个，再新建另一个。但是每一笔上链的交易都需要支付手续费。相对的，他们可以使用 DLC 通道（ItchySats 已经撰写了一份很棒的<a href="https://comit.network/blog/2022/01/11/cfd-protocol-explained/">详细介绍</a>）。DCL 通道允许双方新建合约、在到期之前提前结算合约，当然，也可以在他们希望回收资金的时候在链上关闭合约。一种简单的实现办法是让 CET 变成可以撤销的。但是，那会导致新建合约的时候出现问题。即使某一方撤销掉了以前的 CET，也无法防止对手使用它们。这就意味着，对手方总是可以选择使用旧的 CET 或新的 CET 来关闭通道，而先撤销自己的 CET 的一方则没有选择，只有等待新的合约到期（因为他们需要等待断言机放出签名，这样才能广播 CET）。这给了其中一方不公平的优势。为了解决这个问题，我们引入了一种 “<em>缓冲交易</em>”，它将花费注资交易的输出，并产生相同价值（减去手续费）的输出；缓冲交易的输出再作为 CET 的输入。这样，当我们需要新建合约时，如果某一方不及时撤销前一个合约，另一方可以直接广播新合约的缓冲交易、防止恶意（或误操作的）对手方使用旧合约的 CET 关闭通道。</p><p>那我们要如何撤销旧的缓冲交易呢？一种办法是借鉴闪电网络，让双方都保存缓冲交易的不同版本。幸运的是，还有另一种更好的解决方案（最早是由<a href="https://eprint.iacr.org/2020/476.pdf">这篇论文</a>提出的）。它也依赖于适配器签名，只不过跟常规的 DLC 利用它的方式不同。每一方都使用三组密钥。第一组是注资密钥，用在注资交易输出的 2-of-2 输出中。第二组是撤销密钥，每当一个合约被撤销时就公开。最后一组是公示密钥。这三个密钥都用在缓冲交易的输出脚本中，让这个输出有三种不同的花费方式（我们使用 “Alice” 和 “Bob” 作为两方的代称）：</p><ol><li>使用 Alice 和 Bob 双方的注资密钥的签名（用在 CET 交易中，就像链上 DLC 一样，必须知道断言机对事件结果的见证才能使用）</li><li>一个来自 Alice 注资密钥的签名，以及来自 Bob 的公示密钥和撤销密钥的签名</li><li>一个来自 Bob 注资密钥的签名，以及来自 Alice 的公示密钥和撤销密钥的签名</li></ol><p>当一个合约在通道中建立的时候，Alice 和 Bob 各给对方一个用于缓冲交易输入的适配器签名，是用对手的公示公钥加密过的。要是其中一人希望广播缓冲交易，TA 就要使用自己的公示私钥解密从对方处获得的适配器签名。但是，广播了缓冲交易（其中包含了解密后的签名），TA 就向对方揭开了自己的公示私钥（对方已经知道了适配器签名和加密密钥）。如果缓冲交易还未被撤销，那就没有什么问题，他们可以使用某一条 CET 正当地花费缓冲交易的输出。但如果缓冲交易已经被撤销了，对手方必然就知晓了撤销私钥，因此可以拿走全部的资金。最后，CET 带有一个相对时间锁，让被欺诈的一方可以花费已作废的缓冲交易输出。</p><p>下图演示了这种交易的结构及其花费条件。</p><p><img src="/../images/dlc-on-lightning-by-thibaut-le-guilly/pbTOkCdVvun.png" alt="img"></p><p style="text-align:center">- DLC通道的花费条件 -</p><h2 id="闪电通道中的-DLC"><a href="#闪电通道中的-DLC" class="headerlink" title="闪电通道中的 DLC"></a>闪电通道中的 DLC</h2><p>我们已经解释完了所有的基本模块，现在我们来看看如何在闪电通道中嵌入一个 DLC 通道。</p><p>第一种明显的思路是在闪电通道的承诺交易中增加一个输出，以形成一个 DLC 通道。然而，这就意味着，每一次我们更新承诺交易的时候，DLC 的所有适配器签名都要重新计算（以及重新验证），这对于拥有大量可能结果的合约来说是非常昂贵的（这个问题可以靠 SIGHASH_NOINPUT 以及类型的升级修复）。为避免这一点，我们引入了一种 “<em>分割交易</em>”。它会花费注资交易的输出并形成两个输出：一个用于闪电通道，一个用于 DLC（可以通过增加输入来同时开启多个 DLC 通道、同时执行多个合约）。为了能够将通道恢复成 “标准” 的闪电通道，，我们使用<a href="https://docs.google.com/document/d/1SndejwtOQC93BieINox2Gg5HtnUgFcLTVQODL8MP5Z4/edit#heading=h.niw3p88jfsaz">跟 DLC 通道同样的、基于适配器签名的机制</a>，让分割交易变成可撤销的。</p><p>不过，这样一来闪电通道又会出问题。为了让一方能够到欺诈的另一方（广播已被撤销的分割交易）作出反应，分割交易需要带有时间锁以阻止立即花费。但是，<a href="https://github.com/lightning/bolts/blob/master/03-transactions.md#commitment-transaction">闪电网络的规范已经用到了承诺交易的 nLockTime 和 nSequence 字段</a>，以指定承诺号。为了解决这个问题，我们在分割交易与闪电通道承诺交易之间插入了一个 <em>粘合交易</em>，以实施一个相对时间锁（感谢 Matt Corallo 提出了这个简单的解决方案）。注意，这实际上是一个工程问题，可以通过为承诺交易使用不同的规范来解决（但这将需要闪电网络实现加入更多变更以支持它）。</p><p>总结一下，如果双方有一个直接的闪电网络通道，并希望在其中建立一个 DLC，他们可以合作创建并签名分割交易、粘合交易以及更新后的承诺交易（反映双方保留在闪电通道中的资金）、缓冲交易以及 DLC 的 CET。然后，他们就可以在闪电通道中路由支付、在 DLC 通道中更新和结算 DLC 合约。如果他们想要关闭 DLC 通道，他们可以作废分割交易，并合作创建和签名更新后的承诺交易。</p><p>下图演示了这个交易结构。注意，分割交易和缓冲交易用到了不同的公示和撤销密钥。</p><p><img src="/../images/dlc-on-lightning-by-thibaut-le-guilly/HLtd4Fg.png" alt="img"></p><p style="text-align:center">- 在闪电通道中嵌入 DLC 通道的交易结构 -</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>上述构造已经在我们的 <a href="https://github.com/p2pderivatives/rust-dlc/tree/feature/split-tx-manager-2">rust-dlc 库</a>中实现了，这个库使用了 <a href="https://github.com/p2pderivatives/rust-lightning/tree/split-tx-experiment">Lightning Development Kit（LDK）</a>的一个分叉，加入了对分割闪电通道的特性的支持。我们也实现了一个基于 LDK 样本的<a href="https://github.com/p2pderivatives/ldk-sample/tree/ln-dlc-test">小型命令行工具</a>，除了常规的闪电通道功能，还启用了开启和管理 DLC 通道的功能。注意，代码还非常不稳定，而且我们要强调，<strong>在主网上使用非常有可能导致资金丢失</strong>。</p><h2 id="主网执行"><a href="#主网执行" class="headerlink" title="主网执行"></a>主网执行</h2><p>我们于 11 月 21 日在我们的两个启用了闪电网络的节点中开启了一条通道，<a href="https://blockstream.info/tx/f307a6330c25ff4a43290803b088754b03ffd9c90c556aebca9a89d0b0ff9988">注资交易是这一笔</a>。然后，我们从开启通道的节点给另一个节点发送了一笔 keysend 支付（等到 LDK 实现了双向注资的时候，就不必执行这一步了）。我们定义了一个基于比特币在 11 月 21 日下午 4 点（JST）的价格的 DLC，并在闪电通道中开启了一条 DLC 通道。在这个合约到期时，我们让其中一个节点强制关闭通道。这个节点先是广播了分割交易（见<a href="https://blockstream.info/tx/a110bc985c6b02e5d4a80a6eca4a4561462975dbe65a70a9dd2fb9af47330326">此处</a>）。分割交易得到确认的 288 个区块（缓冲交易和粘合交易的 nSequense 数值）之后，我们让这个节点广播缓冲交易和粘合交易（见<a href="https://blockstream.info/tx/2084f0fab71ceb05a83cc8c1c7430e9aa101cba23d886fa75ccfc46616659af2">此处</a>和<a href="https://blockstream.info/tx/5db5f26943af8f8b2e1be37b612d0d6f768c1117d7e6e63d08ee93cede6c63c1">此处</a>），以及本地的承诺交易（见<a href="https://blockstream.info/tx/bfde28fba3b4873e87f2044e861dc117f321091dc635dafa1ffa2df46c723591">此处</a>）。缓冲交易得到确认的 288 个区块之后，节点获得了断言机对结果的签名，从而解密了另一方对相应结果的适配器签名，然后广播一笔 CET，结束了这个 DLC（见<a href="https://blockstream.info/tx/c0819ea9d8fe73ce3ad79e7aedbcbe8931258e4961b456317a64420ae402aa7e">此处</a>）。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>可以在闪电通道中开启 DLC 的能力，开启了一些很棒的应用，例如将部分通道的价值与其它货币挂钩、使用通道中的资金交易一些衍生品合约（同时无需放弃资产托管），甚至可以直接跟朋友打赌球赛的胜负。在 rust-dlc 库中实现功能支持，并通过在闪电通道中执行和关闭 DLC 演示了器用途，我们已经证明了我们提出的方法的可行性。要分析和优化这个提议并强化这个实现，还有非常多工作要做。所以，如果你有兴趣贡献一份力量或使用这种技术，甚至仅仅是想了解更多，都欢迎联系我们！</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢 LDK 团队审核以及接受让实现本文所述的技术成为可能的多项 PR，以及解答我们对 LDK、闪电网络和 Rust 的许多问题！</p><p>（完）</p>]]></content>
    
    
    <summary type="html">在闪电通道中嵌入 DLC 通道</summary>
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/categories/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Discreet-Log-Contract" scheme="https://www.btcstudy.org/tags/Discreet-Log-Contract/"/>
    
  </entry>
  
  <entry>
    <title>从 Miniscript 到 Simplicity</title>
    <link href="https://www.btcstudy.org/2022/12/01/from-miniscript-to-simplicity/"/>
    <id>https://www.btcstudy.org/2022/12/01/from-miniscript-to-simplicity/</id>
    <published>2022-12-01T02:23:16.000Z</published>
    <updated>2023-01-12T06:01:27.465Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Christian Lewe</em></p><p><em>来源：<a href="https://blog.blockstream.com/from-miniscript-to-simplicity/">https://blog.blockstream.com/from-miniscript-to-simplicity/</a></em></p></blockquote><p><img src="/../images/from-miniscript-to-simplicity/080px-1.png" alt="From Miniscript to Simplicity"></p><p>比特币是由计算机程序控制的，这些程序通过提供有效的见证数据换取资金解锁 。比特币脚本则编码了决定什么见证数据有效的花费条件。每笔交易都依赖这个机制。因此，确保这个机制良好运作就是确保交易有效完成。我们如何确保这些程序是正确的，尤其是那些编码了复杂花费条件的程序？我们是如何追踪这种复杂性的？像 <a href="https://github.com/rust-bitcoin/rust-miniscript">Miniscript</a> 这样的树形程序可以解决这个问题。</p><p>树是一组由边连接的节点的集合，它是最基础的数据结构之一。每个节点可能会连接 0 个或以上的子节点，但是只会连接一个父节点。每棵“树”都是从一个没有父节点的特殊根节点“生长”起来的。因此，我们可以选择任意一个节点看它的后代：那就是一棵更小的树！一棵树由很多棵较小的树通过递归方式组成。这就意味着，对于那些可以用树表示的数据，我们可以通过递归算法处理它，将它一点一点分解。对于我们来说，这会让数据分析变得更容易。</p><h2 id="寻找比特币中的树"><a href="#寻找比特币中的树" class="headerlink" title="寻找比特币中的树"></a>寻找比特币中的树</h2><p>Miniscript 是比特币脚本的一个子集。它在脚本上加了一个树结构来标识脚本各个部分的功能。一些部分要求签名，一些部分要求哈希原像，一些部分执行时间锁，还有一些部分结合起来组成更大的条件。透过树结构，我们可以清楚地了解脚本的含义。每个部分所扮演的角色都可以从树中看出来。</p><p><img src="/../images/from-miniscript-to-simplicity/chart1.jpg" alt="chart1"></p><p style="text-align:center">- 上图是一个比特币脚本以及位于该脚本“之上”的 Miniscript 树结构的示例 -</p><p>事实证明，树结构确实非常有用：我们可以沿着树静态分析和归纳证明脚本的属性。我们可以轻而易举地显示一个脚本承认或拒绝某个见证，产生了某笔费用，或在执行过程中达到资源上限。我们甚至可以将两个脚本合二为一，从而编码两者的结合体。通过这个工具包，我们可以编码复杂的花费条件，同时相信由此产生的脚本是正确的。</p><p>原始的 Bitcoin Script 不具备上述便利性，因此使用起来麻烦得多。一段脚本的含义通过 C++ 实现进行隐式定义。一般来说，这类脚本缺少一个清晰的结构，很难进行推理。此外，Bitcoin Script 本身甚至无法表达像乘法和字符拼接这样的基础操作。这些阻碍使得我们很难随心所欲地编写花费条件。</p><p>通过将树结构引入脚本，Miniscript 改进了 Bitcoin Script 的核心功能。为此，我们在 Miniscript 中只包含编码了密钥、哈希值和时间锁的、表现良好的小型脚本，不包含其它用途的外来脚本。由于 Miniscript 归根结底是带有结构的比特币脚本，你无需软分叉就可以使用它。只有想要使用该结构的钱包和其它软件才需要通过更新来支持它。</p><h2 id="打破边界"><a href="#打破边界" class="headerlink" title="打破边界"></a>打破边界</h2><p>我们如何在保留 Miniscript 的有用属性的基础上更进一步？我们如何让这个系统变得更强大，同时保留其结构？抱着这些想法，我们从头创建了一种全新的区块链语言 <a href="https://www.youtube.com/watch?v=n4iLNNF3sU0">Simplicity</a>，作为 Bitcoin Script 的替代选择。</p><p><a href="https://github.com/ElementsProject/simplicity">Simplicity</a> 程序是树：根节点代表整个程序，每个节点执行一部分计算。具体来说，父节点可以访问子节点的计算并根据某个函数聚合子节点的计算结果。这个过程从叶节点开始，先由叶节点返回公钥和见证数据等常数值，然后自上而下聚合，直至在根节点计算出总的结果。</p><p><img src="/../images/from-miniscript-to-simplicity/chart2.jpg" alt="chart2"></p><p>与上述比特币脚本对应的 Simplicity 程序如上图所示。请注意它的结构与 Miniscript 的树结构相同。真正的 Simplicity 程序包更多内容（and、or、key 和 older 均由叫作组合子（combinators）的较小程序段组成），忽略了一些细节的 Simplicity 和 Miniscript 看起来差不多。</p><p>Simplicity 具有通用性，可以计算任意布尔函数。每个布尔函数都可以被视为一个接受或拒绝见证的花费条件。Simplicity 可以实现限制条款（covenants）、委托、零知识证明等等。虽然如此强大的表达能力令人望而生畏，但是我们可以检查程序的正确性。Simplicity 的语法是显式的，因此程序的功能一目了然。不会出现令人讨厌的意外。另外，树结构让静态分析和证明属性变得更容易。我们可以证明某个程序不仅执行成本低，而且正确编码了某个花费条件。我们使用的程序包虽然与 Miniscript 的相同，但是适用于更多程序。</p><p>不同于 Miniscript，Simplicity 需要软分叉才能在比特币上使用。它可以继 Bitcoin Script (Miniscript) 称为一种新型的 Taproot 叶节点。下一步是先在 Elements（一个开源平台，<a href="https://blockstream.com/liquid/">Liquid</a> 就是在这个平台上构建的）上实现 Simplicity 以证明 Simplicity 可以应用于比特币。这也会影响到最终的语言设计。</p><h2 id="连接两种语言"><a href="#连接两种语言" class="headerlink" title="连接两种语言"></a>连接两种语言</h2><p>我们正在搭建一座连接 Miniscript 和 Simplicity 的“桥”。Miniscript 的树结构在 Simplicity 中复制起来很容易，因此我们可以将比特币脚本转化成 Simplicity 程序，将 Miniscript 变成 Simplicity 的一个子集。你可以使用现有的脚本生成程序，检查程序和脚本在语法上是否等价，然后改进你的程序，表达超出 Miniscript 能力范围的内容。对于熟悉 Miniscript 的人来说，本文是一篇很棒的 Simplicity 入门介绍。在下一篇文章中，我们将详细介绍如何连接 Miniscript 和 Simplicity。</p><h2 id="树形结构引领未来"><a href="#树形结构引领未来" class="headerlink" title="树形结构引领未来"></a>树形结构引领未来</h2><p>像 Miniscript 这样的树形程序很容易阅读和分析。有大量工具作用于这些程序，帮助我们追踪其正确性。Simplicity 踩在 Miniscript 的肩膀上，使用树形结构实现任意计算。得益于树形结构，Simplicity 比 Miniscript 强大得多，但是性能依然良好。Simplicity 继承了 Miniscript 的优点，在享受树形结构优点的同时支持任意计算。</p><p>树形结构是未来的发展方向。我们正在稳步推动 Simplicity 成为现实。利用“桥”将 Miniscript 转化成 Simplicity 是一个良好的开始。关于“桥”的使用方式，请关注我们后续的文章。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">树形结构是未来的发展方向</summary>
    
    
    
    
    <category term="开发" scheme="https://www.btcstudy.org/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Miniscript" scheme="https://www.btcstudy.org/tags/Miniscript/"/>
    
  </entry>
  
  <entry>
    <title>LNURL-Auth：基于闪电网络的身份认证</title>
    <link href="https://www.btcstudy.org/2022/11/30/lightning-authentication-lnurl-auth/"/>
    <id>https://www.btcstudy.org/2022/11/30/lightning-authentication-lnurl-auth/</id>
    <published>2022-11-30T07:07:53.000Z</published>
    <updated>2023-01-12T06:01:27.475Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：heisenberg</em></p><p><em>来源：<a href="https://stacker.news/items/98600">https://stacker.news/items/98600</a></em></p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大多数人认为闪电网络是一个实现快捷低成本比特币交易的支付网络。但是，你知道你可以使用闪电网络钱包轻松、安全且匿名地登录某些服务吗？</p><h2 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h2><p>如今，互联网上最常见的身份验证方式是<strong>输入用户名和口令</strong>（译者注：大家习惯称为 “密码”）。这个概念已有数十年历史，一直保持良好运作。但是，它有什么缺陷？</p><p>为了方便起见，用户通常会选择容易被猜到或暴力破解的<strong>简单密码</strong>。或者，用户会为多个服务设置<strong>同一个密码</strong>。在后一种情况下，一旦某个用户的密码泄露，攻击者可以同时入侵这个用户在多个平台上的账号。攻击者只需在其它平台上尝试相同的密码组合。</p><h2 id="闪电网络如何用于身份验证？"><a href="#闪电网络如何用于身份验证？" class="headerlink" title="闪电网络如何用于身份验证？"></a>闪电网络如何用于身份验证？</h2><p>但是，我们能不能使用<strong>另一种</strong>安全的登录方式来取代用户名和密码呢？这现实吗？</p><p>本文将介绍 <strong>LNURL-auth 协议</strong>。LNURL 是一组扩展了闪电网络功能的协议（我们已经在关于<a href="https://stacker.news/items/65872">闪电网络地址</a>的文章中介绍了其中一个协议）。具体来说，LNURL-auth 负责的是登录部分。</p><p>这种登录方式实际是如何操作的？很简单，打开一个支持 LNURL-auth 技术的网站，用你的闪电网络钱包<strong>扫描二维码</strong>（就像过去支付发票那样），即可成功登录。就这么简单而已。这种登录方式背后的运作原理是什么？它安全吗？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>所有闪电网络钱包都有一个组成部分是私钥。就像在比特币网络中那样，私钥是一个绝对不能向任何人透露的<strong>随机数</strong>。谁知道你的私钥就证明谁拥有你的比特币。</p><p>在实际操作中，网站向你发送随机数据，你用自己的<strong>私钥</strong>签署该随机数据并返回签名和<strong>公钥</strong>。然后，网站验证你的签名，如果签名是正确的，则你的身份验证成功。这一切都依赖于你知道自己的私钥，而且你是它的唯一所有者。没有私钥就无法创建有效签名。</p><p>事实上，用于身份验证的私钥与用于证明比特币所有权的私钥不是同一个。身份验证私钥根据网站 URL 生成，因此不同网站使用的私钥不同。</p><p>有些初学者可能觉得这听起来很复杂，但实际上就是你的身份<strong>与你的私钥绑定</strong>而已。只要没有人偷走你的私钥，你只需扫描二维码即可登录各种服务。</p><p>你唯一要上心的就是<strong>保管好自己的私钥</strong>。通常情况下，你可以使用种子短语（用于找回主私钥的 12 至 24 个单词）。</p><h2 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h2><p>相比传统的用户名和密码登录方式，私钥登录有何<strong>优势</strong>？</p><ul><li>你不需要创建、记住或存储任何密码。</li><li>你甚至不需要填写用户名，你只需要“扫码”。</li><li>你的密码（这里指私钥）永远不会经过网络传输，因此不会被拦截。</li><li>针对每个服务生成的私钥不同，因此你的身份不可能在多个服务之间形成关联（例如，你使用同一个电子邮件或用户名）。</li><li>快速、简单</li></ul><p>有哪些<strong>劣势</strong>？</p><ul><li>目前为止，鲜有服务支持这种登录方式。</li><li>你必须拥有一个支持 LNURL-auth 技术的闪电网络钱包。</li><li>拥有了你的钱包的完整访问权限，就等于拥有了你的身份。</li><li>你有责任保管好自己的种子词。</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>上文已经说得很清楚，首先你需要一个闪电网络钱包。就本例而言，我强烈建议你选择非托管型钱包（<strong>确保私钥的所有权在你自己手中</strong>），例如，Phoenix 或 Breez。你也可以通过 Zeus 运行自己的节点。</p><p>BlueWallet 同样支持该功能，但它<strong>默认</strong>采用托管方式（即，由第三方代持私钥），因此我并不推荐。目前 Wallet of Satoshi 和 Muun wallets 都不支持 LNURL-auth 技术。</p><p>你必须正确<strong>备份</strong>你的钱包。一旦你丢失了钱包，你就会失去你的身份。当然了，你应该为访问钱包设置额外的身份验证方式（PIN、指纹、FaceID 等等）。</p><p>有人可能会觉得使用这种方式存储身份有些危险。但是，如果有攻击者入侵你的手机，绕过生物识别认证窃取你钱包中的身份，他也可以使用同样的方式窃取你存储在任意密码管理器里的密码。</p><p>就是这样 —— 你不需要使用钱包付款，你甚至不需要往这个钱包里存入比特币。</p><p>哪里可以尝试基于闪电网络钱包的登录方式？Stacker.News 就是其中一例。</p><p><img src="/../images/lightning-authentication-lnurl-auth/rl_auth.png" alt="LNURL-auth"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>基于闪电网络的身份认证是一个<strong>有趣的概念</strong>，用户只需扫描二维码即可登录，具有很高的安全性、匿名性，而且非常人性化。</p><p>但是，LNURL-auth 技术本身仍处于<strong>早期发展阶段</strong>。因此，我们需要等待一段时间来获得更广泛的支持，无论是在服务端还是钱包端。</p><p>与此同时，我还要强调的一点是，这种登录方式不涉及“真人识别”，任何人都可以创建无数密钥/钱包（即，身份）。因此，这个问题必须单独处理。</p><p>不管怎么说，试一试又不要钱。勇敢上吧！</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>等等，就这么结束了吗？如果你是极客，又想深入了解这类概念的话，不妨跟我一起从技术角度来看 LNURL-auth 技术。</p><p>每个非托管型钱包都有一个<strong>主私钥</strong>（如果没有，我们也有<a href="https://github.com/lnurl/luds/blob/luds/13.md">解决方案</a>）。派生路径 <strong>m/138’/0</strong> 包含所谓的 <strong>hashingKey</strong>。我们将 hashingKey 与服务 URL 一起放入 HMAC 函数：</p><pre><code>1output = HMAC-SHA256(hashingKey, domain from URL string)</code></pre><p>取输出开头 16 个字节，并将它们拆分成 4 个长度相等的部分，即可得到所谓 <strong>linkingKey</strong> 的派生路径。每个服务（URL）的 linkingKey 都是独一无二的。</p><pre><code>1linkingKey = m/138&#39;/&lt;part1&gt;/&lt;part2&gt;/&lt;part3&gt;/&lt;part4&gt;</code></pre><p>扫描二维码后，钱包会按 bech32 格式解码，得到一个 HTTPS 链接。例如：</p><pre><code>https://web.com?tag=login&amp;k1=random_data&amp;action=login</code></pre><p><strong>tag</strong> 参数告诉我们这是 LNURL-auth，<strong>action</strong> 参数注明行为是登录（也可以是注册等等）。此外，还有一个很重要的参数 <strong>k1</strong>，它包含了我们需要使用 <strong>linkingPrivKey</strong> 签署的长度为 32 个字节的随机数据。</p><p>同意登录对话框后，钱包会使用同一个 URL 进行响应，只增加了 <strong>sig</strong> 和 <strong>key</strong> 参数：</p><ul><li><p><strong>sig</strong> = 在 <strong>secp256k1</strong> 曲线上使用私钥 <strong>linkingPrivKey</strong> 签署的随机数据 <strong>k1</strong></p></li><li><p><strong>key</strong> = linkingKey 公钥</p></li></ul><pre><code>https://web.com?tag=login&amp;k1=random_data&amp;action=login&amp;sig=signature&amp;key=public_key</code></pre><p>最后，服务验证签名是否正确。验证通过后，服务会基于我们使用的 linkingKey 为我们分配身份。如果是注册，服务会为我们创建新的身份。</p><p>如果你想了解更多细节并阅读规范：</p><ul><li><p><a href="https://github.com/lnurl/luds/blob/luds/05.md">https://github.com/lnurl/luds/blob/luds/05.md</a></p></li><li><p><a href="https://github.com/lnurl/luds/blob/luds/13.md">https://github.com/lnurl/luds/blob/luds/13.md</a></p></li><li><p><a href="https://github.com/lnurl/luds/blob/luds/04.md">https://github.com/lnurl/luds/blob/luds/04.md</a></p></li></ul><p>（完）</p>]]></content>
    
    
    <summary type="html">身份验证私钥根据网站 URL 生成，因此不同网站使用的私钥不同</summary>
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/categories/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    <category term="LNURL" scheme="https://www.btcstudy.org/tags/LNURL/"/>
    
  </entry>
  
  <entry>
    <title>比特币至上主义是密码朋克精神的延续</title>
    <link href="https://www.btcstudy.org/2022/11/28/bitcoin-maximalism-is-cypherpunk-ethic/"/>
    <id>https://www.btcstudy.org/2022/11/28/bitcoin-maximalism-is-cypherpunk-ethic/</id>
    <published>2022-11-28T09:24:34.000Z</published>
    <updated>2023-01-12T06:01:27.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Jimmy Song</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/culture/bitcoin-maximalism-is-cypherpunk-ethic">https://bitcoinmagazine.com/culture/bitcoin-maximalism-is-cypherpunk-ethic</a></em></p><p><em>原文首发于 2022 年 10 月 31 日。</em></p></blockquote><p>今天是比特币白皮书日。大多数人认为，2008 年 10 月 31 日（比特币白皮书的发布日期）是比特币的诞生日。这是可以理解的，毕竟比特币白皮书发布和之后的比特币网络上线都是值得庆祝的大事。这几天虽然在历史上留下了浓墨重彩的一笔，却只是一场浩大运动的冰山一角。</p><p>密码朋克运动是鲜为人知的亚文化，孕育出了大量创新技术。比特币这样精巧的货币系统正是在这种背景下诞生的。若想了解比特币，我们要先了解其起源及其所有前身。</p><p>在本文中，我将简要介绍许多不同类型的实验，它们大多虽以失败告终，却为比特币的诞生埋下了伏笔。你会看到，孕育了比特币的文化仍在比特币系统中焕发出勃勃生机，但是不存在于山寨币和法币。比特币至上主义也可以说是密码朋克精神的传承。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>比特币的运作依赖许多创新技术，其中第一个就是<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥密码学</a>。公钥密码学是 Whitfield Diffie 和 Martin Hellmann 两位学者发明的。一种密钥交换协议正是以两位学者的名字命名的：<a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">ECDH</a> 是 Elliptic Curve Diffie-Hellman 的缩写。公钥密码学发明于 1976 年互联网诞生之际，比比特币早了 33 年。</p><p>公钥密码学的主要创新点是可以让使用者证明自己知晓某个秘密，却不需要公开这个秘密是什么。你是不是觉得听起来很像魔术？我也是这么觉得，而我研究公钥密码学已经长达 20 年。在不泄密的情况下证明你知道某个秘密从数学角度来说很合理，听上去却有点反直觉。尽管如此，这是有可能实现的。如今，公钥密码学是现代互联网和保障数字财产安全的基础。</p><p>从比特币的角度来看，公钥密码学的有趣之处在于非对称性。过去，为了确保数据传输的安全性，双方必须知道同一个秘密。在公钥密码学中，一方拥有一个秘密，另一个拥有一个公共标识符/密钥。这一创新实现了无需像传统方案那样共享秘密的 加密/解密，以及将私钥作为消息发送方标识的 签名/验证。</p><p>公钥密码学这一突破性研究成果经过了一段时间才实现商用。也正是这个挫折导致我们迈出了下一步。</p><h2 id="密码朋克邮件列表"><a href="#密码朋克邮件列表" class="headerlink" title="密码朋克邮件列表"></a>密码朋克邮件列表</h2><p>很多学术论文（就像 Diffie 和 Hellmann 的那篇）虽然写得很好，但是实际的工程到后来才真正实现。早期的互联网可以让陌生人相互合作。正是在这个阶段，社区开始形成。在这些社区中，最重要的莫过于<a href="https://mailing-list-archive.cryptoanarchy.wiki/">密码朋克邮件列表</a>。该邮件列表创建于 1992 年，旨在利用多种密码学技术为个人服务，不再局限于军事用途。</p><p>保守地说，密码朋克邮件列表对互联网的发展产生了一定影响。<a href="https://en.wikipedia.org/wiki/Marc_Andreessen">Marc Andreesen</a> 等密码朋克专注于打造网络浏览器。<a href="https://bitcoinmagazine.com/culture/bitcoin-julian-assange-fight-for-freedom">Julian Assange</a> 等人致力于揭露政府恶行。<a href="https://en.wikipedia.org/wiki/Adam_Back">Adam Back</a> 和 <a href="https://en.wikipedia.org/wiki/Nick_Szabo">Nick Szabo</a> 等人为比特币的诞生做出了贡献。</p><p>密码朋克邮件列表从文化层面突破了上一代的学术桎梏。比起实现会改善普通人生活的软件，Diffie、Hellmann 和 <a href="https://en.wikipedia.org/wiki/Ralph_Merkle/">Ralph</a> <a href="https://en.wikipedia.org/wiki/Ralph_Merkle/">Merkle</a> 等先驱者对写论文更感兴趣。如果说上一代学者是科学家，那么密码朋克就是工程师。</p><p><a href="https://nakamotoinstitute.org/static/docs/cypherpunk-manifesto.txt">《密码朋克宣言》</a>里有几句话已经成为经典。“密码朋克要写代码。”“我们必须捍卫自己的隐私，才能享有它。”</p><p>《密码朋克宣言》的总体基调是要为保护隐私性而创造工具。这一态度反映了密码朋克文化。我们需要利用密码学来维护我们天然的权利，而不是任由霸权者肆意掠夺我们的权利。</p><p>该宣言预见到了我们的数字生活最终将走向中心化。这是非常了不起的，毕竟那时的互联网连网页都没有，遑论网络商店、社交网络和直播了。彼时，互联网还只有电子邮件、IRC 和 Usenet 论坛。密码朋克却能预见到隐私性将成为未来的攻击向量。就像今天的比特币至上主义者，他们预见到了<a href="https://bitcoinmagazine.com/legal/the-dangerous-implications-of-cbdcs">以央行数字货币为基础的世界秩序将逐渐形成</a>。</p><p>尤其值得一提的是，密码学朋克意识到，货币是一个巨大的安全漏洞。如果你的购物信息泄露，你很容易遭到攻击，因为这是你最私密的数据。引用《密码朋克宣言》中的话来说：</p><p>“我们正在利用密码学、匿名邮件转发系统、数字签名和电子货币捍卫我们的隐私。”</p><h2 id="密码学与货币的首次碰撞"><a href="#密码学与货币的首次碰撞" class="headerlink" title="密码学与货币的首次碰撞"></a>密码学与货币的首次碰撞</h2><p>利用密码学创建货币的首个试验性项目是 David Chaum 的 <a href="https://en.wikipedia.org/wiki/Ecash">Ecash</a>。Diffie 和 Hellmann 发明公钥密码学后仅过了 6 年，Chaum 就萌生了一个想法：可以发明一种匿名的不记名数字现金，前提是使用者必须信任发行方。Ecash 系统很棒。你可以通过一种叫作“盲化”的过程在不暴露自己身份的情况下以数字方式转移收据。Ecash 可以由一方转让给另一方，无需记录货币流向。因此，Ecash 的创新之处在于，你可以在不知道任何转账方身份的情况下验证货币是否真的来自发行方。</p><p>早期对隐私性的重视是密码朋克精神的重要组成部分，因为密码朋克早就认识到，数字足迹是永久的，而物理足迹不是。</p><p>David Chaum 又花了 14 年时间，创办了 <a href="https://en.wikipedia.org/wiki/DigiCash">DigiCash</a> 来将自己的想法投向市场。他认为 Ecash 可以成为一种隐私性的互联网货币。遗憾的是，没有银行愿意成为 Ecash 的发行方，因为 Ecash 无法满足它们对用户的强烈控制欲。可识别身份的信用卡交易相比起来更胜一筹，例如，PayPal 等公司就充分利用了信用卡的优势。</p><p>DigiCash 的失败让很多密码朋克感到挫败。如今，线上交易的标准付款方式不是隐私性的数字现金，而是会将用户消费信息泄露给第三方的信用卡。清楚的一点是，Ecash 方案中有一个中心方，即，发行货币的银行。中心化是这个系统的一大弱点，会将隐私性、安全性和自我主权毁于一旦。换言之，如果将 Ecash 与法币关联，Ecash 系统会受到法币规则的影响。</p><h2 id="Liberty-Dollars-和-E-gold"><a href="#Liberty-Dollars-和-E-gold" class="headerlink" title="Liberty Dollars 和 E-gold"></a>Liberty Dollars 和 E-gold</h2><p>除此之外，还有其它隐私保护型货币的尝试之举。其中有两个运行了长达 10 年之久：<a href="https://cs.stanford.edu/people/eroberts/cs201/projects/2010-11/Bitcoins/liberty-dollars.html">Liberty Dollars</a> 和 <a href="https://en.wikipedia.org/wiki/E-gold">e-gold</a>。不同于信用卡，这两个项目具有私密性。</p><p>可惜这两个项目都存在同样的严重缺陷。二者都是中心化的。2008 年，这两个项目均被关停，很多人因未遵守 AML/KYC 法规而被司法部<a href="https://en.wikipedia.org/wiki/Liberty_dollar_(private_currency)">判刑</a>。</p><p>说句题外话，政府实体实现这类中心化方案大约也需要 10 年。我猜测实现中心化山寨币所需的时间也差不多。</p><h2 id="去中心化数字账本"><a href="#去中心化数字账本" class="headerlink" title="去中心化数字账本"></a>去中心化数字账本</h2><p>1998 年，Wei Dai 提出了一种用于互联网货币系统的分布式公共账本。他在关于 <a href="https://nakamotoinstitute.org/literature/b-money/">b-money</a> 的论文中提出了一个基于非特定计算难题的系统。遗憾的是，他没有想到一个良好的解决方案，来保证难题的客观性，以及防止货币无限量发行。</p><p>Wei Dai 的 b-money 可以说是区块链的雏形，但是因为货币发行问题没有落地。如果解决难题 X 会让你在账本上得到一些货币，这些货币又是有价值的，系统会产生无限量的货币。Wei Dai 不知道如何让这个系统中的货币变得稀缺。</p><h2 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h2><p>那么，如何赋予数字货币稀缺性？密码朋克在意想不到的方向上找到了一个解决方案。</p><p>Adam Back 试图解决的问题与货币无关。当时，密码朋克正在研究一种能够保护邮件隐私性的邮件转发器，采用了分布式设计，因为中心方的存在会违背隐私保护的目地。但是，一个本质上匿名的邮件系统意味着，一旦发生拒绝服务攻击（也就是垃圾邮件），邮件转发器就会瘫痪。</p><p>由于没有一个中心机构来过滤垃圾邮件，Adam Back 想出了一个创新解决方案：增加电子邮件的计算成本。这个解决方案虽然无法彻底杜绝拒绝服务攻击，但至少会大幅增加其成本。这个方案叫作 <a href="https://en.wikipedia.org/wiki/Hashcash">Hashcash</a>，能够有效过滤大量垃圾邮件。</p><p>2002 年，Hashcash 引起了另一群密码朋克的兴趣。在密码朋克中，有一个群体对数字货币非常感兴趣。Nick Szabo、Hal Finney 和 Wei Dai 均在其列。当他们在密码朋克邮件列表上看到 Hashcash 时，他们立马就意识到 Hashcash 在解决数字稀缺性问题上的潜力。</p><p>Hahcash 具备理想的特性。它是为去中心化系统设计的，解决了零边际成本的问题。尽管如此，他们还没有想好该如何发挥它的作用。</p><h2 id="可重用工作量证明（RPOW）"><a href="#可重用工作量证明（RPOW）" class="headerlink" title="可重用工作量证明（RPOW）"></a>可重用工作量证明（RPOW）</h2><p>至此，我们已经拥有了实现隐私型数字货币所需的大部分要素。Hal Finney 认识到，有了公钥密码学、数字账本和工作量证明，至少足以在概念上证明数字货币的可行性。这就是 2004 年实现的<a href="https://nakamotoinstitute.org/finney/rpow/">可重用工作量证明</a>。</p><p>可重用工作量证明的基本思路是，任何人都可以提交一个难度足够高的工作量证明，以获得中心账本上一定数量的代币。该账本可以通过货币系统中的交易更新。它不是分布式的，因为交易有效性证明靠的是验证运行中心服务器的计算机。硬件是众所周知的，用户可以查询硬件上运行的账本来看它是否存在作弊情况。</p><p>Hashcash 与比特币非常接近，但是依然存在中心化或单点故障问题。首先，计算机是由 IBM 生产的，而软件依赖于硬件的可审计性。将来某一天，IBM 可能会操控其生产的硬件。其次，用户必须信任中心账本会一直保持在线。中心化服务的问题在于，它们有可能也确实会下线，导致系统彻底停摆。当然了，这也是 Solana 等山寨币的主要问题。</p><p>再强调一次，中心化是不可能克服的弱点。</p><h2 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h2><p>2008 年，<a href="https://bitcoinmagazine.com/guides/who-created-bitcoin">中本聪</a>将上述想法相融合，创造了我们如今所知的比特币。除此之外，中本聪想出了令人拍案叫绝的创新点：减半计划表、难度调整和将工作量证明与账本结合。</p><p>将这三个创新点结合不仅实现了真正的稀缺性，而且免去了对中心方的需求。获取货币的方式不再是简单地提供工作量证明，而是和全网其他参与者一起竞争寻找某个工作量证明。减半和供应计划表保证了发行上限。这是人类首次真正实现数字稀缺性。</p><p>多年来，密码朋克都在坚持探索隐私型数字货币解决方案，这是一个缓慢而稳步的过程。最开始的 Ecash 是美元的补充。之后的 b-money 使用账本追踪一种纯数字资产。 再之后的工作量证明实现了不可伪造的价值。最后，减半计划表和难度调整与用来发行新代币的工作量证明机制相结合严格限制了发行数量。</p><h2 id="自我主权文化"><a href="#自我主权文化" class="headerlink" title="自我主权文化"></a>自我主权文化</h2><p>现在我们终于可以开始分析当下的比特币文化了。密码朋克缔造并延续了一种精神：不只局限于构建，还要消除安全威胁。过去 15 年来，屡屡失败的数字货币尝试带给我们的宝贵经验是：中心化是一大安全威胁。正是中心化导致 Chaum 的 Ecash 失败，b-money 和 RPOW 运行不良，让法币变成如此不安全的资产。比特币的诞生是必要的，因为其它系统没有运作起来。</p><p>稳定币实际上是对 Ecash 的尝试，但更糟糕的是，它们的隐私保护能力有限。山寨币是一种中心化承诺，为密码朋克所深恶痛绝。比特币是唯一延续自我主权精神的数字货币。山寨币会固守中心化，永不放弃，因为其控制者可以借此获得金钱和权力。</p><p>山寨币反映了其创始人的价值观。教授或学者创造的代币在理论上可行，实际却行不通。风投机构或企业创造的代币以牟利为目的，几乎没有向用户提供自我主权乃至价值。技术专家大都瞎搞一气，不太关心如何实现自我主权。只有密码朋克才能创造出比特币。</p><p>追求自我主权、减少攻击面、关注安全和隐私是密码朋克的信仰内核。比特币的诞生既不为追名逐利，也不为带来行业巨变，而是出于一个更加质朴的目的 —— 保有我们创造出的价值，确保它们不被夺走。</p><p>比特币至上主义背后的思想是：一方面，货币具有网络效应；另一方面，比特币凭借其去中心化和价值储藏特性胜出，因为没有哪个实体可以对比特币征税或窃取其价值。比特币至上主义是对密码朋克自我主权信仰的延伸。</p><h2 id="继承传统"><a href="#继承传统" class="headerlink" title="继承传统"></a>继承传统</h2><p>继承密码朋克传统是不小的责任。密码朋克站在反对政府数字领域暴政的第一线。在对抗政府的<a href="https://en.wikipedia.org/wiki/Crypto_Wars">加密战争</a>中，他们是先锋部队。阿桑奇是密码朋克并非巧合。如今，这场战争已经迅速蔓延到央行数字货币、金融监管等领域，比特币支持者成了先头兵。</p><p>从这个意义上来说，山寨币拥趸太过怯懦。他们愿意出卖自己的灵魂，服从政府的任何要求，为了保住自己的寻租地位卑躬屈膝。山寨币是缺少密码朋克精神的比特币复制品。它们是低劣的仿制品 —— 在代码上如此，在文化层面上亦如此。</p><p>作为比特币支持者，我们延续着密码朋克传统，也就是写代码。人不能躺在过去的功劳簿上沾沾自喜。</p><p>山寨币拥趸是空谈派，比特币支持者是实干派。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">山寨币拥趸是空谈派，比特币支持者是实干派。</summary>
    
    
    
    
    <category term="密码朋克" scheme="https://www.btcstudy.org/tags/%E5%AF%86%E7%A0%81%E6%9C%8B%E5%85%8B/"/>
    
  </entry>
  
  <entry>
    <title>RGB 魔法：比特币上的客户端合约</title>
    <link href="https://www.btcstudy.org/2022/11/27/rgb-magic-client-contracts-on-bitcoin/"/>
    <id>https://www.btcstudy.org/2022/11/27/rgb-magic-client-contracts-on-bitcoin/</id>
    <published>2022-11-27T12:36:02.000Z</published>
    <updated>2023-01-12T06:01:27.490Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Federico Tenga</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/rgb-magic-client-contracts-on-bitcoin">https://bitcoinmagazine.com/technical/rgb-magic-client-contracts-on-bitcoin</a></em></p></blockquote><p><img src="/../images/rgb-magic-client-contracts-on-bitcoin/image3.png" alt="Image source"></p><p style="text-align:center">- <a href="https://mashable.com/ad/article/history-of-color">图片来源</a> -</p><p>“智能合约” 这个术语的历史比区块链和比特币还更久。它第一次出现是在 <a href="https://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/smart.contracts.html">Nick Szabo 于 1994 年出版的文章</a>里，该文将智能合约定义为一种 “计算机化的交易协议，可以执行合约的条款”。虽然从定义上来说，得益于比特币的脚本功能，比特币从一开始就支持智能合约，但这个词是因为以太坊的支持者才火起来的，他们调整了智能合约原本的定义，成了 “可以被一个全局共识网络的所有节点冗余式执行的代码”。</p><p>虽然将代码的执行委托给一个全局共识网络有其优势（例如，易于部署无主合约（unowed contracts）；这样的合约的一个例子是热门的自动化做市商（AMM）），但这样的设计也有一个重大缺陷：缺乏可扩展性（以及隐私性）。如果网络中的每个节点都必须冗余式地运行同一段代码，可以运行的代码数量就只能保持较低水平，否则会过度地提高运行节点的成本（因此阻碍去中心化）。</p><p>那么，我们是否可以设计出一种系统，其合约的条款仅由参与方执行和验证，而不是由所有的网络成员来验证呢？我们设想一家希望发行股票的公司的例子。与其将发行合约公开放在一个全球账本上、使用这个账本来跟踪这些股份在未来的所有权转移情况，我可以直接私密地发行股份并将进一步转让的权利传递给买方。然后，转让所有权的权利可以传递给每一个新的所有权人，就像修改最初的发行合约一样。如此一来，每一个所有权人都可以独立地验证自己收到的股票是真实的，办法就是阅读最初的合约并验证转移股份的所有操作都遵循了合约中的规则。</p><p>这不是什么新鲜玩意儿，在政府的登记处流行之前，人们正是用这种办法来转移地产的。举个例子，<a href="https://en.wikipedia.org/wiki/English_land_law">在英国</a>，直到上世纪 90 年代开始，地产所有权的转移才强制注册。也就是说，英格兰和威尔士至今仍有 15% 的土地是没有注册的。如果你要购买一块没有注册的土地，你不是去登记处查证卖方是不是真正的所有权人，而是要验证至少 15 年内的所有权转移链条没有缺漏（这个时长足以假设卖方拥有充足的所有权）。这样做的时候，你需要确保每一次所有权转移都是正确执行的，并且用于之前交易的所有抵押贷款都已经还清了。这种模式的优势是提高了所有权的隐私性，而且你不必依赖于政府土地登记处的维护者。另一方面，对买方来说，这让验证卖方所有权的工作复杂很多很多。</p><p><img src="/../images/rgb-magic-client-contracts-on-bitcoin/image1.png" alt="Title deed of unregistered real estate propriety"></p><p style="text-align:center">- <a href="https://www.bestcompliance.co.uk/service/epc-for-listed-buildings/">图片来源</a>：未登记的不动产权的确认书 -</p><p>那么，如何优化这种未登记的地产的转让呢？首先，要把它电子化。如果用计算机可以运行的代码来验证所有权转移的全部历史都符合最初的合约规则，买卖就会变得快捷和便宜许多。</p><p>其次，为了避免卖方一房多卖，必须实现一套发布证明系统。举个例子，我们可以实现一条规则：每一次所有权的转移都必须在一份知名报纸的一个特定位置刊登（例如：将所有权转移操作的哈希值放在纽约时报的头版右上角）。因为你没法在同一个地方重复刊登相同的哈希值，自然也就不能重复花费。但是，使用著名的大报纸也有不利之处：</p><ol><li>为了验证，你必须购买一大捆的报纸。这不太实际。</li><li>每一个合约都需要在报纸上有一个专属的位置。这不便于扩大吞吐量。</li><li>报纸的编辑很容易就可以审查你，甚至在你的位置放置随机的哈希值来模拟重复花费，让潜在的买家都认为你的资产已经卖掉了，从而阻止他们购买你的资产。你必须信任报纸的编辑。</li></ol><p>因为这些原因，我们需要找到更适合发布所有权转移证据的地方。那么，还有什么地方比比特币区块链 —— 一个业已建立的可信任的公开账本、带有保持抗审查性和去中心化的强大激励 —— 更合适呢？</p><p>如果我们使用比特币，我们不应该使用区块的固定位置（比如区块中的第一笔交易，即 coinbase 交易）作为发布所有权转移承诺的地方，因为，就像纽约时报的编辑（可以决定报纸的内容），矿工也可以操纵它。更好的办法是在一笔预定义的比特币交易中放置承诺，更具体来说，是使用关联着已发行的资产的所有权的 UTXO 来发起的一笔交易。一项资产与一个比特币 UTXO 的联系，既可以通过发行资产的合约来建立，也可以在所有权的后续流转中建立 —— 每次流转都可以指定某个 UTXO 作为被转移的资产的容器。这样一来，我们就清晰地定义了所有权转移的义务应该放在哪里（即，放在源自特定 UTXO 的比特币交易中）。任何运行比特币节点的人都可以独立地验证这个承诺，而且没有矿工和其它实体能够审查或阻止这种资产转移方式。</p><p><img src="/../images/rgb-magic-client-contracts-on-bitcoin/image2.jpg" alt="transfer of ownership of utxo"></p><p>因为在比特币区块链上我们只发布了所有权转移的承诺，不包括转移的内容本身，所以卖方需要一条专门的信息通道，向买方提供证明其产权真实性的所有证明。这可以用许多方式来实现，甚至可以打印出证明、用信鸽来传送，虽然有点不实际，但也算能够胜任。但是，要避免审查和隐私性降级，最好的选择莫过于建立一条直接的点对点加密信道；与信鸽相比，还有易于跟验证证据的软件集成的优势。</p><p>上述基于客户端验证的合约和所有权转移模式，正是 RGB 协议所实现的东西。有了 RGB，你可以创建一套合约，定义资产的权利、将资产分配给一个乃至多个 UTXO 并指定这些资产的所有权可以如何转移。合约可以从一套模板（叫做 “方案（schema）”）开始创建，合约的创建者只需调整参数和所有者权利，就像传统的法律合约做的那样。当前，RGB 协议有两类方案：一种用于发行同质化代币（<a href="https://github.com/RGB-WG/rust-rgb20/tree/master/src">RGB20</a>），另一种用于发行收藏品（<a href="https://github.com/RGB-Tools/rust-rgb21">RGB21</a>）；但在未来，人们无需更改协议层，就能以免信任的方式开发出更多方案。</p><p>举一个更加现实的例子，一种同质化资产（例如公司股票、稳定币，等等）的发行者可以使用 RGB20 模板，创建一个定义了发行多少代币、资产的名称并携带额外的元数据的合约。然后，它可以定义哪些比特币 UTXO 有权转移被创建的代币的所有权，并分配其它权利给其它 UTXO（例如增发权和重命名资产的权利）。每一个收到由此合约创建的代币的客户端，都可以验证创始合约的内容，并验证自己收到的代币在历史上的每一次所有权转移都遵守了创始合约的规则。</p><p>那么，今天我们能拿 RGB 来干什么呢？首先，也是最重要的，它可以用于发行和转移代币化的资产，而且相比现在其它所有方案，其可扩展性和隐私性都要更好。在隐私性上，RGB 得益于所有转让相关数据都保存在客户端的做法，区块链的观察者无法从区块链上抽取出关于用户的金融活动的任何信息（甚至无法区分包含了 RGB 承诺的交易和普通的比特币交易）；此外，资产的接收方可以仅跟发送方分享盲化的 UXTO（即 TA 希望用以承接资产的 UTXO 拼接一个随机数后的哈希值），而不是 UTXO 本身，所以转让者也无法监控接收方在未来的金融活动。为了进一步提高用户的隐私性，RGB 还使用了 bulletproof 密码学机制来隐藏历史上的资产转让数额，如此一来，未来的资产所有权人对以往所有权人的金融活动也只能形成模糊的认识。</p><p>至于可扩展性，RGB 也有优势。首先，绝大部分数据都在链下保存，区块链仅用于保存承诺，这就减少了需要支付的手续费，同时也意味着每个客户端都只验证跟自己相关的转让历史，而无需验证一个全局网络的所有活动。因为 RGB 转账依然需要发起比特币交易，所以能够节约的手续费看起来很少，但当你引入交易批处理技术后，这部分节约很快会变得非常可观。实际上，你可以在一笔比特币交易中放置一个承诺，将一个 UTXO 相关的所有代币（更广义来说是 “权利”）转移给任意数量的接收者。假设你是一个服务提供商，需要同时支付给多名客户；有了 RGB，你就可以在一笔比特币交易中承诺对几千名要求不同资产的客户的几千笔转账，让每一笔支付的边际成本都变得微不足道。</p><p>低价值资产的发行者可使用的另一种节约手续费的机制是，在 RGB 中，发行资产并不需要支付手续费。因为创建一个代币发行合约并不需要在区块链上承诺。一个合约只是定义了新发行的资产要分配给哪些已经存在的 UTXO。所以，如果你是一名艺术家，希望创建一些收藏品代币，你可以免费发行任意数量的代币，仅在买方出现并请求把代币转移给他们的 UTXO 时才需要支付比特币手续费。</p><p>此外，因为 RGB 是建立在比特币交易上的，它也跟闪电网络兼容。虽然在撰文之时还尚未实现，但创建资产专属的闪电通道和路由系统，是可以做到的，就类似于正常的闪电交易运作的方式。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>RGB 是一个突破性的创新，使用全新的范式开启了新的应用场景。但是，现在我们有什么工具可用呢？如果你想要实验这项技术的核心，你应该直接尝试 <a href="https://github.com/RGB-WG/rgb-node">RGB 节点</a>。如果你希望在 RGB 上开发应用，有不想深入协议的复杂性，你可以使用 <a href="https://github.com/RGB-Tools/rgb-lib">rgb-lib 库</a>，它为开发者提供了一个简单的接口。如果你想尝试发行和转移资产，你可以试用 <a href="https://play.google.com/store/apps/details?id=com.iriswallet.testnet&hl=en&gl=US">Iris Wallet（Android）</a>，这款钱包的代码也是<a href="https://github.com/RGB-Tools/iris-wallet-android">开源的</a>。如果你想学习 RGB，你可以看看这份<a href="https://github.com/fedsten/rgb-resources">资源列表</a>。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">相比现在其它所有方案， RGB 的可扩展性和隐私性都要更好</summary>
    
    
    
    
    <category term="RGB" scheme="https://www.btcstudy.org/tags/RGB/"/>
    
  </entry>
  
</feed>
