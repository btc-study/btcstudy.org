---
title: '使用 Ecash 票据的谨慎日志合约'
author: 'conduition'
date: '2026/01/23 18:58:44'
cover: ''
excerpt: '本文要介绍一种使用 Chaumian Ecash 来承诺一次条件式支付的方法'
tags:
- Ecash
- Discreet-Log-Contract
---


> *作者：conduition*
> 
> *来源：<https://conduition.io/cryptography/ecash-dlc/>*



本文要介绍一种使用 [Chaumian Ecash](https://en.wikipedia.org/wiki/Ecash) 来承诺一次条件式支付的方法，它使用一个 Ecash 铸币厂作为一个盲化但受信任的中介。

**2024 年 5 月 29 日编辑：**

我已经[向 Cashu 规范提交了一项提议](https://github.com/cashubtc/nuts/pull/128)，可以在 Cashu 铸币厂上支持谨慎日志合约（DLC）。该协议就基于本文的内容。

## 前置知识

- [椭圆曲线数学基础](https://conduition.io/cryptography/ecc-resources)
- [谨慎日志合约](https://bitcoinops.org/en/topics/discreet-log-contracts/)（非必需，但有用）
- [Ecash](https://en.wikipedia.org/wiki/Ecash)（非必需，但有用）

已经熟悉 Ecash 和 DLC 了？那么你可以跳过前面的介绍了。

## 记号

在整篇文章中我们都会使用这些记号。

| 记号                 | 含义                                                         |
| -------------------- | ------------------------------------------------------------ |
| $G$                  | [secp256k1 椭圆曲线的基点](https://bitcoin.stackexchange.com/questions/58784/how-were-the-secp256k1-base-point-coordinates-decided)。 |
| $q$                  | [secp256k1 椭圆曲线的阶](https://crypto.stackexchange.com/questions/53597/how-did-someone-discover-n-order-of-g-for-secp256k1)。曲线上有 $q - 1$ 个有效的非零点，再加一个 “无限” 点（也就是零点）。 |
| $x \leftarrow  Z_q $ | 在整数模 $q$ 的集合中随机采样。请注意，在采样时排除了零。    |
| $a \parallel  b$     | 拼接字节串 $a$ 和 $b$ 。                                     |

## Ecash

基于比特币的 [Chaumian Ecash](https://en.wikipedia.org/wiki/Ecash) 实现最近吸引了许多开发者的注意，并且不无理由：通过复兴一种已经得到充分研究的技术，我们可以给普通用户提供大量的易用性提升，让比特币赋能的支付系统对企业和客户都更好用。

Ecash 铸币厂会发行不同面额的 *Ecash Note（Ecash 票据）*；之后，这些票据可以在铸币厂处赎回一些同质化的商品或服务（比如比特币）。从概念上来说，这跟真实世界中历史上的银行非常相似，他们会接受客户存入一些同质化的资产，比如白银和黄金，然后为客户发放多种面额的 *实体票据*（纸钞或硬币），这些票据也能也带来重新申领相等数额的实体资产。

在基于比特币的 Ecash 铸币厂中，铸币厂接受比特币存款，然后发行 Ecash 票据；这些票据在未来也能赎回比特币，只要这个铸币厂保持偿付能力、还在正常运营。

Ecash 铸币厂的基本原理是：

- **真实性** —— Ecash 铸币厂可以确定，其他人无法伪造他创建的 Ecash 票据，所以，当一个储户要赎回一个票据是，铸币厂是安全的，不会受到欺诈。
- **同质性** —— 储户可以确定，他们收到的 Ecash 票据是是匿名的、可互换的。因为它的模式不是铸币厂给储户一个不记名的 token（那样的话，铸币厂就必须能够识别这些 token ，才不会在储户要求赎回时受到欺诈），而是储户与铸币厂合作、通过一种聪明的密码学协议（叫做 “*盲签名* ”）来 *盲化* 储户收到的 Ecash 票据。

### 这是怎么回事？

设想一家铸币厂，持有一个私钥 $m$ ，以及对应的公钥 $M = mG$ 。

再设想 Alice，她是一位用户，向上述 Ecash 铸币厂存入了 1 美元，并希望能得到一个等价的 Ecash 票据。

设 $H'(x) \rightarrow P$ 是一种哈希函数，可以将输入 $x$ 映射为 secp256k1 椭圆曲线上的一个点 $P$，从而，$P$ 的离散对数（它背后的私钥）是无法知晓的。[这里就有这样的哈希函数的一个例子](https://github.com/cashubtc/nuts/blob/6024402ff8bcbe511e3e689f6d85f5464ecc3982/00.md#hash_to_curvex-bytes---curve-point-y)。

1. Alice 取出随机的标量 $r \leftarrow Z_q$ 。

2. Alice 选出一个随机的秘密值 $x$ 并将它哈希成一个点 $Y = H'(x)$ 。

3. Alice 把点 $A = Y + rG$ 交给铸币厂

4. 铸币厂盲化签名 Alice 盲化点：$Q = mA$ 并将 $Q$ 返回给 Alice，这个点叫做 “*承诺* ”。

5. Alice 解盲 $Q$ ，得到一个证据 $Z$ 。
   $$
   \begin{aligned}
   Z &= Q - rM \\\\
   &= mA - rM \\\\
   &= m(Y + rG) - rmG \\\\
   &= mY + rmg - rmG \\\\
   &= mY
   \end{aligned}
   $$

这一对数值 $(x, Z)$ 就是一个不记名的 token，Alice 可以随时拿来向铸币厂赎回。但因为只有 Alice 知道 $r$ 和 $x$ ，所以只有她知道这个 token  $(x, Z)$ ，并且，没有人可以将这个 token 和她的存款关联起来 —— 至少，从数学上看不出有什么关联。

在 Alice 赎回的时候，为了验证这个 token 的真实性，铸币厂可以检查：
$$
Y = H'(x) \\\\
mY = Z
$$
某人能构造出 $Z$ 的唯一一种别的方法就是计算出 $yM = mY = myG = Z$ ，也就是找出 $yG = Y$ 的离散对数 $y$ 。可是，Alice 所用的哈希成点函数 $H'(x)$ 已经保证了无法知道知道的 $y$ 。所以，Alice 能够知晓 $Z$ 的唯一办法就是，铸币厂试用自己的密钥 $m$ 创造了 $Z$ 。

上述就是 Ecash 的本质，但还有一些疑点要清理：

- 单靠密码学不足以对抗 “重放攻击”（或者说“重复花费”）。Alice 可以多次提交 $(x， Z)$ ，因此，铸币厂必须记忆哪个 $Z$ 已经赎回过了。
- 只有铸币厂自己可以验证自己的 Ecash 票据。所以，当 Alice 要用 Ecash 票据给别人支付时，收款方必须直接联系铸币厂、将收到的票据换成一个新的票据，才能确保收款安全。也就是说，直到收款方成功将 Alice 支付过来的 Ecash 票据兑换成新的（只有 TA 自己知道的）票据之前，都不能算支付完成了。
- 迄今为止，我假设了铸币厂只有一对密钥 $m$ 和 $M = mG$ 。但在现实中，铸币厂需要一种办法来区分不同面额（1 美元、5 美元、50 美元，等等）的票据，而 Ecash 铸币厂实现这一点的常见做法就是准备 *多个公钥*：每个公钥对应一个面额。

## 谨慎日志合约

“[谨慎日志合约](https://bitcoinops.org/en/topics/discreet-log-contracts/)”（缩写为 “DLC”）是一种强大的密码学工具，可以带来原生于比特币的条件式支付。

所谓 “条件式支付”，就是一笔支付可以根据预先同一的结果（或者说条件），给多个收款方分发不同的数额。这种支付可能是单方注资的，也可能是多位参与者合作注资的。案例包括体彩投注、保险合约、期货合约、纸牌，等等。

DLC 这个话题很深，所以我在这里只会几笔带过。网络上已经有不计其数的资源解释了 DLC 是如何在比特币上运行的。

在这里，我想讲的是，让 DLC 能够在比特币上开启条件式支付的相同的根本机制，如何 *同样* 为 Ecash 带来条件式支付，同时能极大提升参与者的隐私性。其可扩展性，也显著好于在区块链内或在闪电网络中开启 DLC 。

所以，我不会全面介绍 DLC ，只会提炼出理解本文所需的最少量的概念。

DLC 要求存在一个或多个可以信任的 *断言机（oracle）*，由他们来见证一些事件的真正结果。这些断言机是公开运行的，先为将来的事件广播带有签名的*公告*，然后，在事件的结果揭晓时，会广播一条密码学 *见证消息（attestation）* 。根据设计，断言机不知道有多少人在订阅其见证消息，也不知道他们都是谁。

- 把 “*公告* ”想成是一个可能结果的清单，每一种（索引号为 $i$ 的）结果都有对应的一个锁定点 $K_i$
- 将 “*见证消息* ”理解成揭晓那些锁定点中 *唯一一个*（对应于真正结果的那个）的离散对数，也即，揭晓 $k_iG = K_i$ 的私钥 $k_i$
- 如果断言机揭晓了超过一个锁定点的私钥，他们作为断言机的长期信誉就会马上崩塌，并且任何欺诈都可以简洁地证明。

*上述讲解是一种简化，并不是 DLC 的真实工作方式* 。在真实的 DLC 中，断言机会有一个提前宣布的 nonce 点来发布一条签名。如果你想知道 DLC 实际上是怎么工作的，我建议你阅读 [Tadge Dryja 的原创论文](https://adiabat.github.io/dlc.pdf)。但想要理解本文，上述概念框架就足够了。

## DLC + Ecash

我们现在假设，已经有了一些公开的断言机，承诺会为某一个事件的 3 种可能结果所对应的锁定点 $\{K_1, K_2, K_3\}$ 揭晓一个锁定秘密值。如果实际发生的结果的索引号为 $i$ ，那么这个断言机就会揭晓 $k_iG = K_i$ 的私钥 $k_i$ 。

Alice 和 Bob 希望对这个事件下注，但不希望要靠自觉来让输家付钱，所以双方都投入 100 美元来创建一个 DLC 。

- 如果揭晓的是 $k_1$ ，那么 Alice 就赢走所有的 200 美元。
- 如果揭晓的是 $k_2$ ，那么 Bob 就赢走所有的 200 美元。
- 如果揭晓的是 $k_3$ ，那么 Alice 和 Bob 各自获得全部退款（100 美元）。
- 如果到了时间点 $t$ 断言机还没有揭晓任何秘密值（超时情形），那么双方都获得退款。

Alice 和 Bob 可以在区块链内创建一个 DLC 来执行这个赌约，那当然是完全安全和免信任的，但可能不是那么划算（因为比特币的数量很少）。链内 DLC 也有隐私性影响：Alice 和 Bob 的钱币，从此将永远被关联起来。

如果 Alice 和 Bob 都信任一个共同的 Ecash 铸币厂，他们可以构造同样的赌约，依然不需要信任对方，而且也不会把赌约的内容暴露给这个铸币厂。因此，铸币厂无法基于赌约的 *类型* 来审查他们的 DLC （不论是保险合约还是纸牌游戏，对于铸币厂来说看起来没有什么分别）。虽然铸币厂能知道最终的支付结构，以及这个 DLC 涉及的金额，但无法知晓其它没有用到的可能结果及其支付结构。

### 鸟瞰图

概要地说：

- Alice 和 Bob 将合作构造一个预先注资的 DLC 包裹，由 Alice 发送给铸币厂。
- 铸币厂注册这个 DLC ，并等待某人从其中一个结果终领取奖金。
- 一旦某个结果被领取，铸币厂就锁定结果，等待其它可能的付款。
- 所有付款都被领取之后，铸币厂可以从记忆中删除这个 DLC 。

### 协议

- 令 $H(x)$ 是一种安全的哈希函数，比如 SHA256 。
- 令  $H'(x) \rightarrow P$ 是一种将输入 $x$ 映射成 secp256k1 上的点 $P$ 的哈希函数，它让 $P$ 的离散对数不可知晓。[这里就有这样的哈希函数的一个例子](https://github.com/cashubtc/nuts/blob/6024402ff8bcbe511e3e689f6d85f5464ecc3982/00.md#hash_to_curvex-bytes---curve-point-y)。
- 令 $d_a$ 是 Alice 的支付秘密值，其对应的公开支付哈希值 $D_a = H(d_a)$ 。
- 令 $d_b$ 是 Bob 的支付秘密值，其对应的公开支付哈希值 $D_b = H(d_b)$ 。

1. Alice 取样出一个随机的 “结果盲化秘密值”。
   $$
   b \leftarrow Z_q
   $$
   她用这个盲化秘密值来掩盖结果锁定点。
   $$
   \begin{aligned}
   K'_1 = K_1 + bG \\\\
   K'_2 = K_2 + bG \\\\
   K'_3 = K_3 + bG 
   \end{aligned}
   $$
   这一盲化层将向铸币厂混淆每一个 $K_i$ ，从而，铸币厂无法基于赌约的内容来审查 Alice 和 Bob 。

   > 为什么 Alice 做这些的时候可以不需要 Bob 参与？
   >
   > Alice 可以独自生成盲化秘密值 $b$ 并执行结果盲化、不使用来自 Bob 的输入，这可能看起来有些奇怪。难道这不会让 Alice 有机会恶意选出一些秘密值，从而让自己在结算 DLC 的时候获得一些优势吗？
   >
   > 幸运的是，这是不可能的：为了跟铸币厂结算这个 DLC ，Alice 最终必须知道某个 $K_i = K_i + bG$ 的离散对数，而这又需要知道 $K_i$ 的离散对数。Bob 将在后续的步骤 6 中检测出任何欺诈的尝试，那时候他会验证注册 DLC 用的是正确的锁定点。
   >
   > 这里也没有隐私性风险，因为 Alice 已经可以将她和 Bob 的赌约的细节发送给铸币厂。结果盲化秘密值的唯一用处就是向铸币厂混淆 DLC 的内容。这就是为什么我们可以使用单个秘密值，而不是为每一个结果都使用不同的随机秘密值。

2. Alice 为每一种 DLC 结果 $i$ 编码 “支付结构”  $P_i$ ，其中涉及的参与者都用他们的公开支付哈希值以及一个对应的权重来识别。比如说，对于结果 $i = 3$ 的支付，可以编码为：

   $$
   P_3 := D_a \parallel 1 \parallel D_b \parallel 1
   $$

   其中的 “ $\parallel$ ” 表示字节串拼接。而各参与者的权重（1）则表示他们获得奖金的相对比例。1：1 意味着 50%/50% 的分割，3：1 则表示 75%/25% 的比例，以此类推。

   而支付结构 $P_2$ —— Bob 是唯一受益人 —— 将是这样的：

   $$
   P_2 := D_b \parallel 1
   $$
   超时情形的支付结构也是一样，记号为 $P_t$ 。
   
3. Alice 将每一个盲化锁定点 $K'_i$ 与对应的支付结构 $P_i$ 配对为一组分支 $\{T_1, T_2, T_3\}$ 。
   $$
   T1 = (K'_1, P_1) \\\\
   T2 = (K'_2, P_2) \\\\
   T3 = (K'_3, P_3) 
   $$
   当然，还有一个超时分支，它的构造稍微特殊一点，使用一个从超时时间戳 $t$ 哈希而成的椭圆曲线点，而不是来自断言机的锁定点。
   $$
   T_t = (H'(t), P_t)
   $$
   我们哈希 t 成一个点，从而保持 $T_i$ 类型的结构，这是为了开发者的方便。

4. Alice 排序好这些分支 $\{T_1, T_2, T_3, T_t\}$ 并安排仅一棵[默克尔树](https://en.wikipedia.org/wiki/Merkle_tree)中，然后计算 “支付默克尔根哈希值” $\hat{T}$。

   这个 $\hat{T}$ 承诺了这组锁定点和支付结构，它允许铸币厂在日后验证，又无需在必要之前暴露任何信息。

5. Alice 把结果盲化秘密值 $b$ 和默克尔根哈希值 $\hat{T}$ 交给 Bob 。

6. Bob 使用断言机锁定点、盲化秘密值、预期的支付结构，重新计算出支付默克尔根哈希值 $\hat{T}$ ，就像 Alice 做的那样（从而验证 Alice 没有欺诈）。

   请注意，Bob  *不能* 只验证与自己相关的支付结构的成员资格，不然 Alice 将有机会塞入额外的分支、使用自己已经知道其见证秘密值的锁定点（也就是欺诈）。Bob 必须完全重新计算出 $\hat{T}$，以消除这种可能性。

7. Bob 创建一组 “*锁定的 Ecash 票据* ”，价值总计 100 美元，每一个票据都承诺他与 Alice 创建的这个 DLC 。

   令 $(x, Z)$ 是一个 Ecash 票据（就像本文 “Ecash” 章节讲的那样）。Bob 计算出一个锁定的 Ecash 证据 $Z'$ ：
   $$
   Z' = H'(Z \parallel \hat{T} \parallel 200)
   $$
   请注意，$\hat{T}$ 让这个锁定证据承诺了一组具体的 DLC 支付结构。而数字 200 被包含在内，作为对这个 DLC 总注资金额的承诺。否则，Alice 将能够只使用 Bob 的锁定 Ecash 票据来注资这个 DLC，自己不付出任何资金。

   这个元组 $(x, Z')$ 可以用作一个锁定的 Ecash 票据。它无法在常规的协议下兑换成有效的 Ecash 票据，但它 *可以* 被证明是从一个有效的 Ecash 票据中 *派生出来的*，只要你也知道 $\hat{T}$ 。

   如果有多个票据，Bob 只需对每个票据重复这个流程。

8. Bob 将自己的这一组价值 100 美元的锁定的 Ecash 票据交给 Alice 。

9. Alice 构造类似的一组价值 100 美元的锁定 Ecash 票据。技术上来说，她 *不需要* 锁定自己的 Ecash，因为除了她自己之外，本就没有需要防范的人。但是这种方法有助于代码复用，而且允许不受信任的代理来向铸币厂提交 DLC 。

10. Alice 把这些东西交给铸币厂：

    - 价值 200 美元的全部锁定的 Ecash 票据（全部都应该是这个铸币厂发行的）。
    - 支付根哈希值 $\hat{T}$
    - 总注资金额（200 美元）

11. 铸币厂可以使用私钥 $m$ 了验证每个锁定的 Ecash 票据：
    $$
    Y = H'(x) \\\\
    Z = mY \\\\
    Z' = H'(Z \parallel \hat{T} \parallel 200)
    $$
    铸币厂检查所有锁定的票据都是有效的、它们的证据 $Z$ 还未被用过。如果某些 Ecash 票据是无效的，那么铸币厂将回复 “错误”，并向 Alice 指明哪些票据是无效的。

    如果根哈希值 $\hat{T}$ 还没有注册过，铸币厂就通过存储 $\hat{T}$ 以及注资金额（200 美元）来注册这个 DLC 。如果 根哈希值 $\hat{T}$ 已经注册过了，那铸币厂就回复 “错误” 。

    Bob 可以使用 $\hat{T}$ 作为一个标识符，向铸币厂检查 DLC 的注册情况。在这个 DLC 注册之后，Bob 应该能够验证一次。如果 Alice 花了太多时间来注册 DLC ，Cash 可以向铸币厂兑换他的（没有锁定的） Ecash 票据，从而撤销 Alice 注册这个 DLC 的能力。

    铸币厂也可以创建一个对 $\hat{T}$ 的公开可验证的签名，并把签名交给 Alice，她可以转发给 Bob，以证明自己真的注册了这个 DLC 。

12. 这时候，Alice 和 Bob 都可以确信这个 DLC 已经锁定了。一旦断言机揭晓 “见证秘密值” $k_i$ ，任何一方都能使用这个见证秘密值来计算 “盲化的见证秘密值”，即，$K'_i$ 的离散对数：
    $$
    k'_i = k_i + b
    $$

13. Bob 现在可以向铸币厂提交以下信息来领取奖金（如果有的话）：

    - 默克尔根哈希值 $\hat{T}$，作为一个标识符
    - 他的支付秘密值 $d_b$
    - 对应的支付结构 $P_i$
    - 盲化的见证秘密值 $k'_i$
    - 默克尔包含证据，证明 $T_i \in \hat{T} $
    - 一组 “挑战点”（类似于前面的 Ecash 铸币厂例子中的 $A = Y + rG$ ，但我们将使用多个挑战点，因为在现实场景中，铸币厂可能需要发布多种面额的 Ecash 票据）

14. 铸币厂验证 Bob 的请求，先计算：
    $$
    D_b = H(d_b) \\\\
    K'_i = k'_iG \\\\
    T_i = (K'_i, P_i)
    $$
    铸币厂检查分支 $T_i$ 真的是默克尔根哈希值 $\hat{T}$ 的一个有效成员，以及 $\hat{T}$ 在自己的持久化存储中注册了。

    通过检查 Bob 的公开支付哈希值 $D_b$ 存在于支付结构 $P_i$ 中，铸币厂可以看出 Bob 应该获得多少 Ecash（根据具体的结果，相对于其他参与者的比例）。如果 $D_b \notin P_i$ ，那 Bob 就是在欺诈。

    如果这些检查都能通过，那么 Bob 的请求就会被铸币厂视为有效的。铸币厂可以使用 Bob 给出的这组挑战点来铸造信的 Ecash 承诺，它汇总了合适的支付数额，然后返回给 Bob 。假设 $i = 2$ ，那么这时候， Bob 将得到价值 200 美元的 Ecash 票据。

    对于结果 $i$ ，Alice  也可以执行上述步骤来获得她应得的任何奖金。

    **超时**

    如果断言机在时间点 $t$ 之前没有发布见证消息，那么超时条件就编程可以强制执行的。在时间点 $t$ 之后，任何一方都可以提交：

    - 默克尔根哈希值 $\hat{T}$，作为一个标识符
    - 自己的支付秘密值
    - 超时支付结构 $P_t$
    - 超时时间戳 $t$
    - 默克尔包含证据，证明 $T_t \in \hat{T} $
    - 一组挑战点，用于 Ecash 铸造
    
    …… 然后铸币厂就能够通过默克尔根哈希值 $\hat{T}$ 来验证，过程是类似的。铸币厂必须检查 $t$ 已经是过去了，也就是超时结果已经生效了。
    
15. 在一个 DLC的第一次领取成功（基于结果 $i$）之后，铸币厂必须原子化地缓存 $P_i$（或者 $P_t$），作为这个 DLC 的事实结果支付结构，从而，从此开始，在这个铸币厂只接受基于结果 $i$ 的申领请求。为什么呢？因为不然的话，Alice 和 Bob 就可以串谋、从铸币厂盗窃资金 —— 通过有意挑选自己已经知道其见证秘密值的锁定点。

16. 铸币厂应该从其缓存的 $P_i$ 拷贝中删除 Bob 的支付哈希值 $D_b$ ，以标记已经给 Bob 支付过了。一旦铸币厂发现所有的 Ecash 支付都已经分发完成，铸币厂就不再需要保留关于这个 DLC 的任何信息。所有参与者都已经得到了合适的支付，每个人都开心了。

## 观察

在本章节，我将评估 Ecash DLC 的安全性、隐私性和可扩展性。

### 安全性

Ecash DLC 的安全性与比特币区块链内的 DLC 并不等同。Ecash 铸币厂有能力欺诈或者与 DLC 参与者勾结。如果铸币厂在 DLC 到期之前离开互联网了，参与者们显然就无法领取自己的 Ecash 奖金。不过，这对于参与者来说并不是一种新的风险 —— 可以假设他们已经是 Ecash 票据的持有者了（已经知道这种风险了）。他们手上的货币已经带有这种托管负担，所以，值得强调，DLC 并没有为参与的任何人引入新的对手方风险。

不能接受这种对手方风险的用户应该考虑使用链内 DLC ，或者[使用闪电网络售票的 DLC](https://conduition.io/scriptless/ticketed-dlc) 。

### 隐私性

Ecash DLC 在隐私性上的效果是惊人的。除了网络层面的元数据（比如 IP 地址）、被 TLS 和 HTTP（等等）泄露的传输层信息，铸币厂只能知道：

- 总的注资金额（各方的注资金额是被掩盖）
- （被见证的唯一结果的）最终支付结构
- 大约的结算时间（参与者们可以故意推迟结算，从而更好地混淆自己用到的见证消息）

由于结果锁定点的盲化特性，铸币厂无法暴力搜索现有的公开断言机来确定参与者们的赌约内容。

如果发生了超时情形，参与者们 *确实* 需要揭晓超时时间戳 $t$ ，这可能会泄露关于打赌事件的一些信息，但超时情形应该是罕见的，如果断言机的行为符合预期的话。

因为揭晓 $T_i \in \hat{T}$ 的默克尔包含证据，参与者可能会泄露可能结果的数量下界，但这一信息可以通过以伪随机方式掩盖默克尔树的真实叶子数量来模糊化。

因为 Ecash 的同质化和盲化属性，铸币厂永远无法知道谁领走了奖金、这些奖金用到了哪里 —— 只知道这个 DLC 的最初注资者批准了最终的支付结构。

### 可扩展性

Ecash DLC 的可扩展性非常好（从铸币厂的角度看），考虑到一个铸币厂可能需要管理数千个 DLC ，这是个好事。

一个尚未结算 DLC，不论价值多高、复杂性符合，在铸币厂的存储中都总是可以表示为一个常量大小的数据结构。不论可能结果的数量有多少、支付结构有多复杂，所有东西的承诺会折叠为一个默克尔根值 $\hat{T}$ 。铸币厂可以在单轮通信中完成一个 DLC 的注册，而结算则至多需要 $n$ 轮。

结算节点的领取验证可以在 $O(\log n)$ 时间内完成，这同样得益于默克尔树。只要铸币厂缓存了第一次有效领取的支付结构 $P_i$ ，它就能避免为后续每一次申领重复验证，代价最多是 $O(n)$ 的存储空间。

对于 DLC 的参与者，DLC 的建立流程更加昂贵，因为计算 $\hat{T}$ 需要 $O(n)$ 次椭圆曲线 加法/乘法，以及 $O(n)$ 次哈希运算。每个参与者都必须独立计算 $\hat{T}$ ，这是无法安全地委托出去的工作。

在这里，性能也可以通过一种透明的方式来提升，通过牺牲隐私性，并允许最终的见证秘密值 $k_i$ 揭晓，而不使用盲化秘密值 $b$ 来掩盖它。这使得构造 $\hat{T}$ 的工作变成纯粹的哈希计算，不涉及椭圆曲线运算（除了一开始要从断言机公告中计算锁定点），并且因此，将快速得多。代价是可能会揭示这个 DLC 要订阅的事件内容。

## 未来的 升级/插件

- 铸币厂可以为处理 DLC 收取手续费。
- DLC 的参数可以更新，只要一组预先确定的参与者同意的话。
- 铸币厂自身可以作为一个断言机。这进一步增加了对单一参与方的信任，但是这个铸币厂 *无法区分* 它结算的 Ecash DLC 是否订阅了自身的断言机，或是别人的断言机。时机与其它侧信道可能会泄露关联。
- 参与者可以超额注资。由锁定 Ecash 票据承诺的限制，可以被认为是让这个 DLC 进入锁定状态、从而被铸币厂强制执行的门槛。但参与者可以超额注资。
- 感谢锁定 Ecash 票据的概念，注资可以在暗箱中完成，无需来自铸币厂的输入。这就为使用 Ecash 来注资 DLC 的众筹服务打开了可能。铸币厂将无法区分一个众筹的 DLC 与单方注资的 DLC 。注资者们可以随时通过兑换他们承诺提供给 DLC 的资金来退出。
- 锁定 Ecash 票据的概念也可以用来在普通 Ecash 协议中创建众筹的多方支付，完全不涉及 DLC 。
- 也许，通过闪电网络进行的跨铸币厂转账，对这一协议也有帮助。
- DLC 断言机可以用 Ecash 票据来激励吗？
- 如何最好地集成 “[数位分解事件](https://github.com/discreetlogcontracts/dlcspecs/blob/master/Oracle.md#digit-decomposition)” —— 断言机需要为每个事件提供超过一个见证秘密值？

## 结论

虽然 “[使用闪电网络来卖票的 DLC](https://conduition.io/scriptless/ticketed-dlc) ” 从对手方风险的角度看会更加安全，Ecash DLC 似乎更容易实现、概念上更简单，因此更不容易出现故障。

与任何 DLC 一样，这套协议也依赖于诚实可靠的断言机，但 *只要* 有一个这样的断言机，DLC 这种技术就允许极大的灵活性，是前所未有的。小规模的微型赌约在几秒钟内就可以构造出来，无需触及区块链，也无需长时间锁定（像闪电通道一样）。

我认为，这是非常有情景的方向 —— 将 Ecash 转化为一个可编程的条件支付层，无需对铸币厂的额外信任，并且几乎无需牺牲隐私性。支持 DLC 特性的 Ecash 铸币厂可以被博彩网站、保险服务、期货市场以及更多服务的客户使用，并且完全是完全隐私、平等的。与此同时，铸币厂将拥有完全的合理否认能力，因为不知道其支持的 DLC 的内容，而且犯错了也可以收取手续费。

（完）