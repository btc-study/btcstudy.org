---
title: 'Trustodial：一个本体论两难'
author: 'Shinobi'
date: '2025/07/14 11:15:04'
cover: ''
excerpt: 'Statechain 这样的 “trustodial” 系统带来了一个难题：到底什么构成了 “自主保管”？'
tags:
- Statechain
---


> *作者：Shinobi*
> 
> *来源：<https://bitcoinmagazine.com/technical/trustodial-an-ontological-dilemma>*



![Trustodial-1024x538](../images/trustodial-an-ontological-dilemma/Trustodial-1024x538.png)

（译者注：上图是两种著名的分类：“托管（custodial）” 和 “非托管（noncustodial）”；作者使用一个生造的新词 “trustodial”，已经透露了其部分想法。）

最近，Wallet of Satoshi 宣布，由于集成了 Lightspark 项目推出的最新 “Spark” 系统，他们得以重新为美国用户服务。许多批评旋即爆发，主要围绕的是信任模式的问题，以及新版本的 Wallet of Satoshi 是不是一种 “非托管” 钱包。

Spark 是一种基于 [statechain](https://bitcoinmagazine.com/technical/bitcoin-layer-2-statechains)（[中文译本](https://www.btcstudy.org/2025/06/21/bitcoin-layer-2-statechains-by-shinobi/)）的系统。Statechain 在信任模式上并不是非常清晰。本质上，Spark 是 statechain 的状态通道版本，也就是许许多多的 statechain 都被封装到了建立在单个链上 UTXO 之上的交易树中。

Statechain 是 Layer 2 系统，让整个 UTXO 可以在链下自由转移，没有收款额度要求，但需要接受信任模式上的一些取舍。你必须信任一个运营者（也就是服务的提供商），会在转移一个 statechain 资金完成之后删除相关的一个私钥材料。

那么我们先来看看什么东西构成了 “非托管”。

- 用户可以单方面控制自己的资金，或者说，有能力重新获得这种单方面控制。
- 没有其他一个人或一群人可以阻止用户花费自己的钱、重获自己的花费能力，也不能在用户不参与的前提下花费其资金。

第一种品质在 statechain 上是成立的。就像在闪电通道中，一个用户有能力使用一笔预签名交易来取出资金到自己排他控制的地址中，只是预签名交易带有时间锁，以保证诚实结算。第二种品质则很难清楚地说是成立还是不成立。

Statechain 协议要求运营者和第一位用户合作生成一个密钥，从而没有任何人知道该密钥的完整私钥。使用各自的私钥碎片，他们就能合作预签名用户的取款交易。当一个 statechain 的原主人要将他转移给其他人的时候，原主人、新主人和运营者就要全体合作，“重新生成” 同一个密钥，只是新用户和运营者的私钥碎片将与原来的不同。

在签名新主人的取款交易之后，运营者被假设会删掉自己跟原主人一起生成的私钥碎片，从而断绝跟原主任一起签名新交易的可能。此文，新主人的取款交易的时间锁也会比原主人的更短，以保证新主人总是可以在原主人之前花费这个 statechain。

如果运营者没有删除旧的私钥碎片，那么任何一个保留了私钥碎片的旧主人，都可以跟运营者一起盗窃对应的 statechain 资金。

## 运营者

如果运营者按照我们的期待，每次转移 statechain 之后旧删掉自己的旧私钥，那么他们旧不是一个托管系统。他们在技术上就不可能跟其他人签名交易，只能跟最新一位主人，也就是正确的所有权人，一起花费这个 statechain 。递减时间锁的预签名交易保证了最新一位主人 *总是* 可以抢在所有旧主人之前让自己的区块交易得到确认。

运营者甚至可以在一个 SGX 飞地（译者注：Intel CPU 中的受信任执行环境）或其他安全计算环境中运行自己的软件，让这个环境来强制执行软件的正确动作。甚至还可以提供所有人都可以验证的证据（保证你可以信任这个环境没有被破坏）。

运营者也有强大的经济激励来诚实运行协议，因为这样一来，他们就不必符合针对托管服务（持有他人资金）的监管要求。

## 用户

终端用户拥有一笔单方面取款交易。在自己的时间锁到期之后、上一任主人的时间锁到期之前，这笔交易随时可以动用。如果运营者停止响应，或者玩失踪，用户是有这个选择的。

但他们必须信任运营者是诚实的，每次都删除了旧私钥碎片。而且，用户没有办法 *真正验证* 这一点。如前所述，SGX 飞地这样的受信任执行环境可以处理运营者软件的安全性，并产生运营者正在运行诚实软件的证据。但所有这一切都不过是将受信任的主体从运营者换成了 Intel —— SGX 飞地的制造商。

即使用户跟一个非常诚实的运营者 —— 从来只运行诚实软件、从不欺骗任何一个用户 —— 打交道，也永远无法真正 *确认* 这是一个诚实的运营者。用户只能看到这个运营者 *一直* 是诚实的，并且希望他们会继续保持诚实。

## 最后结论是？

没有清晰的答案。在一个运营者 *真的* 诚实的情况下，statechain 就满足我们在前面列出的非托管的所有脱胶。用户有不可阻碍的获得资金完整控制的能力，没人能阻止他们，也不能偷走他们的钱。

问题在于 *这是无法验证的*。

作为一个用户，没有办法免信任地验证你对资金有免信任的控制力。即使你真的有，也无法验证。

所以，将这种模式称为 “非托管” 会有一个问题，因为即使它真的是，用户也无法真的验证它。但管它叫 “托管” 也会有问题，因为运营者只有跟另一位用户合作，才能转移资金，光凭自己是不行的；而且最新用户有一笔单方面取款交易。这就在当前的分类法中产生了一个两难。

我不知道该怎么解决这个两难，但我认为，第一步是了解其技术事实，然后再从你自己的激励出发给它打标签（为什么不使用一个新的类别呢？）。这一类的问题，尤其在比特币协议变更极为缓慢的环境下，会发生得更加频繁，因为开发者要在比特币当前的局限下艰难取舍。

比特币是一种可编程的货币，但人们编程它的方式不会总是能够放进我们预先设想的类别里。

（完）