---
title: '如何安全地安装比特币软件'
author: 'Luke Dashjr'
date: '2022/10/24 16:04:25'
cover: ''
excerpt: '如何验证程序未被篡改过？'
tags:
- 文化
---


> *作者：Luke Dashjr*
> 
> *来源：<https://medium.com/@lukedashjr/how-to-securely-install-bitcoin-9bfeca7d3b2a>*



## 预期

这些指令需要你理解文件是如何存储在你的电脑中的（抽象地理解就行；如果你知道什么是 目录/文件夹，那差不多就可以了），以及如何使用命令行来运行程序和访问文件。如果你还不理解这些概念，请转去寻找可以向你解释这些概念的指南。

请注意，这里的指令只能帮助你安全地安装比特币软件。它们无意帮你保护你的硬件、你的操作系统和规避由你安装的其它软件引入的木马。一般来说，如果你的电脑上的别的东西全部都被攻陷了，你的节点也会处在风险之中，无论你在安装的时候如何验证了程序的安全性。

如果你想做成一个绝对安全的节点，除了这里的指令，你还需要（至少）避免使用带有后门的硬件（包括树莓派，以及任何由 Intel 和 AMD 生产的东西）、运行一个值得信赖的基于 Linux 的操作系统，*仅* 安装和使用由你的操作系统供应商提供的软件以及可以使用 GnuPG 验证的软件（本文讲的正是其验证方法），并确保软件打上了最新的漏洞补丁。

但是，即使你没法解决上述问题因此无法获得极致的安全性，也不应该关掉这个网页；毕竟，验证你的比特币节点软件，依然是有意义的。

## 概述

有三大步骤可以保证你安装的比特币软件是安全的、没有木马的：

- 验证 OpenPGP 公钥
- 验证签名
- 验证安装文件本身

每一个步骤都依赖于上一个步骤的成功；而且，虽然你可以跳过某一些步骤，请谨记，只有完成了 *所有的* 步骤，你安装的节点软件才算验证过的。

在下文的例子中，我验证了我自己对 Bitcoin Knots 软件 v0.193.1.knots20200104 版本的 ppc64le Linux 系统适配版的签名。要验证其他人的签名 以及/或者 另一个文件，你要修改命令行指令，使用他们的公钥指纹 以及/或者 文件。

## 步骤 0：安装 GNU Pricacy Guard（GPG，GNU 隐私卫士）

在开始之前，你需要先安装好 GNU 隐私卫士（GPG）工具。保证文件安全所需的所有密码学验证工作，都需要用到这个工具。

如果你使用的是基于 Linux 的系统，你可以从操作系统供应商处安装它。今时今日，GNU 基本上已经做到了 “开箱即用”，也就是它其实是跟操作系统同步安装的 —— 你可以在命令行工具中运行  ` gpg --version ` 来检查。如果运行失败（表示没有安装好 GPG），那就请在下列的指令选择一条来安装它（任一指令失败了都请尝试另一条指令）：

```sh
apt-get install gnupg
dnf install gnupg2
yum install gnupg2
emerge app-crypt/gnupg
pacman -S gnupg 
apk add gnupg
```

如果你不幸用的是 Windows 或者 macOS，你可以在[他们的网站下载 GP](https://gnupg.org/download/#binary)G，但我不知道有什么办法可以验证你下载的软件是不是安全的。当然，他们也提供签名，但这里面有个先有鸡还是先有蛋的问题：除非你安装的是拷贝是正确的，不然你根本没有办法验证这些签名！

## 步骤 1：验证 OpenGPG 公钥

这一步可能是整个流程中最困难的一步：你需要确认你得到的公钥正是你信任的、不会编写带后门的软件的人所用的公钥。如果你不够细心，最终你可能得到一个代表 “Luke Dashjr” 的假公钥，最终导致你验证的是别人 —— 而不是我 —— 有没有签名某个文件。

每个 OpenGPG 公钥都有一个 “指纹”，是一个 40 位的十六进制字符串，有时候会用空格分隔，以便阅读。只要你确保自己得到的公钥的指纹，跟你所信任的签名人放出的指纹相匹配，你就知道自己得到了正确的公钥。

### 获得公钥 以及/或者 指纹

验证公钥的最安全的方法，就是单独见面并现场确认公钥的 “指纹”。几乎没有人会记得自己的公钥的指纹，所以需要在自己的笔记本和手机上查找是很常见的事。

有时候 —— 一般是在大会或者小会的时候 —— 可能会有 “公钥签名派对”，一群人聚在一起相互确认彼此的指纹，比如说每个人都大声读出自己的公钥指纹，或者手动确认其他人 看到的/听到的 是正确的公钥指纹。要是你得到了参加这样的派对的机会，别错过，这是一次性验证许多公钥的机会。

如果你对此没有兴趣，或者没有机会面见真人，你最好通过多个消息源来验证自己得到的公钥。

开发者通常会将自己的公钥或者指纹发布在个人网站上，有时候还会发到别的地方（我把我的公钥指纹发到了[我的个人主页](http://luke.dashjr.org/myself/luke-jr.asc)、[bitcoinknots.org](http://bitcoinknots.org/luke-jr.asc)、[bitcoin.org](https://bitcoin.org/luke-jr.asc) 和 [GitHub](https://github.com/bitcoin/bitcoin/blob/master/contrib/gitian-keys/keys.txt) 中）。

如果你已经有一个你信任的软件的安装好的拷贝，有时候它会包含用来验证更新的公钥（Bitcoin Core 仅在这一次的源代码中才这样做）。

### 检查一个公钥文件的指纹

想知道一个公钥文件的指纹，你需要使用这个命令：

```sh
gpg --import-options show-only --import --with-fingerprint luke-jr.asc
```

它会打印处关于这个公钥的许多信息，但最重要的信息会放在最前面：

```sh
pub   rsa8192 2012-03-23 [SC] [expires: 2020-06-09] 
      E463 A93F 5F31 17EE DE6C  7316 BD02 9424 21F4 889F
```

意思是， ` E463 A93F 5F31 17EE DE6C 7316 BD02 9424 21F4 889F ` 就是这个公钥文件的指纹。

**注意**：如果 GPG 说这个公钥已经过期了，那也没有什么关系，在步骤 2 中，你会更新它到同一个公钥的最新版本，通常来说这会使期限延长。

### 导入验证后的公钥

无论你是如何验证公钥的，你需要记得自己验证过的是哪一个公钥，这样你才能在日后更新时检查更新是不是用到了同一个公钥。即使你跳过了验证的步骤（请注意，这不安全），至少这可以保证，你得到的软件更新跟你正在使用的软件得到了同一个人的签名。

当你确定自己拿到的这个公钥是一个正确的公钥之后，请导入它（把指令中的  ` luke-jr.asc ` 替换成你想要导入的公钥文件的文件名）：

```sh
gpg --import < luke-jr.asc
```

或者，如果你只得到了公钥指纹，你可以这样做（请把指令中的指纹换成你想要导入的公钥的指纹！）：

```sh
gpg --keyserver hkp://keyserver.ubuntu.com --recv-key E463A93F5F3117EEDE6C7316BD02942421F4889F
```

## 步骤 2：验证签名

现在，你已经知道自己要用来检查签名的公钥是哪个了，下一步就是检查签名了。

在你执行这一步之前，先要确保自己得到的签名者的公钥拷贝是最新的。要是你没有这样做，你就会得到一条现实公钥已经过期的消息。请运行（再说一遍，请使用你想要更新的公钥）：

```sh
gpg --keyserver hkp://keyserver.ubuntu.com --recv-key E463A93F5F3117EEDE6C7316BD02942421F4889F
```

然后，（除了你要检查的程序文件之外）你还需要两个文件：“.assert” 文件，包含着一系列的文件的指纹，以及 “.assert.aig” 文件，包含对该列表的签名。这是因为，签名人不是直接对程序文件签名的，而是生成出所有文件的数字指纹，然后再对整个列表签名。所以你 *两个* 文件都需要。

- Bitcoin Core 的 “assert” 文件可在此处获得：

  https://github.com/bitcoin-core/gitian.sigs/find/master

- BitcoinKnot 的 “assert” 文件可在此处获得：

  https://github.com/bitcoinknots/gitian.sigs/find/knots

请注意，每个签名者都有一个单独的签名文件。如此你要验证多个人签名了你得到的这个文件（确实该这么做），你就需要检查多个签名文件。请确保你得到的文件的版本就是你想验证的版本！

你在上面的网页中找出了自己想要的文件之后，就点击链接、在自己的浏览器中打开，然后右键单击 “Raw” 或者 “Download” 按钮，选择 “Save Link As（另存为）”。

你得到了两个 assert 文件之后（再说一般，一个是文件的电子指纹，另一个是对这些指纹的签名），你就可以检查签名了，运行（请把指令中的文件名换成你得到的 .assert.sig 文件的名字）：

```sh
gpg --verify bitcoin-core-linux-0.19-build.assert.sig
```

如果签名是真的，则程序会告诉你：

```sh
gpg: Signature made Sun 19 Jan 2020 03:47:15 AM UTC 
gpg: using RSA key E463A93F5F3117EEDE6C7316BD02942421F4889F 
gpg: Good signature from “Luke Dashjr <luke@dashjr.org>” [ultimate] 
```

请注意，公钥的指纹会以粗体显示，而且一定要跟你在步骤 1 中验证过的公钥的指纹一致，不然就说明这个签名是别的公钥签出的！“Good signature（好的签名）”那一句也很重要，但名字和邮件地址则不重要 —— 如果指纹是错的，这些也有可能是伪造的。

假设一切顺利，那么现在你已经知道，“.assert” 文件得到了控制着你验证过的公钥的人的担保，你现在可以进入下一步了：验证你得到的程序文件，就是列在 “.assert” 文件内列表中的文件 ……

## 步骤 3：验证文件本身

要验证你得到的程序文件，你先要获得它的密码学哈希值（也就是上文说的 “电子指纹”）。只需一行命令就可以搞定（换成你要验证的文件的名字！）：

```sh
Linux: sha256sum bitcoin-0.19.0.1.knots20200104-powerpc64le-linux-gnu.tar.gz
Windows: certUtil -hashfile bitcoin-0.19.0.1.knots20200104-win64.zip SHA256
macOS: shasum -a 256 bitcoin-0.19.0.1.knots20200104-osx-unsigned.dmg
```

结果会是这样的：

```
d370692590c4546ac0de250da91c6c288d9ee5252f1a4b857a5b80c4e3d81149  bitcoin-0.19.0.1.knots20200104-powerpc64le-linux-gnu.tar.gz
```

前面的一个字符串就是这个文件的电子指纹，后面的一段是你指定的文件的名字。

现在，用随便一个编辑器打开 “.assert” 文件，然后看看里面包含的指纹。它应该在顶部的 “out_manifest” 中 —— 要是你遇到了 “in_manifest” 栏目或者 “base_masifests” 栏目，你可能需要回到文件更开头的地方。

要是你在 “.assert” 文件中发现了一模一样的指纹，那么你就知道，你手中的这份文件，正是签名者担保的同一个（你会在 “.assert” 文件中看到一栏文件名和一栏电子指纹 —— 跟你得到哈希值一致的指纹，对应的文件名也应该跟你的文件名一致）。

要是 “.assert” 文件中不包含你得到的哈希值，那么，这可能意味着你得到了一个错误的 “.assert” 文件，要么意味着你的文件 *并不* 匹配（在这种情况下，你会看到一模一样的文件名对应着一个不一样的哈希值）。如果文件名在列，但是指纹不一样，请 *不要打开你得到的文件*，但是保存好（我们可能会向你请求一个拷贝），并联系受到影响的项目的安全团队。

（完）