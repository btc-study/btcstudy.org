---
title: '比特币升级提案 Taproot 技术解读'
author: 'Gaurav Agrawal'
date: '2021/09/29 11:04:24'
cover: '../images/bitcoin-taproot-a-technical-explanation/bfb04aeb0b124acf8ee9659365767e6d.png'
excerpt: '从 P2SH 开始，介绍 Taproot 的升级含义'
categories:
- 比特币主网
tags:
- 比特币
- Taproot
---


> *作者：Gaurav Agrawal*
> 
> *来源：<https://medium.com/coinmonks/bitcoin-taproot-cdf96c2e100>*


![1](../images/bitcoin-taproot-a-technical-explanation/bfb04aeb0b124acf8ee9659365767e6d.png)

本文将讨论[比特币](https://blog.coincodecap.com/a-candid-explanation-of-bitcoin)升级提案 **Taproot** ，该提案将引入很多全新功能。本文将从各个技术层面分析 Taproot、介绍本次升级中涉及的技术以及这些技术会给比特币用户带来哪些好处。

## 什么是 Taproot？

Taproot 由 Bitcoin Core 贡献者 [Gregory Maxwell](https://cryptoanarchy.wiki/people/gregory-maxwell) 于 2018 年首次提出。该实现目前尚在开发中。如果没有 Taproot，这些复杂的交易（时间锁、[多签](https://blog.coincodecap.com/multi-signature-wallet)）需要多个事务来完成，因此很容易失败。

>Taproot 可以让复杂交易（多签、时间锁）像单个比特币交易那样执行，从而增强比特币的隐私性。

Taproot 升级包括三个重要的技术变化（概念），用来增强比特币的可扩展性、隐私性和灵活性。

* P2SH
* MAST
* Schnorr 签名

我们将从技术层面讨论这三个概念，从而了解 Taproot 升级会给比特币用户带来哪些好处。

## P2SH（Pay-to-ScriptHash）

比特币地址是一个包含字母和数字的字符串。用户可以将其分享给其他人，以便从后者那里接收 BTC。比特币交易主要有两大标准：Pay-to-PubKeyHash (P2PKH) 和 Pay-to-ScriptHash (P2SH)。

在讨论 P2SH (Pay To Script Hash) 和 P2PKH (Pay-To-PubKey Hash) 这两个概念之前，我们首先熟悉一下关于比特币的背景知识：

* 在比特币网络中，比特币的形式是 UTXO。UTXO 是 **Unspent Transaction (TX) Output（未花费交易输出）**的缩写，即，比特币交易执行后形成的面额不定的单元。例如，你的比特币钱包里有 10 BTC，你想要转 5 BTC 给朋友。比特币区块链的处理方式与众不同。它会把 10 BTC（全部余额）都花掉，将 5 BTC 转入你朋友的钱包，剩下 5 BTC（10 BTC - 5 BTC = 5 BTC）转入你自己的钱包。这下，你和你的朋友各持有未花费的 5 BTC。
* 比特币使用**脚本（几行代码）**来规定花费 BTC/UTXO 的条件。脚本被用作一种锁定机制。
* BTC 锁定在脚本中。当脚本返回成功（即条件得到满足）时，BTC 就会解锁。
* 任何人都可以向任意比特币地址发送 BTC。只有当脚本中定义的某些条件得到满足时，锁定的 BTC 才可以被花费出去。脚本决定了接收方可以如何花费收到的 BTC。发起交易时，发送方会在交易中放入一个叫作 “**PubKey Script（又称锁定脚本）**”的脚本。接收方（在日后花费时）需要生成一个 “**签名脚本（又称解锁脚本）**” ，是满足 PubKey 脚本的数据参数的集合。签名脚本在代码中又被叫作 “**scriptSig**”。
* 在上述例子中，你在向朋友发送 5 BTC 时，锁定脚本也会包含在这个交易内。如果你的朋友想要花费这些 BTC，必须生成满足锁定脚本中规定条件的解锁脚本。

## Pay-to-PubKeyHash (P2PKH)

Pay-to-PubKeyHash 是一种传统的比特币地址格式。其地址以数字 1 开头。

只有 P2PKH 地址的所有者才能通过提供公钥哈希值和私钥签名来解锁 PubKey 脚本并花费收到的 BTC。私钥是用来证明公钥哈希值的所有权的。

正如我们上文讨论过的那样，脚本定义了特定地址上的 BTC 在什么条件下可以花费。当规定条件得到满足且通过网络验证时，该地址上的 BTC 就会被解锁以供花费。

**这一流程是如何运作的？**—— 接收方首先生成 PubKey 脚本并将其分享给发送方。发送方在发送 BTC 时将该 PubKey 脚本 添加到交易中。收到 BTC 时，如果接收方想要解锁这些 BTC UTXO，就要提供公钥哈希和私钥签名，并满足 PubKey 脚本中提到的条件。

![2](../images/bitcoin-taproot-a-technical-explanation/4d8eb4377a87414ab47af431e948909d.png)

例如，这些条件可以是：

* 解锁 BTC 至少需要两个签名。
* 提供口令（password）才能解锁。
* BTC 需要等待一段时间才能解锁。


上述这类情况可以作为解锁 BTC 的条件。

发送比特币时，发送方需要在交易中包含 **PubKey 脚本。**因此，这会增加交易的体积，产生的交易费比普通交易高出 5 倍左右。

这里，发送方必须承担额外的成本。Pay-to-ScriptHash 可以帮助发送方免去这一额外成本。

## Pay-to-ScriptHash (P2SH)

Pay To Script Hash (P2SH) 可以帮助发送方免去额外的成本，并将这一责任（额外成本）转移到真正需要使用锁定脚本中规定条件的接收方身上。Pay-to-ScriptHash 比特币地址是以数字 3 开头的。

在这个交易标准下，发送方不需要将很长的 PubKey 脚本放到他们的交易中。这里，锁定脚本被替换成了赎回脚本（redeem script）哈希值。赎回脚本哈希值由赎回脚本计算而来。赎回脚本与 PubKey 脚本类似，包含接收方在花费未花费输出之前必须满足的条件。**发送方只需在交易中注明赎回脚本的哈希值。**赎回脚本哈希可以翻译成标准比特币地址，发送方无需进行任何特殊操作或支付额外费用即可将 BTC 发送到这些地址。

接收方想要解锁这个 P2SH 地址上的 BTC 时，需要生成具有相同哈希值的赎回脚本并将其包含到交易内。因此，接收方用来解锁 UTXO 的交易大小会增加，执行交易的成本也会增加。

例如，Alice 想要发送 10 BTC 给 Bob。Alice 必须将赎回脚本哈希包含到交易内。首先，Bob 先生成一个赎回脚本，然后将赎回脚本的哈希值发送给 Alice，以便 Alice 将该哈希添加到交易内并发起交易。如果 Bob 想要花费该 UTXO，必须生成相同哈希值的解锁脚本，并满足脚本中提到的条件。

别忘了，Alice 只需将赎回脚本的哈希值而非整个脚本添加到交易内。因此，Alice 无需承担额外的费用。

## Pay-to-ScriptHash 的优势

* 使用哈希值取代冗长的脚本。
* 发送方可以在不知道脚本中规定的花费条件的情况下，在交易中放入任意数量的赎回脚本哈希值。
* 减轻了发送方的交易费负担。

（……）


## MAST（默克尔抽象语法树）

MAST 是 **Merklized Abstract Syntax Tree（默克尔抽象语法树）**的缩写。

**为什么要使用 MAST？**如果你想花费 P2SH 地址里的 BTC，你必须生成具有相同哈希值的赎回脚本并将其包含到交易中。如果脚本中规定的花费条件太多，交易体积会变得格外庞大。MAST 可以很好的解决这一问题。

默克尔抽象语法树是默克尔树和抽象语法树的结合体。

就像 Pay To Script Hash (P2SH) 是给哈希值为某某的脚本付款那样，MAST 是给哈希值为某某的默克尔根付款。MAST 是把一个大的条件集合中的各个条件组装成一棵哈希树（所谓的默克尔树），而默克尔树的根值是一个哈希值，由所有条件哈希而成。

**默克尔根和哈希树是如何生成的？**

首先分别对所有脚本（条件）做哈希计算；然后将计算得到的哈希值与相邻哈希值组合起来进行哈希计算，生成一组新的哈希值。不断重复这个两两哈希计算的过程，直到计算出最后一个哈希值为止。这个哈希值就是默克尔根。

假设共有四组条件。首先，分别计算出这四组条件的哈希值；再将这四个哈希值两两配对，计算出两个哈希值；最后，把这两个哈希值组合起来做哈希计算，生成最终的哈希值。最后这个哈希值就是默克尔根。

![3](../images/bitcoin-taproot-a-technical-explanation/e1ebcee673c840688ed5b29b8b8d12a3.png)

这个默克尔根可以翻译成一个能够接收付款的有效比特币地址，即，**默克尔比特币地址（Merklized Bitcoin address）**。默克尔比特币地址有很多优点，最主要的优点是无需知晓所有脚本单元就能验证某个脚本是否位于这棵默克尔树上。这个技术叫作**默克尔证明（Merkle Proof）**，可以用来轻松验证一个比特币 UTXO 是否包含某些解锁条件。

在 MAST 中，BTC 与一棵默克尔树绑定。这棵默克尔树指定了可以解锁未花费 BTC 的所有复杂条件。每个叶节点都代表着一个条件。为了解锁 BTC，你必须生成一个满足默克尔树上某个分支所代表的条件的脚本。仅使用默克尔根即可验证这个条件是否属于原始条件集合（即验证某个叶节点是否在这棵默克尔树上）。一旦比特币区块链网络发现某个脚本（及其所代表的条件）属于这个默克尔根，网络就会知道这个脚本是这些比特币的锁定条件并开始验证解锁脚本。因此，我们无需生成完整的脚本并将其包含到交易内，即可花费以 MAST 锁定的 BTC。这有助于减少 BTC 交易的体积。

## Schnorr 签名  

在密码学中，Schnorr 签名是由 [Claus Schnorr](https://en.wikipedia.org/wiki/Claus_P._Schnorr) 提出的 Schnorr 签名算法生成的数字签名。 Schnorr 签名算法是一种以简单闻名的数字签名方案，通过将多个签名聚合成单个签名以优化验证和认证过程。该方案适用于[多签](https://blog.coincodecap.com/multi-signature-wallet)交易。

若想执行交易，你需要使用私钥签名该交易，以证明你是某个公钥背后的 BTC 的所有者。但是，若想执行多签交易，你必须提供多个签名。这些签名会占据额外的空间。

以 12/20 多签交易为例。12/20 指的是执行该交易至少需要提供 20 个签名中的任意 12 个。签署交易时，签名也会存储在区块内。假设 1 个签名的大小是 5 字节，12 个签名需要占用区块 60 字节（5*12 = 60）的内存，100 个签名需要占用 500 字节的内存。这会增加内存用量。**Schnorr 签名**恰好可以解决这一问题。

**为了理解 Schnorr 签名，我们来看两个例子：**

* （……）
* 另一种情况是多签交易。假设你需要 100 个签名且每个签名的大小是 5 字节，Schnorr 签名方案可以将这 100 个签名合并成一个大小为 64 字节的 Schnorr 签名。省下 436 字节（5*100-64=436）的内存可以用来存储更多交易。（注：现在的椭圆曲线签名可不止 5 字节）

**比特币升级** —— Taproot 计划将上述概念引入比特币区块链，增强其可扩展性、隐私性和灵活性。

## 比特币 Taproot：总结

本文主要围绕以下几个要点介绍了 Taproot：

* Taproot 是 Bitcoin Core 贡献者 Gregory Maxwell 在 2018 年提出的比特币升级提案。
* Taproot 让复杂的交易如多签名交易、时间锁交易看起来如同普通的比特币交易，增强了比特币的隐私性。
* Taproot 升级主要包含 3 个技术概念 —— P2SH、MAST 和 Schnorr 签名。
* 比特币使用脚本注明花费 BTC/UTXO（未花费交易输出）的条件。
* Pay To Script Hash (P2SH) 可以帮助发送方免去额外的交易费，并将这一责任（额外的交易费）转移到真正需要使用锁定脚本中规定条件的接收方身上。
* 使用 MAST，比特币可用默克尔树抽象语法树来锁定。（与默克尔根对应的）默克尔树决定了可以解锁未花费 BTC 的所有复杂条件。默克尔抽象语法树（Merklized Abstract Syntax Trees，MAST）被提议引入比特币区块链，以减少 BTC 交易的体积，使得接收方无需在交易中附加冗长的脚本。仅使用默克尔根即可验证接收方生成的脚本是否属于原始条件集合。
* Schnorr 签名可以将多个签名合并成单个签名。

（完）



