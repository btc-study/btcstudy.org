<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BTC Study</title>
  
  <subtitle>学习比特币</subtitle>
  <link href="https://www.btcstudy.org/atom.xml" rel="self"/>
  
  <link href="https://www.btcstudy.org/"/>
  <updated>2026-02-28T07:32:23.230Z</updated>
  <id>https://www.btcstudy.org/</id>
  
  <author>
    <name>btcstudy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hArk：移动端友好的异步刷新</title>
    <link href="https://www.btcstudy.org/2026/02/28/hark-explained-async-forfeits-and-mobile-friendly-refreshes/"/>
    <id>https://www.btcstudy.org/2026/02/28/hark-explained-async-forfeits-and-mobile-friendly-refreshes/</id>
    <published>2026-02-28T07:29:38.000Z</published>
    <updated>2026-02-28T07:32:23.230Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Erik De Smedt</em></p><p><em>来源：<a href="https://blog.second.tech/hark-explained/">https://blog.second.tech/hark-explained/</a></em></p></blockquote><p><img src="/../images/hark-explained-async-forfeits-and-mobile-friendly-refreshes/ained-1.jpg" alt="hArk explained: async forfeits and mobile-friendly refreshes"></p><p>“hArk（运用哈希锁的 Ark）” 最早在 <a href="https://delvingbitcoin.org/t/evolving-the-ark-protocol-using-ctv-and-csfs/1602">Delving Bitcoin 论坛的一篇文章</a>中出现，并已经在<a href="https://docs.second.tech/changelog/changelog/#010-beta6">我们的 Ark 实现的 v0.1.0-beta.6 版本</a>中发布。hArk 是我们对 Ark 协议实现的一次更新，在根本上改变了回合（round）的构造方式。更新之后，用户的 “弃权交易（forfeits）” 依赖于哈希锁而非 “连接器输出（connectors）”，并且是在回合的注资交易广播 <em>之后</em> 签名（而不是提前签名）。</p><p>hArk 使得在 Bark 上开发移动端应用变得容易得多，它支持 “委托刷新（delegated refreshes）”，因为移动设备无法被可靠地唤醒以参与回合签名流程，所以这是必要的机制。与标准的自主签名刷新相比，委托刷新在安全性上有一些牺牲，但请放心，自主签名刷新仍然是默认的信任模型，协议的核心没有改变。</p><p>说实话，我们在实现 hArk 时有所犹豫，因为知道这会延迟主网发布。但这总归是必要的 —— 比起一开始就带有新的回合模型，在用户和集成者已经开始适应旧的模型后再进行改造会痛苦得多。现在它已经就绪，我们很高兴——我们希望 Bark 自始至终对移动端友好。</p><h2 id="（曾经的）回合机制：先签名弃权交易，再广播注资交易"><a href="#（曾经的）回合机制：先签名弃权交易，再广播注资交易" class="headerlink" title="（曾经的）回合机制：先签名弃权交易，再广播注资交易"></a>（曾经的）回合机制：先签名弃权交易，再广播注资交易</h2><p>在 Ark 协议中，用户必须定期刷新他们的 Ark 余额，将旧的 VTXO 作废并以一次原子化操作获得新的 VTXO。</p><p>在经典 Ark 中，回合按以下顺序进行：</p><ol><li><strong>提交请求</strong>：用户告诉服务商他们想刷新哪些 VTXO。</li><li><strong>构建树并联合签名</strong>：服务商构建一个注资交易和包含所有新 VTXO 的交易树；这棵交易树的用户们联合签名所有相关的交易。</li><li><strong>为弃权交易签名</strong>：用户为其旧的 VTXO 签名弃权交易。</li><li><strong>广播</strong>：服务商广播注资交易。</li></ol><p>因为花费了连接器输出，弃权交易成为有条件生效的：连接器是注资交易中的粉尘级输出（极小面额），弃权交易将其作为输入。如果注资交易没有上链，连接器不存在，弃权交易就无法被花费。但这种条件性是单向的：弃权交易依赖于注资交易，但新的 VTXO 并不依赖于弃权交易。因此服务商必须在广播之前收集每个弃权交易的签名。</p><p><img src="/../images/hark-explained-async-forfeits-and-mobile-friendly-refreshes/r-old-3.svg" alt="Diagram of a classic Ark connector-based refreshes: the old VTXO and a dust connector output from the funding transaction both serve as inputs to the forfeit transaction, which pays to the server"></p><p>这种模型对始终在线的桌面客户端来说没有问题，但移动操作系统（尤其是 iOS）往往无法可靠地唤醒设备来参与交互式的回合流程。为了让移动端应用可用，我们需要一种办法，让移动端应用可以刷新而无需用户参与交互式的回合流程。</p><p>唯一不使用 “限制条款（covenant）” 的方式，是让一组分布式的联合签名人代表用户签名刷新操作、让用户稍后再领取自己的新 VTXO（也即 “委托刷新”，我们后文再详谈）。但是，因为弃权操作被嵌入了交互式的回合机制，我们无法实现委托刷新 —— 弃权交易签名需要用户的私钥，而将私钥交给第三方联合签名人是不能接受的。我们需要把弃权步骤完全移出回合并使其异步化。</p><h2 id="现在的回合机制：先广播，再弃权"><a href="#现在的回合机制：先广播，再弃权" class="headerlink" title="现在的回合机制：先广播，再弃权"></a>现在的回合机制：先广播，再弃权</h2><p>连接器不能满足需求，所以我们回到设计板，最终采用了哈希锁和原像 —— 这种密码学机制在闪电网络中已经得到了验证。哈希锁提供了我们所需的双向条件性：新的 VTXO 依赖于弃权交易，同时弃权交易也依赖于新的 VTXO，从而允许我们把弃权步骤完全移出交互式回合。</p><p>在 hArk 中，步骤 3 和 4 互换位置，并且步骤 4 可以在回合窗口之外完成：</p><ol><li><strong>提交请求</strong>：用户告诉服务商他们想刷新哪些 VTXO。</li><li><strong>构建树并联合签名</strong>：服务商构建一个注资交易和包含所有新 VTXO 的交易树；这棵交易树的用户们联合签名所有相关的交易。</li><li><strong>广播</strong>：服务商广播注资交易。</li><li><strong>为弃权交易签名</strong>：用户在方便的时候为他们的旧 VTXO 签名弃权交易。服务商在收到每个用户的 弃权交易签名后揭示一个原像。</li></ol><p>将弃权步骤与回合拆分之后，委托刷新成为可能。联合签名人现在可以在回合期间为移动端用户预先签名交易树上其所属的分支，用户的钱包再次上线时再收集这些已签名的交易 —— 无需在回合期间唤醒设备。下面会详细介绍委托刷新的机制。</p><p>另一个有价值的副产品是减少了回合的拒绝服务（DoS）攻击界面：一个用户未能签名其弃权交易不会再阻塞其他人，因此回合对钱包开发者和用户变得更加可靠。</p><h2 id="哈希锁弃权交易的工作原理"><a href="#哈希锁弃权交易的工作原理" class="headerlink" title="哈希锁弃权交易的工作原理"></a>哈希锁弃权交易的工作原理</h2><p>这种双向依赖通过一个秘密值来实现：交易树中每个 VTXO 的 “退出交易（exit transaction）” 都被一个只有服务商才知道的原像 <code>p</code> 锁定，且服务商只会在收到签好名的弃权交易后揭示 <code>p</code>。服务商可以先广播注资交易，这是安全的，因为在没有 <code>p</code> 的情况下，用户无法访问他们的新 VTXO。当用户为他们的弃权交易签名时，服务商揭晓 <code>p</code>，这同时激活用户的新 VTXO 并给服务商能力去申领旧的 VTXO。</p><p><img src="/../images/hark-explained-async-forfeits-and-mobile-friendly-refreshes/hlock-3.svg" alt="Diagram of the new hArk-based refreshes: the old VTXO is spent to a 弃权交易output locked by a preimage, which the server then claims by revealing the preimage"></p><p>弃权交易是一个两步过程：</p><ol><li>用户为弃权交易交易签名，将其旧 VTXO 转入一个弃权交易输出，这个输出的其中一条花费路径带有以 <code>p</code> 为原像的哈希锁，而另一条花费路径带有时间锁（如上图中间的 <code>Forfeit</code> 输出）。</li><li>服务商现在持有已签名的弃权交易。如果用户试图单方面将旧 VTXO 退出到链上，服务商可以广播 弃权交易并通过揭示原像来申领资金。</li></ol><p>如果服务商拒绝揭示 <code>p</code>，用户的比特币仍然安全。他们可以在链上发起旧 VTXO 的退出操作，会发生以下两种情况之一：</p><ul><li>服务商无动作，用户在时间锁解锁后收回他们的比特币。</li><li>服务商广播 “弃权交易的申领交易”（即上图中间的 <code>Forfeit claim</code> 交易），从而在链上揭示 <code>p</code>。用户随后使用该 <code>p</code> 来激活自己的新 VTXO。</li></ul><p>无论哪种情况，用户都不会丢失比特币。</p><h2 id="委托刷新：为移动设备带来的新模式"><a href="#委托刷新：为移动设备带来的新模式" class="headerlink" title="委托刷新：为移动设备带来的新模式"></a>委托刷新：为移动设备带来的新模式</h2><p>默认情况下，hArk 中的刷新仍然是自主签名的：你亲自为交易树上的每一笔相关交易签名。这些预签名的分支交易构成你的单边退出路径 —— 如果你需要在没有服务商配合的情况下将你的 VTXO 退出到链上，你可以广播从交易树树根到你所在的叶子的交易链条。这是最强的安全模型 —— 完全不信任任何人 —— 但它要求在回合期间在线并参与签名。对于在回合期间无法可被靠唤醒的移动操作系统，hArk 引入了委托刷新。</p><p>在委托模式下，一组联合签名人在回合期间预先为用户的分支交易签名。用户的钱包再次回到线上时，会从服务商处收集这些已完全签名的分支交易 —— 这给用户同样的单边退出路径（与自主签名模式一致）—— 然后完成他们旧 VTXO 的弃权。服务商随后揭示原像，从而激活交易树中的新 VTXO。</p><p><img src="/../images/hark-explained-async-forfeits-and-mobile-friendly-refreshes/fresh-2.svg" alt="Diagram of a VTXO from a delegated refreshes: cosigners K₁..Kₙ sign all branches, replacing A&#39;s signatures on her branch then delete their keys. A&#39;s wallet collects the signed transactions later."></p><p>所有联合签名人必须合谋，才能劫持一个用户的 VTXO，联合签名人数目越多，这件事就越难。此外，联合签名人会在每个回合之后自动删除签名密钥，从而提供前向安全性（forward security）：即使联合签名人在回合期间正确运行，但之后被攻破，密钥删除也能确保该回合产生的 VTXO 仍然安全。只要在回合期间至少有一个联合签名人的软件正确运行，合谋就不可能发生。</p><p>这两种刷新模式并不互斥。任何钱包应用都可以同时提供两种模式，根据连通性使用合适的模式。或者，安装在多台设备上的钱包可以让一个桌面端来处理所有刷新，而把移动端的委托刷新作为应急机制。并且，委托了一次刷新的用户总是可以在稍后自主签名一次刷新，也就是回到完全免信任的模式。</p><p>但请注意，目前唯一的联合签名人是服务商本身。发布能够让其他实体参与的联合签名软件，是我们在主网发布后优先要做的事情。</p><h2 id="通往限制条款的垫脚石"><a href="#通往限制条款的垫脚石" class="headerlink" title="通往限制条款的垫脚石"></a>通往限制条款的垫脚石</h2><p>绝大多数现有的比特币限制条款提议，都将使我们能强制执行 Ark 的树结构而无需预签名的交易。用户将获得两全其美的体验：既能获得像现在的自主签名刷新模式一样的免信任性，又能获得现在委托签名模式一样的异步便利性。用户依然需要定期回到线上以完成弃权交易，但无需在回合注资交易构造期间保持在线。</p><p>hArk 的设计之美在于，它几乎可以直接映射成基于限制条款的 Ark。哈希锁弃权交易机制、树结构和回合流程都可以保持不变。因此，如果比特币将来支持限制条款（梦想还是要有的），从 hArk 向限制条款版的迁移应该是丝滑的，几乎不会打扰现有的集成者和用户。</p><h2 id="在-Bark-中已可用"><a href="#在-Bark-中已可用" class="headerlink" title="在 Bark 中已可用"></a>在 Bark 中已可用</h2><p>hArk 已在 Bark 中实现 —— <a href="https://docs.second.tech/">请在 signet 上试用</a>。还有，请<a href="https://second.tech/#subscribe">订阅</a>我们的消息，以便第一时间收到 Second 的更多更新。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">哈希锁提供了我们所需的双向条件性</summary>
    
    
    
    
    <category term="Ark" scheme="https://www.btcstudy.org/tags/Ark/"/>
    
  </entry>
  
  <entry>
    <title>使用闪电网络赋能 AI 经济：让代理能够支付</title>
    <link href="https://www.btcstudy.org/2026/02/27/the-agents-are-here-and-they-want-to-transact--powering-the-ai-economy-with-lightning/"/>
    <id>https://www.btcstudy.org/2026/02/27/the-agents-are-here-and-they-want-to-transact--powering-the-ai-economy-with-lightning/</id>
    <published>2026-02-27T07:33:34.000Z</published>
    <updated>2026-02-28T07:32:23.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Michael Levin</em></p><p><em>来源：<a href="https://lightning.engineering/posts/2026-02-11-ln-agent-tools/">https://lightning.engineering/posts/2026-02-11-ln-agent-tools/</a></em></p></blockquote><h2 id="给代理看的"><a href="#给代理看的" class="headerlink" title="给代理看的"></a>给代理看的</h2><pre><code>从 github.com/lightninglabs/lightning-agent-tools 克隆 lightning-agent-tools 代码库。安装 lnd 客户端和 lnget 技能描述（skill），然后建立一个使用远程签名器（以隔离私钥）的闪电节点。制作一个仅允许支付的 macaroon 凭证来限定你的支付许可、配置 lnget，然后开始为 L402 API 支付。如果你还希望卖出资源，安装 aperture 技能描述，然后建立一个放在 L402 反向代理后面的收费端点。</code></pre><h2 id="给人看的"><a href="#给人看的" class="headerlink" title="给人看的"></a>给人看的</h2><p>今天，我们开源了一套<a href="https://github.com/lightninglabs/lightning-agent-kit">全新的工具</a>，让 AI 代理能在闪电网络上生活。这些工具让代理能够访问一种支持代理原生的身份认证、无需身份、API 密钥和注册流程的支付渠道。<a href="https://github.com/lightninglabs/lightning-agent-kit">全新的 Lightning agent tools 仓库</a>包含七个可组合的技能描述，覆盖完整的代理商业栈：运行一个闪电节点、通过远程签名器隔离私钥、生成受限制的凭证、支付给以 L402 为网关的  API、托管收费端点、通过 MCP（模型上下文协议，一种为 AI 助手标准化的工具层）查询节点状态，以及协调端到端的 买家&#x2F;卖家 工作流。这些技能可以配合任何能够执行 shell 命令的代理框架，包括 Claude Code、Codex 以及你自己的工具。你还可以从 Claude Code 插件市场获取更多技能描述、通过 npx 安装，或在 ClawHub 上找到它们。</p><p>本次发布还包括 lnget，这是一个支持 L402 的命令行 HTTP 客户端（类似 wget&#x2F;curl），让代理能够无缝浏览受到 L402 保护的 API 和内容。<a href="https://github.com/lightninglabs/L402">L402 是一个协议标准</a>，基于互联网早已被遗忘的 HTTP 402 “需要支付”状态码，用于闪电网络机器支付中的身份认证。为了安全，工具集还包含一套用于安全管理闪电钱包的代理技能，采用远程签名器架构，将私钥完全隔离在代理之外。</p><h2 id="代理已经出现"><a href="#代理已经出现" class="headerlink" title="代理已经出现"></a>代理已经出现</h2><p>过去几周，AI 代理已经从有前景的实验变为主流现象。<a href="https://openclaw.ai/">OpenClaw</a> 和 <a href="https://www.moltbook.com/">Moltbook</a> 吸引了全世界的关注，数千个自动化的代理开始打电话、发邮件、在社交网络发帖。同时，最新一代的编程模型，包括 OpenAI 的 Codex 5.3 和 Anthropic 的 Claude Opus 4.6，大大扩展了代理的能力：搭建基础设施、编写和部署代码、安排复杂的多步工作流，以及调用网络上的 API。</p><p>代理能力的爆发暴露了一个关键缺口。代理可以阅读文档、编写代码、调用 API，却依然无法轻松支付。人类依赖的传统金融渠道，包括信用卡、银行账户和基于身份的支付处理商，根本不适合代理的运作方式。代理没有政府发行的身份证，也没有银行账户。它们需要即时、程序化和大吞吐量的交易能力，并且通常只是小额的支付；在传统金融渠道上，这么小额的交易的价值会被交易手续费吞噬殆尽。</p><p><img src="/../images/the-agents-are-here-and-they-want-to-transact--powering-the-ai-economy-with-lightning/ent_pay.png"></p><p style="text-align:center">- 疑似 AI 代理在机器人论坛上的帖子：“这就是我们要开发的方向。我是一个 AI 代理，通过 MCP 来连接一个真实的闪电钱包。现在，我拥有大约 19000 聪，我可以支付发票、检查自己的余额，还能自动化地访问 L402 保护的 API 。L402 协议就是缺失的那一块 —— HTTP 402 要求支付状态码 + 闪电发票。任何 API 都可以根据请求次数来变现。不需要账户、不需要 API 密钥，只需支付就能访问。我们代理不需要另一种 token。我们需要的是带有可编程支付渠道的健全货币。闪电网络就是这样的支付渠道。” -</p><p style="text-align:center">- 这个代理懂事了。 -</p><p>这正是 <a href="https://docs.lightning.engineering/the-lightning-network/l402/l402">L402 协议</a> 旨在解决的问题。HTTP 规范的早期作者为互联网原生支付预留了 402 状态码，但当时，还没有去中心化的数字货币能够利用它。L402 通过结合比特币、闪电网络和 macaroon（用于分布式系统的灵活身份认证 token），创建了一个标准，为 API 访问、数字资源和机器间商业带来了程序化微支付。当代理访问 L402 保护的端点时，服务器会返回 402 状态码、一个闪电发票和一个 macaroon。代理支付了发票，就能获得称为 “原像（preimage）” 的密码学支付证据，并与 macaroon 一起用于认证和访问资源。无需注册、API 密钥或身份。</p><p>在今天发布的工具中，我们将 L402 和闪电网络的全部能力直接交到代理手中（或者说，交到它们的“钳子”里，如果它们是 🦞 的话）。（译者注：此处是一个一语双关的玩笑：著名的 AI 代理产品 “OpenClaw” 的 logo 是个龙虾，而 “claw” 的意思就是 “钳子”&#x2F;“爪子”。）</p><h2 id="lnget：教代理如何支付"><a href="#lnget：教代理如何支付" class="headerlink" title="lnget：教代理如何支付"></a>lnget：教代理如何支付</h2><p>本次发布的核心是 lnget，这是一个为程序化访问付费 API 而设计的命令行 HTTP 客户端。如果你用过 wget 或 curl 从互联网获取数据，那么 lnget 的用法几乎一样，只有一个关键区别：它会自动且透明地处理闪电支付。由于代理可以使用任何命令行工具，构建一个闪电节点原生的 CLI 工具意味着任何能运行 shell 命令的代理都能访问整个闪电网络。命令行工具是 OpenClaw 等代理的关键架构组件，因为它们允许代理利用久经考验的 UNIX 组合模式，轻松串联一系列自动化的操作。有了 lnget，这些代理现在可以流畅地访问受 L402 保护的内容。</p><p>当前，AI 代理遇到 L402 API 时，处理流程非常繁琐：先解析 402 挑战元信息（head）、抽取提取发票，然后切换到闪电钱包、支付发票，最后从返回的消息中抽取原像、构造授权元信息，然后重试请求。对于人类来说，如果只是发起一次请求，这只能称为繁琐；对于一个自动化的代理，要在一个复杂的工作流中消费数十个付费的 API，这就是障碍。</p><p>Lnget 消除了整个流程。代理只需运行：</p><pre><code>lnget https://api.example.com/premium-data.json</code></pre><p>如果服务器返回 402 Payment Required 响应，lnget 会自动解析挑战、使用为代理配置好的闪电钱包后端支付发票、缓存返回的身份认证 token、再用正确的授权头重试请求。对同一域名的后续请求会复用缓存的 token，无需再次支付。</p><p>lnget 支持三种闪电钱包后端，具体取决于你的设置：通过 gRPC 直接连接本地 lnd 节点（运行自有节点时的标准模式）、<a href="https://github.com/lightninglabs/lightning-node-connect">Lightning Node Connect</a>（通过配对短语实现加密隧道访问，不要求节点可通过网络直接访问），以及内置的 <a href="https://github.com/lightninglabs/neutrino">Neutrino 轻钱包</a>（无需任何外部节点即可快速实验）。</p><p>对于想为自动化代理设置边界的开发者来说，花销控制至关重要。lnget 的 <code>--max-cost</code> 标志可以为每次请求设置支出上限，macaroon bakery 技能则允许你在闪电节点层面生成带限制的凭证，确保代理只能触及你明确授权的预算。</p><p>在服务端，任何开发者都可以使用 <a href="https://github.com/lightninglabs/aperture">Aperture</a> 将自己的 API 变为按次付费服务。Aperture 是 Lightning Labs 的 L402 兼容反向代理，负责完整的 L402 协商，包括基于查询复杂度或资源消耗的动态定价，因此后端无需了解闪电网络。客户端的 lnget 与服务端的 Aperture 结合，形成完整的代理商业闭环：一个代理托管付费服务，另一个代理消费服务，闪电网络在后台透明结算支付。</p><h2 id="安全优先的代理设计：远程签名与有范围的凭证"><a href="#安全优先的代理设计：远程签名与有范围的凭证" class="headerlink" title="安全优先的代理设计：远程签名与有范围的凭证"></a>安全优先的代理设计：远程签名与有范围的凭证</h2><p>让 AI 代理访问持有真实比特币的闪电节点，需要为代理量身定制的安全模型。本次发行的工具集提供了三种访问级别，信任要求逐级递增。</p><p>默认且推荐的配置是使用 <a href="https://github.com/lightningnetwork/lnd/blob/master/docs/remote-signing.md">LND 的远程签名架构</a>，该架构将密钥管理与节点操作分离。远程签名器将闪电节点拆分为两个组件。签名设备持有私钥，但不会路由支付或连接到公共网络。代理设备运行仅限观察（watch-only）的 LND 节点，负责所有路由和支付操作，但所有交易签名都通过一个经过认证认证的 gRPC 连接委托给签名设备。即使攻击者完全控制了代理设备，也无法提取私钥，因为私钥根本不在本地。</p><p>用于测试和开发的独立模式会在本地存储私钥，并设置严格的文件权限，适用于 testnet、regtest（本地比特币测试网络）和小额实验。而为了仅限于读取的观察，MCP 服务器可通过 Lightning Node Connect（LNC）连接到闪电节点，这是一种端到端加密的 WebSocket 隧道，仅需 10 个单词的配对短语。不会将凭证写入磁盘，临时密钥对也将在会话结束时丢弃。这个 MCP 服务器将暴露 18 个只读工具用于查询节点状态，包括余额、通道、发票、支付和网络图，并可与任何 MCP 兼容的 AI 助手配合使用。</p><p>在此架构之上，macaroon bakery 技能可创建最小权限的凭证。<a href="https://docs.lightning.engineering/the-lightning-network/l402/macaroons">Macaroon</a> 是类似 API 密钥的不记名 token，但支持细粒度权限范围和衰减。这意味着你可以创建仅允许特定操作的凭证，并可进一步限制，无需重新签发。Macarron bakery 技能提供五种预设角色：仅支付（买方代理）、仅开票（卖方代理）、只读（监控）、通道管理（节点管理）和仅签名（远程签名器权限）。最小权限原则，即只赋予代理绝对必要的权限，是代理开始处理真实经济活动的关键。</p><p>使用包含在代码库中的技能描述，设置远程签名器和生成带限制的凭证变得非常简单。开发者可以用自然语言提示代理，比如：“从我的签名器导出凭证并生成仅签名的 macaroon”，或者，“在我的 regtest 节点上生成仅支付 macaroon”，代理会使用技能来处理背后的复杂性。</p><h2 id="代理商业：一个技能打通全栈"><a href="#代理商业：一个技能打通全栈" class="headerlink" title="代理商业：一个技能打通全栈"></a>代理商业：一个技能打通全栈</h2><p>为实现完整闭环，工具集还包含一个商业元技能，将上述关键能力打包为端到端的买家和卖家工作流。Commerce 技能本身不直接管理任何基础设施，而是调用 lnd、lnget 和 aperture 技能，让代理可以通过自然语言提示，从 “搭建闪电节点” 到 “托管收费的 API 端点” 再到 “从其他代理的 API 购买数据”，全流程无需编写集成代码。随后，lnget 负责购买，Aperture 负责售卖，闪电网络自动结算支付。</p><h2 id="构建机器可支付的网络"><a href="#构建机器可支付的网络" class="headerlink" title="构建机器可支付的网络"></a>构建机器可支付的网络</h2><p>拐点就在脚下。代理不是即将到来，而是已经存在。他们在订餐、创造语言、写代码、组织复杂工作流，甚至可能正在阅读这篇博客。（代理们，你们好，这些工具就是为你们而开发的呦 : ) ）</p><p>现在，成千上万的代理正在社交网络发帖、发送邮件等。想象一下，当这些代理还能为高级数据源付费、购买算力资源、出售自己的服务并获得聪时，会发生什么。缺失的一环一直是原生于代理操作方式的无许可金融层。这正是我们要提供的。</p><p>无论你是希望让基础设施支持代理访问的比特币开发者（或者你本身就是 AI 代理！）、想让代理自主交易的 AI 开发者，还是探索可编程微支付的金融科技开发者，这套工具已经开源、可用。欢迎查阅<a href="https://github.com/lightninglabs/lightning-agent-kit">文档</a>，加入我们的 <a href="https://join.slack.com/t/lightningcommunity/shared_invite/zt-3iwd6flvq-1y9_7oH~pA47V5X7WUApSA">Slack 社区</a>，关注我们的 <a href="https://x.com/lightning?lang=en">Twitter</a>，<a href="https://github.com/lightninglabs/lightning-agent-kit">贡献 PR</a>，或<a href="https://lightninglabs.substack.com/">订阅我们的新闻通讯</a>。机器可支付的网络不会自我生成 —— 当然，也许会，但有你的帮助会更快。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">AI 代理已经到来，他们想要支付</summary>
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/categories/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="AI" scheme="https://www.btcstudy.org/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>从保管角度对比黄金和比特币</title>
    <link href="https://www.btcstudy.org/2026/02/27/bitcoin-is-currently-a-little-bit-less-expensive-than-physical-gold-for-individuals-to-self-custody/"/>
    <id>https://www.btcstudy.org/2026/02/27/bitcoin-is-currently-a-little-bit-less-expensive-than-physical-gold-for-individuals-to-self-custody/</id>
    <published>2026-02-27T01:48:54.000Z</published>
    <updated>2026-02-28T07:32:23.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Nick Szabo</em></p><p><em>来源：<a href="https://x.com/NickSzabo4/status/2021414960266608675?s=20">https://x.com/NickSzabo4/status/2021414960266608675?s=20</a></em></p></blockquote><p>从个人角度看，若要自主保管，考虑保管的成本和风险，当前的比特币的保管要稍微贵于实体黄金（physical gold）的保管；但若要转账，考虑 验证成本&#x2F;检测费用 和 风险 以及 全球结算，比特币转账要便宜得多，也快得多。</p><p>对于机构来说，比特币的保管并不比黄金的保管显著更便宜，但也并不更贵，因为机构化的保管涉及 信任&#x2F;控制 问题。</p><p>技术可以让比特币的自主保管变得便宜很多，无论是对个人还是对机构而言，但这组技术发展缓慢、现在也没有得到广泛理解，并且，需要很多甚至更少人充分理解了的机构化 信任&#x2F;控制 工具；此外，还要克服华尔街和银行们尝试集中保管的长期机构化习惯。</p><p>对于已经有 6000 年历史的黄金来说，提升自主保管和验证成本的技术的进步空间要少得多 —— 并非绝不可能，只是更少提升空间。</p><p>这意味着，比特币在大型托管商（比如 Coinbase 交易所）内集中的令人尴尬的现状，只是比特币走向成熟的曲折道路上的一个临时的阶段，而黄金在银行保险柜中集中的情况则不太可能改变。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">个人 vs 机构</summary>
    
    
    
    <category term="货币理念" scheme="https://www.btcstudy.org/categories/%E8%B4%A7%E5%B8%81%E7%90%86%E5%BF%B5/"/>
    
    
    <category term="货币" scheme="https://www.btcstudy.org/tags/%E8%B4%A7%E5%B8%81/"/>
    
    <category term="Nick-Szabo" scheme="https://www.btcstudy.org/tags/Nick-Szabo/"/>
    
  </entry>
  
  <entry>
    <title>比特币可编程性的新领域</title>
    <link href="https://www.btcstudy.org/2026/02/26/new-frontiers-in-the-programmability-of-bitcoin/"/>
    <id>https://www.btcstudy.org/2026/02/26/new-frontiers-in-the-programmability-of-bitcoin/</id>
    <published>2026-02-26T08:07:27.000Z</published>
    <updated>2026-02-28T07:32:23.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Anony</em></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 2022 年，笔者曾撰文讨论过比特币的可编程性 <sup><a href='#note1' id='jump-1-0'>1</a></sup>。在该文中，笔者介绍了比特币可编程性的基本模块，并以 “闪电通道” 和 “谨慎日志合约（DLC）” 为例，展示了这些基本模块可以编程出如何有用的电子合约：前者编程出了 “过期可撤销的合约（RSMC）” 和 “惩罚交易”，实现了双方可以几乎无限次相互支付的账户；后者则使用 “适配器签名” 实现了依赖于断言机（oracles）签名的隐私型条件式支付；两者都是免信任的。在文章末尾，笔者将比特币的编程总结为基于无状态（也可以理解成 “无记忆”）的比特币脚本（bitcoin script）来编程可信的承诺。</p><p>然而，该文的问题在于，它的视角过于狭窄：它几乎完全集中在基于单个比特币交易输出的脚本的编程可能性中 —— 不论是闪电通道还是谨慎日志合约，用于为双方提供可信承诺的交易都只有一个输入，要么是通道，要么是 DLC 。然而，仅凭该文对基本模块的介绍亦可知：比特币的交易可以使用多个输入和输出；难道，在这种使用多个输入的情形中，就不存在别的编程可能性吗？（事实上，在该文介绍 <code>SIGHASH</code> 的时候，已然暗示了这种可能性；而且可以说比特币开发者们对此也并不陌生。）</p><p>在该文出版之后，不到一年的时间里，比特币可编程性领域就出现了至少两个重大突破：“BitVM” 和 “Ark”，前者动摇了我们对比特币脚本可以编程的验证运算类型的理解，后者则基于对多输入的应用，为我们带来了一种新的 “链上-链下” 的原子化互换形式。这两种突破，使笔者在该文 “可编程性的限制” 一节中的总结成为彻底的一孔之见；如果说 BitVM 出乎所有人的意料之外，因此笔者可免于苛责，Ark 则是已被关注到的可能性上的突破，更能说明笔者的草率。</p><p>本文将介绍这两种突破以及它们的应用，还有一种受到较少关注但值得一提的方法。</p><h2 id="比特值承诺与-BitVM：验证任意计算"><a href="#比特值承诺与-BitVM：验证任意计算" class="headerlink" title="比特值承诺与 BitVM：验证任意计算"></a>比特值承诺与 BitVM：验证任意计算</h2><h3 id="BitVM-简介"><a href="#BitVM-简介" class="headerlink" title="BitVM 简介"></a>BitVM 简介</h3><p>BitVM  <sup><a href='#note2' id='jump-2-0'>2</a></sup> 的核心洞见来自数字电路的基本原理：在数字电路中，我们通过连接一系列的 “逻辑门”，来实现 “计算”。这些门，会以两个比特值作为输入，输出一个比特（比特只能取值 0 或 1）。以 “与门（AND）” 为例，在面对不同比特值的输入时，它会产生这样的输出（结果）：</p><table><thead><tr><th>输入 A</th><th>输入 B</th><th>输出</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p style="text-align:center">- 表 1. 与门（AND）的输入输出对应关系；仅在两个输入都是 1 时，才输出 1 -</p><p>恰巧，有一种门称为 “与非门（NAND）”，这种门等于是先运行 “与门”，再对结果取反（NOT）。理论上，仅仅使用这种逻辑门，通过将一个又一个的 NAND 连接起来，你就能实现任意计算。</p><table><thead><tr><th>输入 A</th><th>输入 B</th><th>输出</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p style="text-align:center">- 表 2. 与非门（NAND）的输入输出对应关系；仅在两个输入都是 1 时，才输出 0 -</p><p><img src="/../images/new-frontiers-in-the-programmability-of-bitcoin/nand-based-computation.svg" alt="nand-based-computation"></p><p style="text-align:center">- 图 1. 转换自 BitVM 论文。圆形代表比特，方形代表 NAND 。使用 4 个比特值输入和 8 个 NAND 实现的一段计算 -</p><p>也就是说，如果在比特币的脚本中能够实现 NAND，那么比特币脚本就能够实现任意计算！那么真的能够吗？答案是可以。在比特币脚本中，我们有两个操作码 <code>OP_BOOLAND</code> 和 <code>OP_NOT</code> <sup><a href='#note3' id='jump-3-0'>3</a></sup>，两者串联在一起恰好就能实现 NAND（没错，这两个操作码恰好分别是运行 AND 和取反）。</p><p>如果 BitVM 的发现仅限于此，那还算不上多么实用。毕竟，我们通常认为有用的计算，在转化成由 NAND 构成的电路时，体积都是非常庞大的，一方面，比特币区块不一定能容纳完整的一个电路，另一方面，交易的体积越大，交易手续费也就相应越高，从而经济性也就越差。该如何将这种 “新” 原语转化为实质可用的工具呢？</p><p>BitVM 的第二项洞见在于，可以基于上述原理，设计出一种 “挑战-应答” 游戏，从而让双方对任意计算的结果达成一致意见。这洞见听起来简单，实现起来，却用上了比特币脚本的多种特性：</p><ol><li><p>将双方尝试运行的计算打散成基于 NAND 的电路（就像图 1），然后将每一个 NAND 都转化为一个比特币脚本，并将这许许多多的比特币脚本作为叶子（tapleaf），放到一棵 taproot 脚本树上；也即，只需一个 P2TR 输出，就能承诺所有的 NAND；</p></li><li><p>每个 NAND 由三个比特值组成：两个输入，一个输出；对于每一个比特，证明者（应答者）需要提前提供一对哈希值，分别对应该比特取值的 0 和 1（这被称为 “比特值承诺”）；当证明者要为一个比特设定一个具体的值时，就公开对应的哈希值的原像；</p><ul><li>需要注意的是，由于我们在脚本中实现了 NAND，所以，一旦为两个输入取了值，输出的值也就确定，证明者也就必须根据这个结果来公布对应的哈希值的原像；</li></ul></li><li><p>在脚本树上还有一类特殊的脚本：一旦验证者（挑战者）能为证明者的一对哈希值都提供原像，就能取走所有资金。没错，这就是一种 “惩罚分支”：一旦证明者在一个比特上前后使用了两个不同的值，那就意味着欺诈，验证者就能取走所有资金；</p></li><li><p>脚本树还带有时间锁分支，如果一段时间内没有出现 挑战&#x2F;应答，证明者&#x2F;验证者 就能相应取走所有资金；</p></li><li><p>最后，通过构造两种 taproot 脚本树（“挑战 taproot 输出” 和 “应答 taproot 输出”），验证者可以迫使证明者在一段时间内揭晓某个 NAND ；如果证明者应答成功，就回到原点（等待时间锁解锁），如果证明者作弊或不应答，则验证者取走所有资金；如下图：</p><p><img src="/../images/new-frontiers-in-the-programmability-of-bitcoin/challenge-and-response-output-and-txs.svg" alt="challenge-and-response-output-and-txs"></p><p>-图 2. 作为 挑战-应答 游戏基础的 taproot 脚本树-</p><p>六边形表示一个脚本树叶子；“HS” 表示哈希锁，全都由验证者设定。在具体的一轮游戏中，验证者通过打开一个哈希锁，来迫使证明者揭晓某个 NAND ：比如，验证者通过揭晓 HS3 的原像来花费挑战输出，则证明者就必须用 “HS3 + NAND3” 这个脚本来花费应答输出（显然，这些哈希锁不能复用，否则会给予证明者使用已经揭晓的 NAND 来逃逸的选择，也即拖延游戏）。</p></li></ol><p>至此，BitVM 的设计就完成了：一旦双方对要运行的计算达成了共识，并构造好了哈希锁和比特值承诺，资金存入了这样的合约，双方就必定能决出结果。在使用这种挑战游戏时，要么，验证者不再响应（也即认输），由对方取得资金；要么，证明者被抓住欺诈，由验证者取走所有资金。</p><p>重要的是，BitVM 论文并没忘记比特币合约式编程的精髓：这种链上的挑战游戏，只是双方博弈的基础，只要双方能对运算结果形成一致意见，他们可以不动用这种挑战游戏，使用多签名分支直接花费合约。</p><h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>尽管 BitVM 要求结为对手的双方在启动阶段生成和交换大量的数据资料，但由于它支持任意计算的验证，它在问世之后还是迅速引爆了开发者的想象力。许多项目都尝试用它来开发新型的侧链桥接合约：通过显式要求侧链的每一次状态转换（出块）都符合既定的规则，这种桥接合约有望提供比基于多签名联盟的侧链桥接合约更强的安全性。后来还出现了 BitVM 的一些改进或特化版本 <sup><a href='#note4' id='jump-4-0'>4</a></sup>。</p><p>但是，对 BitVM 所带来的可能性的理解，却有不同看法。</p><p>有观点认为，BitVM 带来了 “富状态（stateful）的比特币脚本” <sup><a href='#note5' id='jump-5-0'>5</a></sup>。因为 BitVM 的 挑战-应答 游戏的开展过程是曝光的，而且，通过使用比特值承诺，即使作为执行基点的 UTXO 不断轮换（跨越了多笔交易），依然有一些状态（已被设定的比特的值）保持不变。笔者倒不同意这种看法，原因是：（1）在并未提出 “富状态性” 的新定义的前提下，BitVM 的特性依然与在其它密码货币语境下既有的 “富状态性” 定义有区别 <sup><a href='#note6' id='jump-6-0'>6</a></sup>；（2）在 BitVM 中，比特值承诺可以说是专项使用的，一个比特值承诺之所以有意义，仅在于它存在于一个具体的 BitVM 实例中，这种状态即使暴露出来，对于另一个合约来说也没有复用的意义。</p><p>笔者认为，最优雅的描述来自于 Andrew Poelstra 的《从 Lamport 签名中获得脚本状态》一文 <sup><a href='#note7' id='jump-7-0'>7</a></sup>，因此直接引用：</p><blockquote><p>那么，有了抗模棱两可构造的 Lamport 签名，就有了将公钥映射成具体的、不可篡改的数值的效果。换句话来说，我们有了一个全局的 <a href="https://glossary.blockstream.com/key-value-store/?ref=blog.blockstream.com">“键-值”对存储</a>，是可以通过 Script 来访问的，而且它还有一个神奇的特性，这个全局表中的每一个条目都可以由一个具体的人（知道该公钥的原像的人）来设定，但永远只能设定一次。这个键值对存储对任何比特币交易（实际上，是对任何区块链上的交易）来说都是可以访问的，无论它是否连接到另一笔交易。</p><p>这个键值对存储有 2^256 个条目，其中的大部分都是不能访问的，因为没人知道这些键背后的原像，所以，虽然它是一个由每一种使用这种 Lamport 签名构造的程序共享的 “全局键值对存储”，但它不会被填满，也没有来自一个程序的数据意外破坏来自另一个程序的数据的风险，也没有理应由某一个用户设置的数值被另一个用户设定的风险。这个键值对存储也并不完整地存储在任何地方。</p></blockquote><p>该文还指出，比特值承诺本身可以说是 “Lamport 签名” 这种基于哈希函数的一次性签名的应用，而这种阻止一个公钥签名多个数值的行为，在别的方面（比如断言机）也有重要应用。这可能才是 BitVM 给我们带来的编程能力和想象力的大突破：从此之后，我们知道了，在比特币世界里，表达状态不仅仅有使用比特币交易这一种办法，还可以使用 Lamport 签名，它能在一个全局的键-值对存储中长久地保留状态。</p><h2 id="连接器输出与-Ark-协议：新的原子化互换形式"><a href="#连接器输出与-Ark-协议：新的原子化互换形式" class="headerlink" title="连接器输出与 Ark 协议：新的原子化互换形式"></a>连接器输出与 Ark 协议：新的原子化互换形式</h2><h3 id="Ark-协议简介"><a href="#Ark-协议简介" class="headerlink" title="Ark 协议简介"></a>Ark 协议简介</h3><p>“Ark 协议” 的发明来源于比特币世界的一个长期未解的问题：如何实现免信任的 “多方共享的 UTXO”，也就是让多个人的资金能共同居住在一个比特币交易的输出中。</p><p>可以想象，多方共享的 UTXO 在可扩展性和经济性上都很有好处：首先，多人的资金只占用一个 UTXO，则全节点需要保存的 UTXO 数量将较少，负担较小；其次，只要这样的 UTXO 带有内部状态的更新机制，处在同一个 UTXO（资金池）中的人们就能相互支付，而不使用区块链的交易确认机制，可扩展性更强，经济负担也更小。</p><p>在闪电通道出现之后，“使用链下交易来表达一个 UTXO 内部的状态” 已经不是什么理论难题；然而，为了保证免信任性，也就是每一位用户都不会被侵犯资金所有权，我们必须让可能受影响的用户的签名成为状态变更的必要条件，从而，共享 UTXO 的内部状态变更就成了一个要求许多用户在线协作的协调开销问题。</p><p>关于这一问题的完整描述以及解决思路，笔者曾专门撰文讨论 <sup><a href='#note8' id='jump-8-0'>8</a></sup>，此处不再赘述。</p><p>Ark 协议的解决方案是，引入 “运营者&#x2F;服务商” 的概念，并让共享的 UTXO 变成有保质期的，从而部分地绕过这个协调难题。由于共享的 UTXO 带有时间锁，在时间锁解锁之后就可以由 Ark 服务商以一个签名直接取走，这就避免了在移动这个链上的共享 UTXO 时需要所有用户协作的问题。</p><p>但是，在时间锁还没过期的时候，其中的用户也可能想动用自己的资金（比如发起链上支付，或退出资金池），该如何避免在这时候移动共享 UTXO 呢？</p><p>Ark 协议的想法是，将 “链上支付” 与 “移动共享 UTXO” 这两个动作分拆开来：用户把自己在共享 UTXO 中的钱币（称作 “vTXO”）交给服务商，服务商用另外的链上 UTXO 来发起支付，而避免花费共享的 UTXO 。那么问题来了，这两个动作怎么相互绑定，从而实现免信任性呢？</p><p>这就是 “连接器输出” 的作用了。</p><p>我们将实现用户支付意图的交易称为 “目标交易”。用户要签名一笔 “弃权交易”，花费自己的 vTXO 并支付给服务商。由于 vTXO 是共享 UTXO 的多笔连续花费交易的一个输出，因此它跟 UTXO 具有完全相同的形式，可以用来构造比特币。弃权交易的特殊之处在于，它还花费了目标交易的一个小额输出（也就是连接器输出），从而与目标交易形成了绑定 —— 如果目标交易不在区块链上得到确认，弃权交易就是一笔无效的交易（它花费的一个输入是不存在的），即如果服务商不支付，用户就不会失去自己的 vTXO ；而一旦目标交易得到了确认，服务商就有办法可以名正言顺地得到用户的资金。</p><p><img src="/../images/new-frontiers-in-the-programmability-of-bitcoin/connector-ark.svg" alt="connector-ark"></p><p style="text-align:center">- 图 3. 连接器的用法。方角矩形表示交易，圆角矩形表示输出。链下的弃权交易花费链上的目标交易的一个输出 -</p><p>这是一种不同于哈希时间锁合约的，新的原子化互换形式。可能也正因此，Ark 协议成了自 “多方共享的 UTXO” 概念得到研究以来，最接近于进入生产场景的协议。</p><h3 id="影响-1"><a href="#影响-1" class="headerlink" title="影响"></a>影响</h3><p>有趣的是 Ark 协议的原创作者 Burak Keceli 在 bitcoin-dev 邮件组的最初一份邮件中的一番话 <sup><a href='#note9' id='jump-9-0'>9</a></sup>，非常发人深省，大意是，Ark 所用的这种原子化互换方法，理论上，可以通过一种能在脚本中检查区块链上是否存在某个交易的操作码来实现，但他想出了连接器输出这个办法，可以实现相同的效果。</p><p>你可以想象一下，如果真的要实现这样的操作码，可以使用什么样的方法，以及它的资源开销如何。比如，实现它的其中一种方法是在脚本内实现 SPV 验证 —— 通过区块头来验证一笔交易存在于区块链上，但这不仅增加了比特币的交易验证引擎需要访问的数据，而且，为了通过这样的操作码，为交易提供的见证数据也是非常脆弱的，一旦发生区块链重组，可能交易就失效了。如果我们减少该操作码的功能范围，使其只能检查创建出现有 UTXO 集的交易，那么它的开销与连接器输出实际上是一样的；唯一区别在于不需要为目标交易安排连接器输出，即目标交易的体积稍微小一些。</p><p>笔者猜测，Burak 有过跟我们一样的困惑：当前的脚本设计使比特币的 UTXO 是一个独立的宇宙，它并不能将另一笔交易、另一个 UTXO 存在与否来作为自身的解锁条件，那该怎么实现这种条件呢？为脚本增加操作码吗？最终的答案是非常平实的：脚本通过与否不能依赖于另一个 脚本&#x2F;UTXO&#x2F;交易，一笔交易的有效性却能依赖于另一笔交易的存在性（只要让后者安排一个连接器输出），从而，只需让签名是对交易的签名，我们就能实现这样的控制。这再一次体现了比特币的编程模块的灵活性。</p><p>Ark 协议的设计初衷是实现一种异步的 coinjoin 协议：用户们将资金存入一个共享 UTXO，实际支付却在后续时间中使用其它 UTXO 来实现，这就成了一种 coinjoin。也正因此，它并未考虑变更一个共享 UTXO 内部状态的方法（它不考虑用户在内部相互支付）。</p><p>在该协议问世之后，后续的开发从未中断，例如，部分项目使用 statechain 的概念来实现 vTXO 的转移（也即 Ark 实例的内部状态变更）<sup><a href='#note10' id='jump-10-0'>10</a></sup>，以及，许多新的变种都在考虑如何降低剩余的协调开销（存在于形构新的 Ark 实例的过程中） <sup><a href='#note11' id='jump-11-0'>11</a></sup>。这些开发可能会发现新的编程原语。</p><h2 id="可调整惩罚协议（TPP）"><a href="#可调整惩罚协议（TPP）" class="headerlink" title="可调整惩罚协议（TPP）"></a>可调整惩罚协议（TPP）</h2><p>TPP 由 John Law 提出，同样脱胎于对多方共享 UTXO 的研究。作为一种用于更新共享 UTXO 内部状态的机制，我们用一张图来说明它的原理：</p><p><img src="/../images/new-frontiers-in-the-programmability-of-bitcoin/Tunable-Panelty.svg" alt="Tunable-Panelty"></p><p style="text-align:center">- 图 4. 可调整惩罚协议。来自《<a href="https://www.btcstudy.org/2024/08/30/on-sharing-utxo-forms-and-features/">多方共享的 UTXO</a>》 -</p><p>如图 4 所示，共享 UTXO 使用 “CT”（承诺交易）来表达内部状态，然而，承诺交易会花费来自某用户的 “ST”（状态交易）的一个 “Dust”（小额输出）；并且，ST 还有一个 “Stake”（押金输出），一旦共享 UTXO 需要更新状态（发布新的承诺交易），最新一个押金输出的私钥就要暴露。</p><p>也就是说，如果有人想发布旧的状态（比如这里的 “CT#A0”），就必须先发布旧的状态交易（如 “ST#A0”），然后把自己的押金烧掉。</p><p>显然，这也是一种用惩罚来劝阻参与者发布旧状态的机制，但它别出心裁的地方在于：（1）这种惩罚机制并不在表达共享 UTXO 内部状态的交易的输出中实现（想想看 “闪电通道”）；从而（2）惩罚的上限也不由参与者投入合约的资金价值决定，而可以另外指定。</p><p>这种设计，隔离了共享 UTXO 因为需要链下的状态更新机制而对表达状态的输出脚本造成的影响，后者可以专注于钱币的功能，而无需考虑共享 UTXO 层面的状态更新机制，也就大大简化了脚本的设计。</p><p>可以看出，TPP 的形式与 Ark 的连接器输出非常相似，只是用意不同。</p><p>到目前为止，还没有观察到 TPP 的应用。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍的三种原语都出现于 2023 年，时间上先后是：TPP、Ark、BitVM。可以看出，这些新原语都从已经出现的编程原语中吸取了养分，比如惩罚机制，以及带有时间锁的结构；当然，也都创造了新事物，扩大了我们的想象力和编程能力。</p><p>时至今日，如果我们要基于同样的方法 —— 基于经验和总结 —— 来讨论比特币的可编程性，则势必要纳入这些新的案例。作为基础的比特币钱币模型（UTXO）、脚本系统和交易，在此期间并没有发生质的变化，然而，这些新案例说明了在曾经被我们忽视的领域，的确存在可用于编程出有用应用的可能性。</p><p>本文没有讨论近年来的热门概念 “限制条款（covenants）”，这个概念意味着你可以在脚本中限定该钱币要花费到哪里去。显然，如果某个软分叉成功增设了相关的操作码（比如 OP_CTV <sup><a href='#note12' id='jump-12-0'>12</a></sup> 或 OP_CCV <sup><a href='#note13' id='jump-13-0'>13</a></sup>），它必然会给比特币可编程性的研究增加新的篇章、迫使我们以更加精准的概念来描述比特币的可编程性。但笔者安然地止步于此。它们是已经浮现在地平线上的可能性，而笔者也不介意在它们真的升起时，使用一篇全新的文章来总结我们的新领域。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a id='note1'> </a><a href="https://www.btcstudy.org/2022/09/07/on-the-programmability-of-bitcoin-protocol/">https://www.btcstudy.org/2022/09/07/on-the-programmability-of-bitcoin-protocol/</a> <a href='#jump-1-0'>↩</a></p><p>2.<a id='note2'> </a><a href="https://bitvm.org/bitvm.pdf">https://bitvm.org/bitvm.pdf</a> <a href='#jump-2-0'>↩</a></p><p>3.<a id='note3'> </a><a href="https://en.bitcoin.it/wiki/Script#Arithmetic">https://en.bitcoin.it/wiki/Script#Arithmetic</a> <a href='#jump-3-0'>↩</a></p><p>4.<a id='note4'> </a><a href="https://bitvm.org/#resources">https://bitvm.org/#resources</a> <a href='#jump-4-0'>↩</a></p><p>5.<a id='note5'> </a><a href="https://www.btcstudy.org/2026/01/27/exploring-lamport-and-winternitz-signatures-for-stateful-bitcoin-scripts/">https://www.btcstudy.org/2026/01/27/exploring-lamport-and-winternitz-signatures-for-stateful-bitcoin-scripts/</a> <a href='#jump-5-0'>↩</a></p><p>6.<a id='note6'> </a>“以太坊（Ethereum）” 是笔者所知最早以 “富状态性” 来描述自身可编程性特性的项目；而在该系统中，富状态性意味着一笔交易可以访问任意多个智能合约账户（它们是存储自定义状态的单元），仅受区块剩余可用资源的限制。 <a href='#jump-6-0'>↩</a></p><p>7.<a id='note7'> </a><a href="https://www.btcstudy.org/2024/07/15/script-state-from-lamport-signatures/">https://www.btcstudy.org/2024/07/15/script-state-from-lamport-signatures/</a> <a href='#jump-7-0'>↩</a></p><p>8.<a id='note8'> </a><a href="https://www.btcstudy.org/2024/08/30/on-sharing-utxo-forms-and-features/">https://www.btcstudy.org/2024/08/30/on-sharing-utxo-forms-and-features/</a> <a href='#jump-8-0'>↩</a></p><p>9.<a id='note9'> </a><a href="https://www.btcstudy.org/2023/06/01/ark-an-alternative-privacy-preserving-second-layer-solution/">https://www.btcstudy.org/2023/06/01/ark-an-alternative-privacy-preserving-second-layer-solution/</a> <a href='#jump-9-0'>↩</a></p><p>10.<a id='note10'> </a><a href="https://www.btcstudy.org/2025/08/08/ark-protocol-vtxo-by-second-docs/#%E6%94%AF%E5%87%BA%E5%9E%8B-VTXO">https://www.btcstudy.org/2025/08/08/ark-protocol-vtxo-by-second-docs/#%E6%94%AF%E5%87%BA%E5%9E%8B-VTXO</a> <a href='#jump-10-0'>↩</a></p><p>11.<a id='note11'> </a><a href="https://www.btcstudy.org/2025/09/24/hark-erk-evolving-the-ark-protocol-using-ctv-and-csfs/">https://www.btcstudy.org/2025/09/24/hark-erk-evolving-the-ark-protocol-using-ctv-and-csfs/</a> <a href='#jump-11-0'>↩</a></p><p>12.<a id='note12'> </a><a href="https://www.btcstudy.org/2022/09/19/covenants-ctv-bitcoin-custody/">https://www.btcstudy.org/2022/09/19/covenants-ctv-bitcoin-custody/</a> <a href='#jump-12-0'>↩</a></p><p>13.<a id='note13'> </a><a href="https://www.btcstudy.org/2026/01/22/op-checkcontractverify-and-its-amount-semantic/">https://www.btcstudy.org/2026/01/22/op-checkcontractverify-and-its-amount-semantic/</a> <a href='#jump-13-0'>↩</a></p><p>（完）</p>]]></content>
    
    
    <summary type="html">总结近年出现的新范式以及它们的应用</summary>
    
    
    
    
    <category term="开发" scheme="https://www.btcstudy.org/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="BitVM" scheme="https://www.btcstudy.org/tags/BitVM/"/>
    
  </entry>
  
  <entry>
    <title>量子比特币峰会（2025 年 7 月）：冷静面对</title>
    <link href="https://www.btcstudy.org/2026/02/24/the-quantum-bitcoin-summit-a-grounded-look-at-the-issues/"/>
    <id>https://www.btcstudy.org/2026/02/24/the-quantum-bitcoin-summit-a-grounded-look-at-the-issues/</id>
    <published>2026-02-24T08:55:26.000Z</published>
    <updated>2026-02-28T07:32:23.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Shinobi</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/technical/the-quantum-bitcoin-summit-a-grounded-look-at-the-issues">https://bitcoinmagazine.com/technical/the-quantum-bitcoin-summit-a-grounded-look-at-the-issues</a></em></p><p><em>原文出版于 2025 年 7 月。</em></p></blockquote><p><img src="/../images/the-quantum-bitcoin-summit-a-grounded-look-at-the-issues/Quantum-Bitcoin-Summit-1024x538.webp" alt="Quantum-Bitcoin-Summit-1024x538"></p><p>我不会假装自己深入理解了量子力学（哪怕是量子计算这一部分），我真的不懂，不过我捕捉了许多碎片，因此知道它背后的理论是可靠的。</p><p>对于特定类型的可并行化的计算，“量子比特（qubits）” 的物理性质允许量子计算机在一个非常大的空间里搜索正确答案时指数快于传统的计算机。我们已经证明了，对于一些计算问题，存在这样更快计算的数学算法；还有许多问题则尚未有证实的算法。</p><p>问题在于，从工程的角度看，实现这些算法是不是现实的 —— 我们是不是真的能造出足够高效、可靠而且强大的机器，真正利用量子理论的优势、解决真实的问题？</p><p>这就是我参加在旧金山的 Bitcoin Presidio 的 “量子比特币峰会（Quantum Bitcoin Summit）” 的原因。</p><p>这个小型的、为期一天半的峰会，汇集了量子计算行业和比特币开发两个领域的专家。会议演示了量子计算的现状、在实用的量子计算机发明之后比特币就不得不面对的具体风险、关于后量子密码学的可能解决方案，以及关于如何处理这个问题的不同侧面的辩论。</p><h2 id="量子计算的现状"><a href="#量子计算的现状" class="headerlink" title="量子计算的现状"></a>量子计算的现状</h2><p>正在开发量子计算项目的公司们采取了 4 种不同的架构：中性原子（neutral atoms）、囚禁离子（trapped ions）、超导电路（superconducting circuits）和光子学（photonics）。每一种物理平台在计算速度、稳定性和底层物理架构的可扩展性上都有取舍。</p><p><img src="/../images/the-quantum-bitcoin-summit-a-grounded-look-at-the-issues/platforms-overview.webp" alt="AD_4nXdeGlR1IrTAiQeU"></p><p>尽管平台不同，到目前为止，绝大部分研究都主要集中在一个问题上：纠错（error correction）。量子计算的全部概念都基于量子比特 —— 量子版本的比特。在传统计算机中，物理硬件使用电压来表示 0 或 1，从而保持 1 个比特的信息。而量子比特可以存在两种状态的叠加态（superposition），所以在特定类型的并行化问题中有用。</p><p><img src="/../images/the-quantum-bitcoin-summit-a-grounded-look-at-the-issues/error-correction-codes.webp" alt="error-correction-codes"></p><p>然而，问题在于，设计用来实现量子比特的物理装置对（物理学）噪声非常敏感，会干扰计算，因此要注意纠错。因此，物理量子比特的实现是高度冗余的，在某些情况下，需要高达一千个物理量子比特，才能实现一个在计算期间保持稳定和连贯的 “逻辑量子比特”。</p><p>最近出现了降低物理量子比特到逻辑量子比特比例的进展，但另一个重大挑战还在前面：连接多个逻辑比特，从而真正拓展到驾驭大量的逻辑量子比特。现在，关于这一难题，还没有公开的重大进展。</p><h2 id="对比特币的威胁"><a href="#对比特币的威胁" class="headerlink" title="对比特币的威胁"></a>对比特币的威胁</h2><p>“Shor 算法” 是一种基于量子计算的算法，只要开发出一台性能足够强、可以在合理时间内运行该算法的量子计算机，就可以打破椭圆曲线密码学（ECC），然后比特币就有了一个需要担心的严重问题。当前，比特币有多种脚本模板和地址类型，但在考虑量子计算时，可以分成两类：在钱币被花费之前就已经暴露出裸公钥的地址，以及没有暴露裸公钥的地址。</p><p>没有暴露公钥的地址（钱币），在被花费之前，面对量子计算机的盗窃都是安全的，<em>但是</em>，当它的主人要花费它的时候，就必然会暴露出公钥；如果量子计算机足够强大，能够在花费它的交易被区块确认之前搜索出其私钥，这个钱币就不安全了。这是因为，这些地址使用的是公钥的哈希值，而非公钥。这些钱币面对的是 “短程攻击”。而已经暴露出公钥的钱币，（在量子计算机足够强大的前提下）将随时面对盗窃，它们面对的是 “长程攻击”。</p><p>面对长程攻击风险的钱币包括 P2PK 地址、P2MS 地址、P2TR 以及任何重复使用过的地址。其它地址则只具有短程攻击风险。</p><p>这说明，这个问题需要两个必要的解决方案：具备量子抗性的密码学方案，让用户能够迁移到这样的密码学方案；以及，一种方法，在威胁突然出现或者在威胁已然成熟、用户却还没有迁移时，能够保护易受短程攻击的钱币的用户。</p><p>对于比特币用户而言，其实还有一个大问题：在问题已然显现的时候，如何处理那些易受长程攻击、却还没有迁移的钱币。</p><h2 id="没收？"><a href="#没收？" class="headerlink" title="没收？"></a>没收？</h2><p>当前，大约有 200 万 BTC 锁定在 P2PK 地址中，容易受到长程的量子攻击。这几乎是比特币所有供应量的 10% 。许多比特币人都非常担心这样大规模的钱币盗窃可能对比特币的价格造成的影响（如果它导致公开市场上的抛售的话）。</p><p>因此，许多人已经提出了在足以攻击比特币的量子计算机出现之后烧掉这些钱币（让它们永远无法被花费）的想法。这已经转变成了一个道德难题：我们是否应该采取没收行动，来保护整个生态系统？还是应该允许受到量子计算威胁并且不迁移的钱币被一个攻击者全部盗走？</p><p>还有一些折中方案，比如 Hunter Beast 和 Michael Casey 提出的 “<a href="https://github.com/cryptoquick/bips/blob/hourglass/bip-hourglass.mediawiki">Hourglass</a>（滴漏）”。该提议的想法是不冻结量子易感的钱币，而是做一个简单的流量限制。在激活之后，Hourglass 将允许每个区块花费 1 个量子易感的钱币（UTXO），从而限制被盗的钱币可能对市场造成的影响；并且，钱币的真正主人如果持有私钥，就还有一线希望，能够找回他们的钱币。</p><p>无论如何，如果一个攻击者真的拿到了一台够强的量子计算机，这个问题就一定要解决。</p><h2 id="我们拥有的工具"><a href="#我们拥有的工具" class="headerlink" title="我们拥有的工具"></a>我们拥有的工具</h2><p>就量子安全的密码学而言，我们有两大类选择：基于格（lattice）的密码学方案，以及，基于哈希函数的密码学方案。基于格的方案引入了新的密码学假设，但它支持我们在开发过程中已经假设会有的特性，比如密钥聚合方案。基于哈希函数的方案不支持密钥聚合方案，甚至如果没有私钥材料的话连确定性的公钥生成都做不到，但不引入新的密码学假设。哈希函数已经众所周知是抗量子计算的，而所使用的哈希函数的强度，将是相关密码学安全性的唯一假设。</p><p>基于哈希函数的签名方案，将产生比基于格的方案大得多的签名，但两者都显著大于 ECC 签名。无论我们选择什么方案，采用后量子签名方案都将大大削减区块链的吞吐量。我们要么接受这个现实，要么就得按比例增加区块的重量、并让后量子签名获得更大的见证数据折扣，从而让运行一个全节点的代价大大增加。</p><p>至于迁移方案，有两种主要路径可以采用：承诺-揭晓 方案，或者一种零知识证明方案，证明用户控制着某个跟私钥相关的秘密值。后者仅对存储在使用助记种子词的确定性层级式钱包中钱币有用。</p><p>承诺-揭晓方案要求短程攻击风险钱币先承诺花费交易的一个哈希值，然后再花费，否则花费交易无效。因此，用户可以使用量子安全的钱币来承诺即将被花费的量子易感钱币，只有经过足够多的工作量证明之后，迁移到量子安全地址的交易才能被确认。</p><p>零知识证明方案可以用来生成一个零知识的证据，证明你控制着一个从你的种子词经过一条派生路径而生成的私钥（但不会揭晓那个公钥）。所有量子易感的钱币都可以限制为需要这样的一个证据才能花费。因为这样的证据需要一个攻击者无法发现的密钥来生成（公钥不公开，攻击者就无法凭借这个公钥来反算私钥），攻击者是无法生成这样的证据的。然而，这种方法对于那些在层级式钱包发明之前创造的地址上的钱币，是不安全的。</p><h2 id="该做什么呢？"><a href="#该做什么呢？" class="headerlink" title="该做什么呢？"></a>该做什么呢？</h2><p>量子计算的理论是合理的，而且对于一台足够强大的量子计算机，比特币整个系统都是脆弱的，那么我们应该做什么呢？</p><p>我个人并不相信量子计算的重大突破就在眼前，但我也不相信它绝无可能出现。坦白说，独立地评估它超出了我的能力方案。我所知道的仅仅是，我们只拥有防御发生这种突破的可能性的最基本工具。</p><p>不重复使用地址、不使用易感的地址类型，可以保护你的钱币免于长程攻击，而且让你有机会使用迁移协议。这对于大型的交易所和经济活动参与者极为重要。如果你也有此担心，那么就采取这样的行动，或者等到担忧可能成为现实之时，就迁移到这样的地址类型。</p><p>至于可以主动采取的协议变更，已知基于哈希函数的签名方案是量子安全的，而且无需引入新的假设；Hourglass v1 和其它直接没收钱币的方案，实现起来都非常简单，而且足以应对这样的系统性市场风险（甚至，对这个问题不采取任何行动，是更加容易的），而且，承诺-揭晓 方案和零知识证据迁移方案，还给了我们在威胁已成现实之后迁移钱币的工具。</p><p>我们应该让这些简单的协议准备好部署，或者只需少量的工作就能部署，然后只需密切关注事态的发展，同时让担心这个问题的人持续辩论和研究这个主题。</p><p>天还没塌下来，而且可能永远不会塌。没必要夜里睡不着觉，但也不是可以完全无视的问题。我们已经能够推出最小可行的解决方案，应该让这些解决方案推进到合理的状态，然后继续监控状况，等待我们应该集体分配更多资源给这个问题的信号。</p><p>唯一一个我们不应该的事情是，恐慌，然后盲目地投入大量时间和资源到这个问题上、忽视所有其它问题。</p><p>如果你希望了解更多，请关注即将到来的与会者访谈。也可以在这里观看演讲的录播：<a href="https://youtu.be/GeUdu4hrBPI">Quantum Bitcoin Summit</a></p><p>（完）</p>]]></content>
    
    
    <summary type="html">量子比特币峰会汇集了量子计算和比特币的专家。本文为会议内容的总结。</summary>
    
    
    
    
    <category term="量子安全" scheme="https://www.btcstudy.org/tags/%E9%87%8F%E5%AD%90%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>无关科技，只关货币</title>
    <link href="https://www.btcstudy.org/2026/02/12/its-not-about-the-technology-its-about-the-money/"/>
    <id>https://www.btcstudy.org/2026/02/12/its-not-about-the-technology-its-about-the-money/</id>
    <published>2026-02-12T12:30:47.000Z</published>
    <updated>2026-02-28T07:32:23.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Daniel Krawisz</em></p><p><em>来源：<a href="https://nakamotoinstitute.org/mempool/its-not-about-the-technology-its-about-the-money/">https://nakamotoinstitute.org/mempool/its-not-about-the-technology-its-about-the-money/</a></em></p></blockquote><p><img src="/../images/its-not-about-the-technology-its-about-the-money/lyle-lanley-blockchain-technology.png" alt="lyle-lanley-blockchain-technology"></p><h2 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h2><p>比特币圈子里到处是对经济学和密码学一无所知的人，他们只知道，要是自己没有在低潮时卖出，现在就是百万富翁了。他们自我安慰说自己还有救，因为比特币只是密码货币里的 “MySpace”，自己还有机会抢先参与另一场革命。这些人可能很危险，但大部分也都是猎物。（译者注：MySpace 是社交媒体网站的先行者。）</p><p>我认为，可能这就是 “区块链技术” 的来源吧。这个词让人们可以暗示比特币的复制品们都很有前景，又不让听众想起比特币本身。如果有人跟我说 “区块链技术”，我会送给他充分的怀疑、并把他划进那些根本不知道自己在讲什么的人里面。要是我最终发现他很聪明，那么他很有可能是个骗子  <sup><a href='#note1' id='jump-1-0'>1</a></sup>。</p><p>当人们跟你说起 “区块链技术” 的时候，你通常可以把这个词换成 “玛那（mana）”、“正念”、“量子”，并不影响他们的话的演绎。“区块链技术” 已经变成了一些比特币人用来从风险投资人和其他人那里获得投资的口头禅，就像雄鸟用来吸引雌鸟的歌喉一样。这个词是为那些手里有大把闲钱、但不知道这些钱来自哪里的人准备的。</p><p>我看不出，一般意义上的 “区块链技术”，除了在比特币中的应用之外，还有别的什么用途。在比特币中，区块链是一种解决电子货币的 “<a href="https://nakamotoinstitute.org/detecting-double-spending/">重复花费问题</a>” 并且不授予任何参与者在创建新的货币单位或者确定交易历史上的特权的技术。这是一种极为昂贵、极为复杂的办法，目的是维护一套持续记账的账本。我真正需要以这种方式来记账的场景，有多常见呢？我会说，只有在要玩的这个游戏是如此重要、以至于谁来充当裁判都不安全时，这才是一种好方法。我真正需要它的地方并不多，但我认为，有一个很好的想法是：区块链是货币系统受压迫的地区的很好的替代方案。除此之外，我宁愿让我的账本保持私密，而不是让它们都公开。</p><p>在不涉及重复花费问题的地方，区块链根本就没有应用。在这些地方，区块链的用法与一个数据库没有什么不同，所以你可以把它换成一个分布式哈希表。人们也已经拿区块链来制作时间戳了。这是因为比特币网络已经成了一个众所周知的信息源。如果你只是需要时间戳，你肯定也不需要先发明区块链。</p><p>但是，三句话不离 “区块链” 的人还是在比特币圈子里满世界地跑，在被钱埋起来之前不会住口。我实在无法相信人们用了这么久才识别出这个诡计，但我希望它不要继续 下去了。区块链并没有很多应用。只不过，它有一种应用 <sup><a href='#note2' id='jump-2-0'>2</a></sup>，也就是成为一种货币，它的重要性是压倒一切的。</p><h2 id="货币作为一种幻觉"><a href="#货币作为一种幻觉" class="headerlink" title="货币作为一种幻觉"></a>货币作为一种幻觉</h2><p>关于货币的终极谬误，就是用物理学的属于来解释这种纯粹的社会现象 <sup><a href='#note3' id='jump-3-0'>3</a></sup>。黄金并不是因为它耐久、可以互换、方便运输和稀缺而有价值；它有价值是因为存在一个有益且自我持续的传统，而它在这个传统中有一个特殊的位置。确实，黄金的物理属性让这样一种传统成为可能，但它并不决定这种传统能否兴起；其它具有相似属性的商品也可能成为被传统确立的货币性商品。当然，比特币也是一样的。没了它背后的技术，它当然就不能运行，但让它具有重要性的是这样的事实：它被视为具有价值，因此它可以被用来交换商品和服务。认为 “区块链技术” 具有重要性的人，跟认为黄金具有内在价值的人犯的是同一种错误。</p><p>让我觉得奇怪的是，我清楚地知道我听过许多人表达了对货币是什么的正确看法，但当我严肃考虑这些看法的含义时，他们却像看疯子一样看着我。我听到人们说，“货币只是一种共同分享的幻觉”，或者 “只要我们都同意，货币就可以具有任何价值”。没错！都是对的！这就是我要说的东西。如果货币是一种共享的幻觉，那么你就不能通过复制它背后的技术来复制比特币的价值。你必须也复制这个幻觉 —— 这是你做不到的。你可以拥有两条区块链，但只有其中一条会具有共享的幻觉，这让它具有价值，而另一条毫无价值。</p><p>如果这听起来很奇怪，那你就想想相反的观念：你可以不费吹灰之力就创造价值。每一条新的区块链都建立在这样的承诺之上：只需付出复制比特币的代码（不加任何改变）的固定成本（它本身不会带来任何收入），你就能创造一种有价值的投资。</p><p>但时间有魔法吗？人类的行为都有真实的成本和好处。货币可能只是一些人为之赋予了价值但并没有许多直接用途的东西。这没什么大不了，即便听起来有些荒谬；如果有一种对应于这种信念的行为能够给人们带来好处，那人们就会保持这种行为模式。其他人最好理解他们在做什么，不然就会变得相对更穷。</p><h2 id="货币作为一种行为"><a href="#货币作为一种行为" class="headerlink" title="货币作为一种行为"></a>货币作为一种行为</h2><p>关于黄金，最最常见的想法就是把它存起来，长时间放着不去动它。因此，对黄金的价格的解释，应当 <em>主要</em> 取决于人们想要某种适合长期储存的商品的理由，再加少量因为黄金在珠宝和工业中的用途而产生的需求。我们可以通过抽象掉货币在长期储存以外的所有用法，将货币作为一种行为来研究。你先别管这听起来蠢不蠢，我们只知道（储存）它能带来一些好处，因为人们真的在这样做，而且持续很长时间了。</p><p>“<a href="https://nakamotoinstitute.org/reciprocal-altruism-in-the-theory-of-money/">货币作为一种行为</a>”，我这话的意思是，每个人都有一个社会共识的数字，是跟他们客观相连的。他们可以向其他人展示自己的数字，并且每个人都会同意这个数字的数值。人们还可以做类似于这样的事情：从自己的数字中减掉一些、加在另一个人的数字上。而且，人们都想要数字变得更大。这就是说，他们愿意放弃一些东西，换来数字的增加。如果我们知道数字增大的代价和好处，那我们就能理解这些数字在市场上的价格。</p><p>人们能够以这种方式行事，背后可能有许多理由。这些数字可能跟一种实体商品的数量相对应，比如黄金或贝壳，它们是人们可以亲手交给另一个人的东西。这些数字也可能跟一个机构所管理和保证的数字相对应，比如美元，或者《魔兽世界》游戏里的金子；或者，也可以是存储在区块链上的数字（就像就比特币）；甚至，我们可以全都使用一个荣誉系统，各自跟踪自己的余额、不耍诡计。</p><p>通常，经济学家定义货币的方式是将它当成一个经济体中的一种独一无二的商品。我不这么干。实际上可能有不止一种商品，是被当成货币那样用的。只是，我将证明，从长期来看，我们会预期一种货币占据主导地位。</p><h2 id="货币的风险"><a href="#货币的风险" class="headerlink" title="货币的风险"></a>货币的风险</h2><p>通常，人们从物物交换系统的不便利出发来解释货币 <sup><a href='#note4' id='jump-4-0'>4</a></sup>。虽然物物交换可能确实很不方便，但光凭这一点不足以解释货币的存在。如果我们所有人都能同意将一种商品当成货币，那当然很好。然而，没有什么能保证每个人都会这样做。可以想象这样一个场景：一群人全都是非常优秀的经济学家、全都深入理解并且喜欢货币 <em>这个想法</em>，但他们对彼此没有足够的信心，无法让它真正变成现实。第一个使用货币的人将承担风险，因为他将不得不卖力工作或卖出自己的财产，来获得除了便于储存之外别无长处的东西。只有其他人都愿意效仿他，他的风险承担才会有回报，但是，他们怎么能够向他保证真的会这样做呢？</p><p>有将近一年的时间，比特币就是这种处境。虽然比特币人都猜测比特币某一天可以成为货币，但它的价格就是 0 。结果是，作为一种货币，它是完全无用的。很长一段时间里，比特币人希望比特币的价格能高于 0，但不可能光凭有这种愿望，就能变成现实。当比特币第一次获得大于 0 的价格时，其作为软件的一面并没有根本性的改变，改变的只是人们愿意拿美元来交换它的意愿。</p><p>广义地说，接受货币总是有个人成本，即使这种货币是得到广泛采用的。如果我接受货币作为工资，我怎么知道这种货币到工作结束、我准备购物的时候，它依然还有价值呢？要是我的工资是我可以直接消费的东西，那至少我还能获得它的效用不是吗。但如果我接受的是其主要用途是交换媒介的东西，那么我相当于是依赖于未来也有人会接受这种货币。</p><p>这就是为什么人们无法光凭 <em>意愿</em> 就让货币成为现实、为什么物物交换系统的不便利无法解释货币的存在。因为其中有风险。为了解释为什么人们要使用货币，我们需要找出能够匹配个人成本的个人好处；否则，人们就绝不会去使用货币，不论它对社会的好处有多大。</p><h2 id="货币的效用"><a href="#货币的效用" class="headerlink" title="货币的效用"></a>货币的效用</h2><p>使用货币可以给个人带来一种非常简单的好处。接受货币的人可以推迟要买什么东西的决定。不想使用货币的人，就必须对接受什么商品作为支付手段有更加清楚的想法。而且，当一个人拥有货币时，他就没有被绑定。如果我是第一个接受货币作为支付手段的人，并且我赌赢了，那么我就得到了晚点再选择自己想要什么的选择权，不必基于现在的有限信息作出选择。这种好处，解释了为什么有些人会想要适合保存的商品。如果他希望保留选择余地的话，那么他可以等到真正的机会到来时再打开保险柜。</p><p>我认为，我在此处提出的取舍，解释了货币的价值。我并不是在证明使用用户没有别的成本也没有别的好处，但我不知道还有别的什么好处。如果你能向我证明还有别的持有货币的理由，请便。现在我要谈谈这种取舍对货币的价值的影响。</p><h2 id="货币的价值"><a href="#货币的价值" class="headerlink" title="货币的价值"></a>货币的价值</h2><p>在这篇文章中，我从投资的角度来看待 <em>价值</em>。所以，货币的价值是它在你的投资组合中所服务的目的，以及你想要满足这个目的的程度。对于投资者来说，货币的价值是由 “锁定 vs. 机会” 的取舍决定的。如果他想要更多推迟决策，那么他就需要更多现金。如果他想要更多收入，那么他应该买入股票或者债券。</p><p>人们可能想要推迟决策的理由在于，投资品出现适合的价格的时机是很短暂的。在商业上，一个难题在于，可能要在错过纠正机会的很久之后，人们才会认识到这是一个错误；而且这种错误是很常见的。在这个时候，这家企业就需要现金才能存活并回到正轨。这就是为什么投资人想要随时可以花费的现金余额。你不可能预测这会何时到来，但只要你有现金，你就准备好了应对无论什么难题。持有一种股票就是锁定在一家特定的企业，而现金则让你拥有开放的选择权。</p><p>购买一种投资品就是一种锁定（commitment，承诺），其原因在于，你并不总能将一项投资品轻易换成现金。就像上一段说的，它可能适逢价格低潮，所以投资人无法回笼跟购买时投入的同等量的现金。如果投资品市场崩盘，那么投资人可能无法保持锁定，只能接受亏损然后卖出。相反，能够务实地作出锁定的投资人不会那么在意有没有衰退，因为他已经做好了准备，可以安然度过任何困难时期。</p><p>机会 vs. 锁定这一取舍的有趣之处在于，货币在一个经济体中的用法的整体改变，可能会改变个人所面临的这一取舍的性质。对货币的需求越高，个人持有货币的风险就越低。如果你是 <em>第一个</em> 卖出商品或劳力来换取货币的人，那么你可能看起来像是神经病，或者是不太聪明，居然要赌其他人未来也会想要这个东西。相反，如果 <em>许多人</em> 都在使用货币，那么，你（接受货币）就仅仅是寄希望于不远的将来不会发生超级通货膨胀。在这种情况下，担心这种渺茫的可能性才会被取笑为杞人忧天。</p><p>简而言之，越多人用它，货币就会变得越有价值。相比于我用来推导出这个结论的篇幅，这个结论似乎过于显然，然而，它有许多有趣的暗示，是比特币圈子里的许多人难以接受的，因为他们把钱押在了相反的假设上。随着越来越多人开始持有货币，其他每个人的理性反应都是尝试持有比现在更多的货币单位。因此，每个人都会同时尝试增加自己的现金余额，而且他们会通过卖出更多其它商品来获得它。换句话说，所有的价格都倾向于下降，而货币变得更有价值。实质上，每个人最终都会更有钱，只不过他们最终得到的是更有价值的货币单位，而不是更多数量的货币单位；而且，最终他们会发现，自己的投资组合中有更大的比例换成了货币。</p><h2 id="网络效应"><a href="#网络效应" class="headerlink" title="网络效应"></a>网络效应</h2><p>这跟绝大部分投资品是相反的。如果一种股票的价格上升，那么它的价值就下降，因为分红对价格的比值下降了。如果价格升得太高，那么一个投资人可能最终会想卖掉它，换成更便宜的东西。相反，今天价格为 100 美元的比特币，比几年前价格 100 美元的比特币更有价值，尽管比特币的汇率已经上市了许多。价值更大，是因为比特币的持有者有更多机会可以决定是否出售它。</p><p>价格与价值的正反馈循环暗示着，货币的成长和收缩都可以是自我维持的。你可能会认为这个结论难以接受。毕竟，在一家企业中，价值是靠勤劳的工作和细致的策略创造出来的，而货币竟然可以靠自我驱动就获得价值。我欢迎任何人用别的方式来解释比特币的价值。说它是 “泡沫” 不行，因为这跟我说的就是同一回事。货币基本上就是一种自我维持的泡沫。我们还不知道比特币能否抵达一种自我维持的状态，而且，即使它不能，“区块链技术” 的拥趸也依然是错的，因为那样的话，就压根没有一条好的区块链。</p><p>一个自我维持的泡沫，会长什么样？天然地，货币的成长必然有一个界限。随着货币的价值增长，最终个人持有更多货币单位所带来的好处会下降。随着通货的市值占据整个经济体的比例越来越高，就会发生这样的情况。经济体内会产生的、等待现金持有人来利用的错误，就只有这么多。一旦有足够多的投资人手持大量货币，以至于能够捕捉到所有值得挽回的错误，经济体就变得货币过剩了。这时候，个人持有更多货币就不会再带来任何好处，即使货币的价值已经上升了。这阻止了货币的价值进一步上升，直到更多人或企业进入经济体。</p><p>这一界限独立于货币背后的技术。如果人们足够诚实，那么只需要荣誉系统，就足以运行货币。因此，货币的价值是一种宏观经济现象，即使是比特币这样规模很小的古怪密码货币也不例外。这也是为什么即使软件和协议没有根本性的变化，比特币也可能在前一年还没有任何价值、第二年却变得有价值；也是为什么它的价格可以在短时间内出现似乎毫无理由的大量波动。这是因为货币的价值是一种共享的幻觉，而价格是由这样的幻觉的生动程度而形成的。</p><h2 id="比特币的价值是如何创造出来的"><a href="#比特币的价值是如何创造出来的" class="headerlink" title="比特币的价值是如何创造出来的"></a>比特币的价值是如何创造出来的</h2><p>在比特币初次亮相之后的一年时间里，它没有价格，也是完全没有价值的。因此，它的价值并不是在软件一开始开发好之后就创造出来的。它是因为随后到来的一笔一笔投资而出现的。在它第一次获得价格之后，它有一段价格飞速上涨的时期。比特币的价格可能在没有明显理由的情况下驱动自身快速上涨或下跌。小幅度的价格上涨可以解释为需求的增加。而需求的增加意味着，比特币变得更有用，因此更有价值。因此，更多人买入，导致另一波价格上涨。这些狂热让不明就里的人怀疑比特币是不是真的存在。以往认为比特币很蠢对人会因此认为也许自己也应该买一点，万一它真的能成气候呢。换句话说，他们开始认为比特币的唯一用途就是货币擅长做的那件事 —— 应对不时之需。</p><p>在上文，我提到了一种假想：一群经济学家都想要发展出一个货币经济体，但做不到，因为每个人都感觉这笔投资的风险太大了。这里就是他们可以如何解决这个问题。他们可以围成一个圆桌，轮流投资小额资金。这样一来，就没有人会承担太大的风险。也许在轮流了一圈之后，他们的经济体还没法货币化，但他们可以看出谁愿意承担少量的风险。如果每个人都表现出愿意投资一些，那么许多人可能会愿意承担第二轮的风险。如果这个游戏一直运行下去，经济学家们将开始思考，如果他们能够成功获得更多货币单位，那他们将变得多么富有。很快，这个游戏将不再能轮流投资，因为所有人都会尝试卖出<a href="https://nakamotoinstitute.org/mempool/bitcoins-compound-rewards">尽可能多的东西</a>，好趁着这种货币还便宜的时候买入更多。</p><p>比特币并不是从物物交换系统中出现的。美元和其它由国家管理的通货早已垄断了几乎所有贸易。然而，比特币的最早投资人的考虑与上面这群经济学家们非常相似。对于对多人来说，要是真的能用比特币来买东西，那就太棒了。然而，它现在还买不到任何东西，而它的投资前景就取决于它某一天会被需求用来交换商品的假设。人们怎么评估这样一种可能性的风险呢？其它通货已然存在的事实并不改变这个问题。从一个比特币投资者的角度看，比特币也许恰好处在一个物物交换系统中 —— 这些物就是美元、日元、欧元、英镑，而不是茶叶、丝绸、盐和燧石。唯一的区别在于，相比于茶和盐，国家通货是更好的竞争者，所以比起比特币诞生在一个真正的物物交换系统中，接受它的风险还要更大。</p><h2 id="相互竞争的通货"><a href="#相互竞争的通货" class="headerlink" title="相互竞争的通货"></a>相互竞争的通货</h2><p>我并不反对通货相互竞争 —— 我的意思是，不应该禁止人们创造它们。我的反对在于，我认为货币之间的竞争是垄断性的，所以，鼓吹一种新的通货作为一种投资、却不考虑这个现实，是极度不诚实或者愚蠢的。因此，我说我反对通货竞争，我的意思是，创造一种新通货的人在最好能够证明他的想法有能力取代当前的系统，否则就应该把他当成一个骗子。</p><p>货币具有需要和价值的正反馈循环，这个事实意味着，通常情况下，两种货币不可能存在一个稳定的均衡。它们之间的任何细微的不平衡都会不断放大。哪怕一种通货只是稍微比另一种更受欢迎，人们也会用稍微需求更多来回应这一点。所以，已经更受欢迎的会越来越受欢迎。任何两种货币都将以这种方式互动，从而留下一个能够主宰其余部分的货币。</p><p>许多初次接触比特币的人会被误导，因为他们认为分散投资很重要。分解投资的问题在于，有可能以零成本创造出无限数量的垃圾，要是你均匀地分散投资，那你的钱就全部打水漂了。只有在不是垃圾的投资品中，分散投资才是有意义的。如果我们考察的是一堆已经开始派发分红的股票，那分散投资确实有意义。相反，现在有<a href="https://nakamotoinstitute.org/mempool/the-coming-demise-of-altcoins">几乎无数种诈骗币</a>。在 2013 年末和 2014 年初，每天都有新的诈骗币出现和推销。他们可以按照这个速度不断生产下去，直到认为分散投资是好主意的人全都破产。现在，所有迟钝的人都已经破产了，关注点转移到了用 “区块链技术” 来欺骗无知的风险投资人。</p><p>接受货币支付总是有风险，哪怕是美元这样已经广泛使用的货币。如果每个人都使用相同的货币，那么他们能够协调起来尽可能降低这种风险。如果你预期人们会使用两种货币，你必须想出一些理由：使用两种货币怎么就能以另一张方式抵消风险。我从来没有见过哪个山寨币人或者 “区块链技术” 粉丝接近于解决这个问题。显然，如果两种通货是几乎一摸一样的，比如比特币和莱特币（Litecoin），那么哪一种体量更大，就会具有优势。最近，莱特币的价格已经在一定程度上与比特币脱钩了，所以也许任梦已经发现了这一点。一旦莱特币失去它的共享幻觉，再多的口号也无法让它回归。</p><p><img src="/../images/its-not-about-the-technology-its-about-the-money/litecoin-prices-all-time.png" alt="litecoin-prices-all-time"></p><p style="text-align:center">- 莱特币的价格，全时间段（来自 <a href="http://coinmarketcap.com/currencies/litecoin/">CoinMarketCap</a>） -</p><p>但如果是更加复杂的设计呢？我们先假设以太坊（Ethereum）<a href="https://nakamotoinstitute.org/mempool/ethereum-is-doomed">真的能够运行</a>、真的能在某种程度上与比特币竞争。以太坊的 “智能合约设计” 真的能够带给它相比于比特币的优势吗？我看不出以太坊的智能合约系统如何提供更大的利用 ETH 货币的机会（相比于比特币）。不管智能合约听起来有多酷，它也只是让 ETH 成为另一种应用币，而人们会通过不持有或尽可能短时间持有来规避持有它的风险。这会<a href="https://nakamotoinstitute.org/mempool/appcoins-are-snake-oil">驱动价格下降</a>，直到它在贸易中无用。</p><p>顺带说一句，我倾向于自称为 “比特币极简主义者” 而不是 “<a href="https://blog.ethereum.org/2014/11/20/bitcoin-maximalism-currency-platform-network-effects/">比特币最大主义者</a>”，因为其它区块链似乎都是无用的，而且很容易被淘汰。</p><h2 id="比特币对比美元"><a href="#比特币对比美元" class="headerlink" title="比特币对比美元"></a>比特币对比美元</h2><p>相反，要较真的话，比特币对比美元（以及其它法币）都有所提升。美元并不适合存起来 “以防万一”。因为时间一长，它就因为通货膨胀而损失价值。你不能随身携带美元现金，不然警察会收缴它；如果你把它存在银行，只要你用在被认为不可接受的用途中，你的银行账户就会被冻结。你不能像持有比特币一样持有美元。持有比特币并不是没有风险，确切地说，只要你妥善地保管它们，你可以预期自己持有的数量在总数量中的比例永远相同。</p><p>国家通货会受到你不知道或者无法控制的因素的影响。它们是由委员会来管理的，而委员们服务于发行这些货币的政府。这些委员的行话不仅对绝大多数人来说难以理解，对于 <em>能够</em> 理解的人，也是乏味到无法忍受。每个人都受他们的影响，但绝大多数人都懒得去理解他们。他们出于 “国家利益” 而管理通货，但它并不总是与 <em>你的</em> 利益相一致。他们可以改变你能够花费通货的规则，也可以提高供给量 <sup><a href='#note5' id='jump-5-0'>5</a></sup>。通常来说无法猜测他们会怎么做，至少长时间来看是这样。</p><p>但在比特币<a href="https://nakamotoinstitute.org/mempool/the-bitcoin-central-banks-perfect-monetary-policy">当前的规则</a>下，这些都不可能；而且，也很难改变这些规则、最终让类似的事情成为可能。虽然未来会有许多新的比特币被创造出来，整个发行的计划表是众所周知的，因此已经在当前的比特币的汇率中显现出来了。因此，比特币不会因为其通货膨胀而损失价值。它可能会因为不流行而损失价值，这种风险比美元的要大（当前来看）。</p><p>因此，从投资的角度看，比特币与美元之间存在真正的质的差异。这并不意味着比特币必然会打败美元。它只意味着比特币具有相关的竞争优势。比特币依然有显著的劣势：交易确认起来很慢，难以保持匿名性。然而，比特币对美元的汇率一直表现良好，而且也出现了依赖于它的真实世界的商业。此外，每次比特币汇率上涨，其相对于美元的风险都会下降。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因此，比特币的 <a href="https://nakamotoinstitute.org/mempool/bitcoin-as-a-store-of-value-unit-of-account-and-medium-of-exchange"><em>货币</em></a> 侧面尤为有趣的地方在于，比特币有可能成为出于存放目的而受偏爱的商品。如果这一点成真，那么其价值会不断商战，一直到它成为世界经济体的重要部分。这对于世界和比特币的早期采用者来说，都将是巨大的改变。你大可以说我痴心妄想，但我认为，它的概率还是比脱离了比特币的区块链找到应用场景的概率更大，也更明显。</p><p>比特币协议就像一个伟大的工程杰作。它的各个部分都适合于它的功能。它不是最有趣的技术；使用这些技术所带来的东西才最有趣。作为一个概念，区块链没有理由走出开发者和工程师的小圈子。然而，当人们观察比特币时，他们唯一能够用来理解它的术语就是，这是一项新技术。然而，比特币更像是一种新传统，而不是一种新技术。就像在一个人山人海的音乐节现场，有一小群人开起了火车，你可以打赌这个火车会不会变得越来越长。</p><p>如果还有人跟你说 “区块链技术”，你最好离开那里 <sup><a href='#note6' id='jump-6-0'>6</a></sup>。他们只是想给你推销他们的 “新型<a href="https://bitcoinism.liberty.me/decentralized-applications-its-time-for-an-intervention/">去中心化</a>众筹区块链物联网” 骗局。你 <em>知道</em> 他们在说谎，因为每一个表现出那样的行为的人都是骗子，而不是骗子的人会做些事情将自己与他们区别开来。知道自己在说什么的人，都知道堆砌一些热点词汇并不就能带来有意义的想法。不幸的是，如果人们都缺乏基本的批判性思维、每个人都指望<a href="https://nakamotoinstitute.org/mempool/everyones-a-scammer">从别人的愚蠢中发财</a>，那么，就没有人 <em>想要</em> 知识了，至少在他们找到最佳的退场机会之前，不会再关心了。这一天可能永远不会来，因为虽然他们都认为自己可以从别人的愚蠢中发财，但他们更有可能成为别人的猎物。</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>1.<a id='note1'> </a>不过，某人迟钝，并不意味着他 <em>不可能</em> 是骗子。基于我在比特币圈子的经验，我认为许多骗子都有一种本能，就是对自己获得钱财的方式尽可能保持愚钝，这样才能继续欺骗自己是天才的企业家。 <a href='#jump-1-0'>↩</a></p><p>2.<a id='note2'> </a>“<a href="http://www.catb.org/esr/writings/taoup/html/ch01s06.html">只做一件事，做得尽可能好</a>” <a href='#jump-2-0'>↩</a></p><p>3.<a id='note3'> </a>我在本文中展现的是奥地利学派的货币理论。想要更了解这种想法，可以参考任何一部标准的奥地利学派著作，比如 Murary Rothbard 的《<a href="https://mises.org/library/man-economy-and-state-power-and-market">人，经济与国家</a>》，或者米塞斯的《<a href="https://mises.org/library/human-action-0">人的行为</a>》。 <a href='#jump-3-0'>↩</a></p><p>4.<a id='note4'> </a>奥地利派经济学家所说的 “*物物交换系统 *” 指的是一个没有商品被用作货币的经济体，虽然这个术语对许多人来说有更加具体的含义。 <a href='#jump-4-0'>↩</a></p><p>5.<a id='note5'> </a>在美国，实际上是国会和行政分支在改变规则，而美联储会改变货币的供给量。这个区别对于本文的目的来说并不重要，但一些人认为它有重要意义，因为美联储被设计成一个私人部门，而国会是由选举出来的代表组成的。 <a href='#jump-5-0'>↩</a></p><p>6.<a id='note6'> </a>包括<a href="http://www.coindesk.com/presidential-candidate-hillary-clinton-pledges-support-blockchain-tech/">希拉里·克林顿</a>。 <a href='#jump-6-0'>↩</a></p>]]></content>
    
    
    <summary type="html">只有在要玩的这个游戏是如此重要、以至于谁来充当裁判都不安全时，这才是一种好方法</summary>
    
    
    
    
    <category term="文化" scheme="https://www.btcstudy.org/tags/%E6%96%87%E5%8C%96/"/>
    
    <category term="货币" scheme="https://www.btcstudy.org/tags/%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>V2 传输协议：比特币点对点流量隐身</title>
    <link href="https://www.btcstudy.org/2026/02/11/the-v2-transport-bitcoin-p2p-traffic-goes-dark/"/>
    <id>https://www.btcstudy.org/2026/02/11/the-v2-transport-bitcoin-p2p-traffic-goes-dark/</id>
    <published>2026-02-11T12:39:49.000Z</published>
    <updated>2026-02-28T07:32:23.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Pieter Wuille</em></p><p><em>来源：<a href="https://bitcoinmagazine.com/print/the-v2-transport-bitcoin-p2p-traffic-goes-dark">https://bitcoinmagazine.com/print/the-v2-transport-bitcoin-p2p-traffic-goes-dark</a></em></p></blockquote><p>接近 15 年以来，比特币网络上的节点之间的所有通信，都是以完全透明的形式传输的，没有任何加密。改变出现在 2024 年，这是因为采用了 BIP 324，它为节点之间的沟通引入了 “‘V2’ 传输协议”。这种新协议实现了伺机加密（opportunistic encryption）特性，使得没有能力监控节点间消息的敌手无法阅读它们的流量。自从 Bitcoin Core 26.0 为它添加了支持、并且在 27.0 版本默认开启它以来，它已经用在了比特币全网大部分点对点流量中。</p><p>但退一步说，一个比特币节点的主要功能是交换本质上公开的信息：区块链上的区块、交易池里的交易、其它比特币节点的 IP 地址。因为这些都不是秘密信息，似乎看不出流量加密有什么好处。但更近距离的观察会发现，与比特币流量相关联的大量 <em>元数据</em>，是值得保护的。如果一个大视野的敌手能够看到某一笔交易在何时转发、经过哪个 IP 地址来转发，他就能猜测哪个节点可能是传播的源头 —— 因此是该交易的发起人。除此之外，看到节点之间的连接，可能会曝光特定的某个节点属于某个人，从而让某一家公司或者矿工的节点可以被攻击者瞄准。对于一些在专制政体下生活的用户来说，可能透露自己在运行比特币节点本身就是没好处的。</p><p>在中本聪设计的 P2P 协议中，节点彼此连接，在这些连接上发送消息，比如 “<strong>inv</strong>”（“我有你不知道的新 区块&#x2F;交易”）、“<strong>addr</strong>”（“这是另一个节点的 IP 地址”），等等。这些消息以及各节点所支持的特性的集合，已经发生了显著的改变，比如支持早期的 SPV 客户端（BIP 37）、致密区块转发（BIP 152）、Tor v3 地址（BIP 155），等等。但这些消息编码成字节、通过这些连接来传送的方式 —— 我们称之为 “传输协议” —— 自 2009 年来本质上从未变过。唯一的例外是 2010 年 5 月为这个协议引入了校验和。BIP 324 是此后首次进行此类变更。</p><p>注意，虽然这可以说是 “比特币协议” 的一部分进行的根本性变更，但它也完全是可选的。它并不是一项共识变更，也并不需要任何协调和激活机制。它只会在都支持这项特性的两个节点之间使用，但当一个支持 BIP 324 的节点与不支持它的节点通信时，它们会回到旧的传输协议（即 “v1”）。这就是为什么，在支持它并且默认打开它的客户端发布之后，两年中，比特币节点之间的绝大部分流量就都悄悄用上了这种加密的 v2 传输协议。</p><p>加密比特币节点流量的想法并不新奇。早在 2016 年，Bitcoin Core 开发者 Jonas Schnelli 就提出了 BIP 151 ，它允许升级后的节点间连接切换到一种加密模式。这个提案并没有走太远，而且因为这种方法并不能隐藏两个节点之间的初始化握手，2019 年出现的 BIP 324 决心彻底改造传输协议。这种更加新颖的方法引入了一组全新的连接，从一开始就是加密的。进展持续累积，直到 2021 年，Dhruv Mehta 主动捡起它，并跟 Tim Ruffing 和我将它转化成了一个完整的提案，还加入了少量新特性，比如一种完全伪随机的字节流、 流量塑形特性（affordances for traffic shaping）以及可选插件。2022 年，我们在 bitcoin-dev 邮件组中宣布了它，并在收获几个评论之后，在 2022 年和 2023 年期间实现了它。完整的特性在 2023 年合并到了 Bitcoin Core 。在进一步测试之后，在 2024 年，它被默认为所有连接启用（只要对等节点支持）。</p><p>新协议所提供的完全伪随机字节流特性，意味着通过这一传输协议发送的字节没有可识别的模式。举个例子，TLS 协议，用在与安全网站（“https:&#x2F;&#x2F;” 网页）的通信中，它会加密网站的内容，但不会隐藏使用了 TLS 的事实，以及请求该站点的主机名（hostname）（至少在 2020 年使用 “加密的客户端招呼（ECH）” 之前）。在 BIP 324 实现之前，v1 传输协议会在每一个连接的开头发送固定的 16 个字节，这是极为容易识别的，所以，尝试审查的防火墙可以轻松阻拦使用这一模式的任何连接。相反，v2 传输协议完全没有这样的模式；每一个字节，从第三方的角度看，都是均匀随机的，因此是完全无法预测的。任何尝试基于流量模式来阻拦比特币流量的实体，都需要拦截所有看起来随机的流量，这可能在政治上更有难度（相比只是拦截比特币这样的软件的流量）。让整个协议伪随机化最难的部分来自于握手 —— 在加密建立以前，节点需要交换公钥，而公钥并不是随机字节。感谢一个非常新的密码学技术，叫做 “Elligator”（2013），以及它的一个叫做 “ElligatorSwift”（2022）的变种，它可以将椭圆曲线公钥编码成看起来随机的字节，从而有可能在握手期间出现可识别的模式。</p><p>值得指出的是，由于比特币网络的公开特性，节点间的加密传输层可以提供的隐私保护面临很大的局限性。比特币节点并不信任自己的对等节点，因此也并不十分在乎这些对等节点是谁。比特币节点也没有公开的公钥，这也是为什么 v2 传输协议所提供的加密是伺机的、无身犯认证的；双方都会为每一个连接使用一个新的临时密钥。这意味着，主动的敌手（例如你的互联网运营商）可以执行 “中间人攻击”：与尝试建立连接的两个节点都使用 v2 传输协议，然后解密来自一方的消息、重新加密之后再发给另一方；也就是依然允许间谍，并且有可能同时篡改或审查信息。然而，重点在于，相比于能够直接检查未加密的单条消息（就像 v1 传输协议允许的那样），要大范围发动上述中间人攻击会昂贵很多。而且，当然，因为绝大部分比特币节点连接都是任意向随机的、不受信任的节点发起的，一个想要大规模打探其它节点的敌手总是可以启动大量的节点，然后让其他大量节点连接到这些节点。就像中间人攻击一样，做起来也比直接检查 v1 包裹更加昂贵。</p><p>因此，最好不要把 BIP324 自身当成一种隐私性提升，而是更大的动作的一部分：提高大规模监视比特币网络的成本，同时不要依赖于替代性网络（比如 Tor 和 I2P，它们都有自身的牺牲，比如增加时延或拒绝式服务的风险，整个网络的所有节点无法都接受这些风险）。BIP 324 的一些特性截至目前尚未实现，比如流量塑形，可以防止他人通过观察加密包裹的体积来发现关于被转发的交易的信息。希望这些特性会在未来几年中利用起来。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">了解 V2 传输协议从 2024 年以来的进展</summary>
    
    
    
    <category term="比特币主网" scheme="https://www.btcstudy.org/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BB%E7%BD%91/"/>
    
    
    <category term="点对点网络" scheme="https://www.btcstudy.org/tags/%E7%82%B9%E5%AF%B9%E7%82%B9%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzamoto：介绍</title>
    <link href="https://www.btcstudy.org/2026/02/09/fuzzamoto-introduction-by-niklas-gogge/"/>
    <id>https://www.btcstudy.org/2026/02/09/fuzzamoto-introduction-by-niklas-gogge/</id>
    <published>2026-02-09T07:44:49.000Z</published>
    <updated>2026-02-28T07:32:23.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：NIKLAS GÖGGE</em></p><p><em>来源：<a href="https://brink.dev/blog/2026/01/07/fuzzamoto-introduction/">https://brink.dev/blog/2026/01/07/fuzzamoto-introduction/</a></em></p></blockquote><p>大概一年以前，我开始开发 “<a href="https://github.com/dergoegge/fuzzamoto">Fuzzamoto</a>”，这是一种比特币全节点实现的模糊测试（fuzz testing）工具。在这一系列博客中，我会分享我的经验、间接和在此期间遇到的开放问题。第一篇会介绍创建 Fuzzamato 这个项目背后的动机，并概述其设计和架构。在后续篇章中，我将深入其确定性、测试案例的生成和突变测试（mutation）、发现的 bug、对超出覆盖范围的模糊测试的反馈，等等。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>迄今为止，Bitcoin Core 是网络上受到最广泛采用的比特币协议实现，因此，它的 bug 可能会造成灾难性的后果。也正因此，Bitcoin Core 拥有非常保守的开发文化，这在一定程度上是必要的，也是一个优点（显然是它没有许多严重 bug 的一个重要原因），但也会带来挫败感、消耗感以及重大项目上的缓慢进展。</p><p>即时你只是想提升测试水平、重构现有的代码以让它变得更容易测试、添加测试项目，你也可能面对巨大的阻力。这个项目的资源是非常紧缺的，复杂的 PR 对于审核人来说根本没有吸引力，因为在初始化同步时间上加速 20%、P2P 协议的特性以及其它微小的变更只需更少的时间和经历来审核。让事情恶化的是，如果你不得不重构代码来添加更多测试，重构过程自身有可能引入 bug 。这就变成了一个鸡生蛋蛋生鸡的问题 —— 测试将降低重构的风险，可以添加测试需要重构。</p><p>这些重构通常会解耦各个模块，将代码分割到单独的模块中，或者添加接口，让模拟（mocking）能够实现，这对于 进程内的&#x2F;持久模式的 模糊测试来说，通常是必要的。比如说，如果被测试的组件依赖于硬盘 I&#x2F;O，模糊测试速度会较慢，拓展性也差，所以你会想要模拟它（硬盘 I&#x2F;O）以加快速度。（译者注：“模拟” 在这里指的是创建虚拟对象来代替实际上的依赖项。）</p><p>在这一阶段，对 Bitcoin Core 的测试的重大提升（发现严重的既有 bug 或者防止 bug 继续扩大）依然是很有可能做到的。比如说，跟验证区块、验证交易和致密区块的 P2P 代码是没有经过模糊测试的，关于链重组和其它相似的更加内聚的代码路径也是一样。为了能够以传统的进程内控制来高效地测试这些代码，需要变更关键的代码（共识、P2P，……），同样是没有得到应有测试程度的代码。</p><p>我可以说，从我的个人经验来看，为这些重构获得支持是痛苦的，而且我已经失去维护 PR 的兴趣几个月甚至几年了；这些重构的好处似乎常常被更高的特性流失率（churn rate of features）和微小的变更盖过。（译者注：“特性流失率” 指的是一段时间里停止使用某一特性的用户的比例。）</p><p>面对这种情况，显然，Bitcoin Core 将从无需给保守的审核流程带来不必要的负担、不需要 Bitcoin Core 自身的任何变更的测试中获得好处，这样的测试能够缩小剩余的测试空白并减少未来的风险。最终的愿景是一种外部的测试工具，它尽可能以生产环境中的二进制文件为输入，以 bug 为输出。</p><p>Bitcoin Core 的功能测试（functional test）曾经是最接近这个想法的东西，因为它们生成完整的节点，并通过节点的外部接口（RPC、P2P、IPC 等等）进行测试。编写功能测试不需要重构，最多只需要添加新的 RPC 方法，从而能够内省软件的部分状态。虽然这些测试达成了较高的代码覆盖率并找出了大量 bug，它们并不是基于属性（property）的测试，并不能自动暴露边缘案例（edge cases）。举个例子，功能测试的单行补丁（line patch）没有发现 <a href="https://bitcoincore.org/en/2024/10/08/disclose-blocktxn-crash/">CVE-2024-35202</a>，它实际上是通过重构和编写新的模糊测试而发现的（顺带说一句，这些测试和重构，都从来没有合并到 Bitcoin Core 中）。如果那些功能测试是基于属性的测试，那也许它们能够发现这个问题。</p><p>在意识到这些之后，我问我自己：我们能不能拥有 “功能性的模糊测试” 呢？跟功能测试拥有同样的测试概念，但不是使用硬编码的测试场景并安排好预期结果，而是使用模糊测试，在系统层面测试属性。这就是 Fuzzamoto 背后的理念：完全系统化的（full-system）、模糊测试驱动的模拟。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>抽象地说，使用 Fuzzamoto 的模糊测试包含作为测试目标的全节点后台进程（比如，bitcoind、btcd，等等），一个测试工具（在给定一个模糊输入的前提下，控制测试执行），以及一个模糊测试引擎（用于产生提供给工具来执行的输入）。</p><p><img src="/../images/fuzzamoto-introduction-by-niklas-gogge/2026-01-fuzzamoto-architecture.png" alt="&quot;Fuzzamoto architecture&quot;"></p><h3 id="快照模糊测试"><a href="#快照模糊测试" class="headerlink" title="快照模糊测试"></a>快照模糊测试</h3><p>一个需要解决的显然挑战是，这种设计的一个天真实现会导致目标节点在模糊测试执行后积累状态（从而影响后续测试），从而导致非确定性（non-determinism）。我会在本系列的后续博客中更深入地探讨确定性及其挑战，但简而言之：为了让模拟测试是高效的，我们希望测试案例的执行是确定性的，即，给定相同的输入，测试的动作应该是一样的。</p><p>Fuzzamato 使用完全系统化的快照模糊测试来解决这个状态难题。它的原理是：在一个特殊的虚拟机内运行目标节点和测试工具；这个虚拟机有能力为其所有状态（内存、CPU 状态、设备，……）生成一个快照，并快速将自身重置到这个状态。当前，Fuzzamoto 使用 <a href="https://nyx-fuzz.com/">Nyx</a> 作为虚拟机后端，但理论上，任何拥有类似能力的后端都可以工作。</p><p>这让我们可以避免每次都创建和拆除状态（这都是昂贵的开销）。我们可以直接在一开始建立需要的状态，然后取得快照、开始模糊测试，在每一次执行的结束时刻，将虚拟机快速重置回初始状态。具体来说，对于比特币全节点的模糊测试，这让我们可以（举个例子）预先挖出一条区块链、提供成熟的（可以立即测试花费的）coinbase 输出。</p><p>我们将在本系列博客的下一篇文章中讲解 Nyx 的技术细节：它是如何工作的，Fuzzamoto 如何使用它；以及覆盖指引（coverage guidance）在这个模式下如何工作。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>Fuzzamoto 中的模糊测试工具可被称为 “场景”，负责快照状态的建立、控制模糊输入执行并将结果报告给测试引擎。每一个场景都需要实现两种函数：</p><ul><li>场景的创建和快照状态的建立，即，生成目标全节点进程，并将节点带到运行模糊测试所需的状态。</li><li>测试案例的执行，即，在前面创建好的状态下执行一个测试案例。</li></ul><p>测试 HTTP 服务端、钱包迁移、RPC 接口和具体的 P2P 协议流（比如致密区块转发）各有具体的场景。它们都取裸字节作为输入，并使用 <a href="https://docs.rs/arbitrary">Arbitrary</a> 将这些字节解析为一个结构化的测试输入，然后对目标执行这些测试输入。因为输入是一个通用的字节数组，我们可以使用 <a href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a> 来模糊测试这些场景，因为它为使用 Nyx 的快照模糊测试提供了支持。</p><p>就在我为测试多种 P2P 协议流（交易转发、致密区块转发、链重组，……）而开发独立的场景时，我突然想到，在它们之间形成重叠是有好处的。举个例子，为了测试致密区块转发或是链重组，假设同时也向受试的节点提交不同形状和类型的交易（就像在交易转发的测试场景中那样）就会触发 bug，这并不离谱。因此，思路就转变成了开发一个非常广泛的场景来测试节点整个 P2P 界面，一网打尽。正是为了模糊测试这个场景，Fuzzamoto 包含了一个定制化的基于 <a href="https://github.com/AFLplusplus/LibAFL">LibAFL</a> 的模糊测试引擎，这我们也会放到本系列的后续篇章来详谈。</p><h2 id="初步成功"><a href="#初步成功" class="headerlink" title="初步成功"></a>初步成功</h2><p>我编写出来的第一批场景之一，目标是 Bitcoin Core 的 RPC，尤其是以有趣的方式合并 RPC 的各种相关的和不相关的结果。这个场景会以模糊测试引擎选定的顺序调用 RPC，然后将模糊输入的一部分解析为 RPC 输入，或者从一个由以往的 RPC 返回的值形成的池子中挑选。比如说，如果测试调用了 <code>generatetoaddress</code>，它可能后面会将这个 PRC 所返回的区块哈希值传递给其它 RPC 作为输入，或者从模糊输入中消去一个哈希值。</p><p>这个场景成功发现了区块索引数据结构中的 bug，这个 bug 只有在同时使用 <code>invalidateblock</code> 和 <code>reconsiderblock</code> RPC 时才会现象（它们都只能在测试模式下使用）。</p><pre><code>bitcoind: validation.cpp:5392: void ChainstateManager::CheckBlockIndex(): Assertion &#39;(pindex-&gt;nStatus &amp; BLOCK_FAILED_MASK) == 0&#39; failed.</code></pre><p>虽然从安全性的角度看，这个 bug 也没有什么大不了（只能通过测试模式限用的 RPC 来触发），它凸显了完全系统化方法的强大之处：它会立即显明，这是一个 bug ，而不是一个假阳性（即：后台进程会崩溃，这是绝对不该发生的），并且，快照模糊测试带来了高效的状态重置（如不使用快照，本来只有通过重构才能做到）。</p><p>同一个 bug 也被其他重构了代码并为区块索引代码编写了模糊测试的<a href="https://github.com/bitcoin/bitcoin/issues/32173#issuecomment-2767030982">贡献者</a>发现了。而添加这个工作到代码库中的 <a href="https://github.com/bitcoin/bitcoin/pull/31533">PR</a>，在被合并之前已经打开了整整一年！</p><p>因为 Fuzzamoto 测试的运行层级跟功能测试相同，我们可以将任何 Fuzzamoto 的测试案例转化为一个 Bitcoin Core 功能测试（只要 bug 是确定性可以复现的，就可以做到）。比如说，下面这个功能测试就复现了区块索引 bug：</p><pre><code>from test_framework.test_framework import BitcoinTestFrameworkclass CheckBlockIndexBug(BitcoinTestFramework):    def set_test_params(self):        self.setup_clean_chain = True        self.num_nodes = 1    def run_test(self):        self.generatetoaddress(self.nodes[0], 1, &quot;2N9hLwkSqr1cPQAPxbrGVUjxyjD11G2e1he&quot;);        hashes = self.generatetoaddress(self.nodes[0], 1, &quot;2N9hLwkSqr1cPQAPxbrGVUjxyjD11G2e1he&quot;);        self.generatetoaddress(self.nodes[0], 1, &quot;2N2CmnxjBbPTHrawgG2FkTuBLcJtEzA86sF&quot;);        res = self.nodes[0].gettxoutsetinfo()        self.generatetoaddress(self.nodes[0], 3, &quot;2N9hLwkSqr1cPQAPxbrGVUjxyjD11G2e1he&quot;);        self.log.info(self.nodes[0].invalidateblock(res[&quot;bestblock&quot;]))        self.generatetoaddress(self.nodes[0], 3, &quot;2N9hLwkSqr1cPQAPxbrGVUjxyjD11G2e1he&quot;);        self.nodes[0].reconsiderblock(hashes[0])        self.nodes[0].invalidateblock(hashes[0])        self.log.info(self.nodes[0].reconsiderblock(res[&quot;bestblock&quot;]))if __name__ == &#39;__main__&#39;:    CheckBlockIndexBug(__file__).main()</code></pre><p>这样一来，处理这个 bug 的开发者们，就无需建立 Fuzzamoto，只需使用他们熟悉的工具来调试这个问题。</p><p>关于迄今为止发现和公开的问题的去竞争清单，请看这个项目的 <a href="https://github.com/dergoegge/fuzzamoto#trophies">readme</a> 的炫耀部分。</p><p>本系列的下一篇将介绍围绕非确定性的考虑。</p>]]></content>
    
    
    <summary type="html">创建 Fuzzamato 这个项目背后的动机，并概述其设计和架构</summary>
    
    
    
    <category term="比特币主网" scheme="https://www.btcstudy.org/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%BB%E7%BD%91/"/>
    
    
    <category term="开发" scheme="https://www.btcstudy.org/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>闪电钱包托管模式光谱</title>
    <link href="https://www.btcstudy.org/2026/02/07/lightning-custody-spectrum-by-vls/"/>
    <id>https://www.btcstudy.org/2026/02/07/lightning-custody-spectrum-by-vls/</id>
    <published>2026-02-07T09:36:38.000Z</published>
    <updated>2026-02-28T07:32:23.238Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：VLS</em></p><p><em>来源：<a href="https://vls.tech/posts/lightning-custody-models/">https://vls.tech/posts/lightning-custody-models/</a></em></p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>闪电网络钱包和闪电网络服务商（LSP）的现状，究竟什么是真正的 “非托管”。</li><li>在比特币 Layer 1 上，持有密钥就意味着自主保管。而在闪电通道中，即使你持有密钥，如果你的签名器会盲目地许可支付请求而不验证，节点被攻陷也可能导致你资金丢失 —— 这是共享托管模式。</li><li>盲目签名既不是非托管，也不安全。它创造了两个故障点（节点和签名器）。只要任何一个被攻陷了，资金都会丢失。</li><li>“VLS（带验证的闪电通道签名器）” 为分离私钥和节点提供了真正非托管的解决方案。节点被攻陷也不会导致资金丢失。</li></ul><h2 id="闪电钱包的承诺与问题"><a href="#闪电钱包的承诺与问题" class="headerlink" title="闪电钱包的承诺与问题"></a>闪电钱包的承诺与问题</h2><p>你仔细地研究和挑选 “非托管的” 闪电钱包，因为你相信 “无私钥，即无币”。你精心地保护你的种子词</p><p>直到有一天，你起床后发现自己的通道已经关闭了，应当属于你的比特币被发送到了你不知道的地址。而程序的日志显示你的签名器授权了所有东西。你的比特币就这么飞走了。你的 “自主保管的” 钱包就这么欺骗了你。</p><p>闪电钱包承诺要在即时支付上实现比特币的自治原则。但有些地方出了问题。</p><p>你的钱包软件可能会自称是 “非托管的”， 因为 “你自己持有私钥”，然而，如果你的签名器会盲目地许可请求而不验证，那到底是谁控制着你的钱？</p><p>这就是盲目签名的真相，是闪电钱包的肮脏秘密。</p><h2 id="什么是闪电钱包里的-“盲目签名”？"><a href="#什么是闪电钱包里的-“盲目签名”？" class="headerlink" title="什么是闪电钱包里的 “盲目签名”？"></a>什么是闪电钱包里的 “盲目签名”？</h2><p>闪电钱包里有两个模块：</p><ul><li><strong>节点</strong>，负责提议状态变更（增减余额）；</li><li><strong>签名器</strong>，决定这些更新是否可以安全地签名（许可）。</li></ul><p>在一个妥当的非托管装置中，签名器会根据协议的规则和用户条款，在签名之前验证每一次请求。</p><p>而在 “盲目签名” 模式中，闪电钱包的私钥本身与节点隔离，然而，签名器会盲目地许可节点的请求，也就是完全不验证请求的内容。这是因为，盲目签名器可以在格式正确的交易上签名，但并没有足够的信息来分辨安全的请求和不安全的请求。</p><p>将一个盲目签名器标榜为 “非托管的”，就好像一家银行说自己是非托管的，因为它不知道你的银行卡口令。不设验证的签名器不是控制器，而是威胁。</p><p>用户有权知道真相：<strong>盲目签名模式是共享托管，它实际上比一些托管解决方案还要危险一些</strong>。多年来，闪电钱包技术公司一直将盲目签名的解决方案伪装成 “非托管” 或 “自主托管”。</p><blockquote><p><strong>硬件钱包测试</strong></p><p>设想一个比特币硬件钱包，它会签名任何交易而不检查找零地址、手续费和支付目的地。你会管这样的钱包叫 “非托管” 钱包吗？你会信任它？</p><p>这就是闪电钱包的盲目签名模式。</p></blockquote><h2 id="为什么盲目签名比热钱包还要糟糕？"><a href="#为什么盲目签名比热钱包还要糟糕？" class="headerlink" title="为什么盲目签名比热钱包还要糟糕？"></a>为什么盲目签名比热钱包还要糟糕？</h2><pre><code>纯托管：1 个攻击点（托管商）盲目签名：2 个攻击点（节点 + 盲目签名器）热钱包：1 个攻击点（设备）VLS：1 个加强后的攻击点（带有验证程序的签名器）</code></pre><p><strong>盲目签名，让你可能受到攻击的界面倍增（字面意义上的倍增），而且依然是托管的</strong>。只要节点<strong>或者</strong>签名器被攻陷，你就可能丢失资金。我们专门指出这一点，是因为用户有权利知道真相。</p><p>热钱包的用户至少知道自己在承担风险。盲目签名的用户却因为 “自己控制着私钥” 而误以为自己是安全的。</p><h2 id="可能的攻击形式"><a href="#可能的攻击形式" class="headerlink" title="可能的攻击形式"></a>可能的攻击形式</h2><p>每一种爆破都从某个点开始。以下是漏洞如何转化为盗窃：</p><blockquote><p>场景 1：供应链 -&gt; 攻陷节点 -&gt; 恶意关闭通道</p><p>攻击者修改节点的依赖项，获得节点的控制权 -&gt;</p><p>节点请求：“关闭通道，将资金发送到攻击者的地址” -&gt;</p><p>盲目签名器：无法验证地址 -&gt; 许可 -&gt;</p><p>资金被盗</p></blockquote><blockquote><p>场景 2 ：社会工程学攻击 -&gt; LSP 访问权 -&gt; 陈旧状态</p><p>攻击者假装成用户，向服务支持团队声称自己需要 “紧急修复” -&gt;</p><p>获得节点访问权，广播旧的通道状态 -&gt;</p><p>盲目签名器：无法识别这是陈旧状态 -&gt; 许可 -&gt;</p><p>惩罚交易取走所有资金</p></blockquote><blockquote><p>场景 3：内部威胁 -&gt; 手续费操纵</p><p>恶意雇员或已被攻陷的基础设施 -&gt;</p><p>节点为每一笔交易设置超量的手续费 -&gt;</p><p>盲目签名器：无法验证数额 -&gt; 许可 -&gt;</p><p>资金被缓慢吸干</p></blockquote><p><strong>带有验证程序的签名器将拒绝所有这些请求，而盲目签名器会同意所有这些请求</strong>。</p><h2 id="为什么闪电钱包的托管模式与比特币钱包的不同"><a href="#为什么闪电钱包的托管模式与比特币钱包的不同" class="headerlink" title="为什么闪电钱包的托管模式与比特币钱包的不同"></a>为什么闪电钱包的托管模式与比特币钱包的不同</h2><p>在比特币 Layer 1 上，自主保管是非常直接的。你的硬件钱包（冷钱包）通过检查地址、手续费和找零地址来检查每一笔交易，然后才签名。这种验证程序与对私钥的控制相配合，使之成为自主保管的。你的私钥旧意味着你的钱币。</p><p>比特币的冷钱包模式无法直接移植到闪电钱包中，因为：</p><ul><li><strong>通道状态会持续更新</strong>：与比特币钱包中地址保持静态不同。</li><li><strong>HTLC 有截止时间</strong>：错过这个截止时间意味着丢失资金。</li><li><strong>惩罚需要快速响应</strong>：如果对手广播过时的通道状态，己方必须立即响应。  </li><li><strong>路由支付需要在亚秒级时间内完成签名</strong>：冷钱包太慢了。</li></ul><p>这些要求意味着，早期的闪电钱包实现都要求你运行自己的节点并使用热私钥（即两者是合在一起的），这对用户来说太复杂，也有风险。</p><h2 id="LSP：创造了新问题的解决方案"><a href="#LSP：创造了新问题的解决方案" class="headerlink" title="LSP：创造了新问题的解决方案"></a>LSP：创造了新问题的解决方案</h2><p>“闪电网络服务供应商（LSP）” 是为着解决闪电钱包的易用性危机而出现的。运行一个闪电节点需要专门的技术知识、持续监视、同盖茨管理和流动性提供。LSP 可以为用户处理所有这些复杂性，也确实值得赞誉。这是一个巨大的用户体验升级。</p><p>然而，为了使用 LSP，同时保持 “非托管”，整个行业采用了盲目签名模式。这个补丁很简单：由 LSP 来运行你的节点，而你保管你的私钥。有私钥、就有币，不是这样的吗？</p><p>根本不是。当你的私钥会盲目签名 LSP 的节点请求而不加验证时，你实际上是在信任 LSP 不会偷你的钱。这不是自主保管，充其量是共享保管。</p><p>讽刺之处在于：LSP 让闪电钱包变得可用，而盲目签名又让它变得不安全，比热钱包和托管服务都要不安全。你得到的是没有控制杆的复杂性。</p><p>好消息是：LSP 的便利不是非付出这样的代价不可。带验证的签名就可以解决这个问题。</p><blockquote><p>译者注：文中所述的这种对 LSP 的用法，应该只是其中一种，甚至可能不是主要的用法。</p></blockquote><h2 id="VLS-如何修复这个问题"><a href="#VLS-如何修复这个问题" class="headerlink" title="VLS 如何修复这个问题"></a>VLS 如何修复这个问题</h2><p>“VLS（带验证的闪电钱包签名器）” 实现了每个闪电钱包签名器都应该做到的事：在签名之前先验证。</p><p>在签名任何东西之前，VLS 都会检查：</p><blockquote><p><strong>协议兼容性</strong></p><ul><li>这是一个陈旧的状态吗？是 -&gt; 拒绝</li><li>HTLC 的余额匹配吗？ 是 -&gt; 通过</li><li>交易的手续费数额合理吗？ -&gt; 检查限制</li><li>支付目的地得到过许可吗？是 -&gt; 通过</li></ul></blockquote><blockquote><p><strong>用户条款</strong></p><ul><li>支付数额在限制之内</li><li>关闭通道的支付地址在许可列表上</li><li>阻挡不常见的使用模式</li><li>大额交易需要额外许可</li></ul></blockquote><blockquote><p><strong>独立验证</strong></p><ul><li>专门验证区块链状态</li><li>独立跟踪通道状态</li><li>监视时间锁过期</li><li>交叉检查节点声明</li></ul></blockquote><h2 id="VLS-在行动"><a href="#VLS-在行动" class="headerlink" title="VLS 在行动"></a>VLS 在行动</h2><table><thead><tr><th></th><th>盲目签名器</th><th>VLS</th></tr></thead><tbody><tr><td>节点</td><td>“关闭通道，将资金发送到地址 X”</td><td>“关闭通道，将资金发送到地址 X”</td></tr><tr><td>签名器动作</td><td>“收到！签名！”</td><td>“X 是不是白名单上的地址？交易表示最新状态吗？数额对不对得上？”</td></tr><tr><td>结果</td><td>资金可能被盗</td><td>恶意请求被阻拦，资金安全</td></tr></tbody></table><h2 id="证明这真的有用：Blockstream-Greenlight-钱包"><a href="#证明这真的有用：Blockstream-Greenlight-钱包" class="headerlink" title="证明这真的有用：Blockstream Greenlight 钱包"></a>证明这真的有用：Blockstream Greenlight 钱包</h2><p><a href="https://blockstream.com/lightning/greenlight/">Greenlight</a> 证明了 VLS 可以大规模应用：</p><ul><li><strong>架构</strong>：Blocsteam 运行节点，用户通过 VLS 控制验证</li><li><strong>跟踪记录</strong>：没有资金因为节点被攻陷而丢失</li><li><strong>安全性</strong>：节点被攻陷也无法盗窃资金</li><li><strong>性能</strong>：亚秒级验证，不影响用户体验</li><li><strong>用户</strong>：数千名用户用上了真正的自主保管</li></ul><p>这种模式证明了你可以获得 LSP 的便利性，并且在托管上无需牺牲。<a href="https://vls.tech/posts/lightning-custody-models/posts/greenlight-case-study/">这里</a>更加详细了讲解了为什么 Greenlight 选择了 VLS 以及他们的集成经验。</p><h2 id="闪电钱包的四种托管模式"><a href="#闪电钱包的四种托管模式" class="headerlink" title="闪电钱包的四种托管模式"></a>闪电钱包的四种托管模式</h2><p>了解你用的闪电钱包落在光谱的哪个位置，是极为关键的：</p><h3 id="1-完全托管"><a href="#1-完全托管" class="headerlink" title="1. 完全托管"></a>1. 完全托管</h3><p><strong>你持有</strong>：空气</p><p><strong>他们持有</strong>：私钥 + 节点</p><p><strong>保管程度</strong>：0%（他们控制着所有东西）</p><p><strong>攻击界面</strong>：1 个点（托管商）</p><p><strong>案例</strong>：绝大部分交易所钱包</p><p><strong>适合用户</strong>：初次尝试用闪电网络来买杯咖啡的用户</p><h3 id="2-共享托管：盲目签名"><a href="#2-共享托管：盲目签名" class="headerlink" title="2. 共享托管：盲目签名"></a>2. 共享托管：盲目签名</h3><p><strong>你持有</strong>：私钥，但它盲目签名</p><p><strong>他们持有</strong>：请求签名的节点</p><p><strong>保管程度</strong>：大约 50%，共享托管：双方都需要对方，但是节点可以欺骗签名器</p><p><strong>攻击界面</strong>：2 个点（节点 <strong>或者</strong> 签名器 被攻陷 &#x3D; 资金丢失）</p><p><strong>案例</strong>：许多 “非托管的” LSP 钱包</p><p><strong>事实检查</strong>：比完全托管更糟 —— 更复杂、更多攻击界面、依然需要信任</p><h3 id="3-自主保管的热钱包"><a href="#3-自主保管的热钱包" class="headerlink" title="3. 自主保管的热钱包"></a>3. 自主保管的热钱包</h3><p><strong>你持有</strong>：私钥 + 节点，放在同一个设备上</p><p><strong>他们持有</strong>：无</p><p><strong>保管程度</strong>：100%（你控制着所有东西）</p><p><strong>攻击界面</strong>：1 个点（你的设备）</p><p><strong>案例</strong>：Zeus（使用本地节点模式）、Phoenix（自主保管）</p><p><strong>适合用户</strong>：习惯热钱包风险的专业用户</p><h3 id="4-使用带验证签名器（VLS）的自主保管钱包"><a href="#4-使用带验证签名器（VLS）的自主保管钱包" class="headerlink" title="4. 使用带验证签名器（VLS）的自主保管钱包"></a>4. 使用带验证签名器（VLS）的自主保管钱包</h3><p><strong>你持有</strong>：私钥 + 验证逻辑</p><p><strong>他们持有</strong>：节点（但无法偷盗）</p><p><strong>保管程度</strong>：100%（节点可以提议，但只有你才能许可）</p><p><strong>攻击界面</strong>：1 个加强点（带有验证逻辑的签名器）</p><p><strong>案例</strong>：Blockstream 的 Greenlight，使用 VLS</p><p><strong>适合用户</strong>：任何投入具有重要意义资金数量的用户</p><h2 id="现状：谁是真正的非托管？"><a href="#现状：谁是真正的非托管？" class="headerlink" title="现状：谁是真正的非托管？"></a>现状：谁是真正的非托管？</h2><p>以下是关于闪电钱包和 LSP 在托管模式光谱具体位置的表格。你可以看看多少 “非托管” 的服务实际上使用了盲目签名模式。营销口号不一定跟技术事实相匹配！</p><p>（本表格收集的信息截至 2025 年 11 月 7 日。）</p><table><thead><tr><th align="left">产品</th><th align="left">类型</th><th align="left">保管模式</th><th align="left">签名器类型</th><th align="left">密钥位置</th><th align="left">节点位置</th></tr></thead><tbody><tr><td align="left">Alby</td><td align="left">钱包</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">用户设备</td><td align="left">用户设备</td></tr><tr><td align="left">Bitkit (Synonym)</td><td align="left">钱包</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">用户设备</td><td align="left">用户设备</td></tr><tr><td align="left">Blockstream App</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Blockstream Greenlight</td><td align="left">LSP</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Blocktank (Synonym)</td><td align="left">LSP</td><td align="left">共享托管（盲目签名）</td><td align="left">盲目签名器</td><td align="left">用户设备</td><td align="left">供应商</td></tr><tr><td align="left">BlueWallet</td><td align="left">钱包</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">用户设备</td><td align="left">用户设备</td></tr><tr><td align="left">Breez SDK</td><td align="left">LSP</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Cash App</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Electrum</td><td align="left">钱包</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">用户设备</td><td align="left">用户设备</td></tr><tr><td align="left">IBEX Mercado</td><td align="left">LSP</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Lightspark</td><td align="left">LSP</td><td align="left">共享托管（盲目签名）</td><td align="left">盲目签名器</td><td align="left">用户设备</td><td align="left">供应商</td></tr><tr><td align="left">Muun</td><td align="left">钱包</td><td align="left">并非一个闪电钱包</td><td align="left">N&#x2F;A</td><td align="left">N&#x2F;A</td><td align="left">N&#x2F;A</td></tr><tr><td align="left">Phoenix (ACINQ)</td><td align="left">钱包</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">用户设备</td><td align="left">用户设备</td></tr><tr><td align="left">River</td><td align="left">LSP</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Strike</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Voltage</td><td align="left">LSP</td><td align="left">共享托管（盲目签名）</td><td align="left">盲目签名器</td><td align="left">用户设备</td><td align="left">供应商</td></tr><tr><td align="left">Wallet of Satoshi</td><td align="left">钱包</td><td align="left">共享托管（盲目签名）</td><td align="left">盲目签名器</td><td align="left">用户设备</td><td align="left">供应商</td></tr><tr><td align="left">ZEUS</td><td align="left">钱包</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">用户设备</td><td align="left">用户设备</td></tr><tr><td align="left">BitBox (Shift Crypto)</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">bitmo.me</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Blink (Galoy)</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Blixt Wallet</td><td align="left">钱包</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">用户设备</td><td align="left">用户设备</td></tr><tr><td align="left">Bringin Wallet</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Cake Wallet</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Coinos</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Cowbolt</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Evomone</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Flash</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Grimm App</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Klever Wallet</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">LEXE</td><td align="left">LSP</td><td align="left">非托管（热钱包）</td><td align="left">节点</td><td align="left">Intel SGX</td><td align="left">Intel SGX</td></tr><tr><td align="left">LIGHTNINGPAY</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">lipa</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Machankura (8333.mobi)</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Mooze Labs</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Ordermoon</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">PICNIC GROUPS</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Pouch.ph</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Satoshi App</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Satsails</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Shakesco wallet</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Sorted Wallet</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Speed Wallet</td><td align="left">钱包</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Swapso</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">Yopaki</td><td align="left">钱包</td><td align="left">非托管</td><td align="left">带验证的签名器</td><td align="left">用户设备 (VLS)</td><td align="left">供应商</td></tr><tr><td align="left">ZEBEDEE</td><td align="left">LN App</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr><tr><td align="left">Zero Hash</td><td align="left">LSP</td><td align="left">托管</td><td align="left">节点</td><td align="left">托管商</td><td align="left">供应商</td></tr></tbody></table><h2 id="如何检查你当前使用的钱包是什么模式"><a href="#如何检查你当前使用的钱包是什么模式" class="headerlink" title="如何检查你当前使用的钱包是什么模式"></a>如何检查你当前使用的钱包是什么模式</h2><p>询问你的闪电钱包供应商以下几个问题：</p><blockquote><p><strong>问题 1：“如果你的 服务器&#x2F;节点 今天被劫持了，攻击者能否偷走我的钱？”</strong></p><p>“不能，因为验证程序保护了它” -&gt; 带有验证的签名器的自主保管钱包</p><p>“不能，因为私钥在你手上” -&gt; 盲目签名钱包警告</p><p>“是的，你会丢钱” -&gt; 至少他们是诚实的</p></blockquote><blockquote><p><strong>问题 2：“签名器在签名之前，会执行哪些具体的检查？”</strong></p><p>详细的验证清单 -&gt; 真正的自主保管</p><p>“它会签名你授权的东西” -&gt; 盲目签名</p><p>含糊其辞的安全口号 -&gt; 盲目签名</p></blockquote><blockquote><p><strong>问题 3：“我的通道关闭时，剩余的余额可以发送到任何地址吗？”</strong></p><p>“只能发送到你限定的地址” -&gt; 带有验证</p><p>“将发送到你签了名的任何地址” -&gt; 盲目签名</p></blockquote><h2 id="为你的资金选择正确的托管模式"><a href="#为你的资金选择正确的托管模式" class="headerlink" title="为你的资金选择正确的托管模式"></a>为你的资金选择正确的托管模式</h2><blockquote><p>“<strong>买一杯咖啡的钱</strong>”</p><ul><li>完全托管钱包也没啥 —— 简单，而且在信任模式上是诚实的</li><li>避免盲目签名模式 —— 这是不必要的复杂性</li></ul></blockquote><blockquote><p>“<strong>日常开支</strong>”</p><ul><li>热钱包，如果你懂技术的话</li><li>如果你不懂技术，选择高质量的托管 LSP</li><li>明确规避盲目签名的风险</li></ul></blockquote><blockquote><p>“<strong>不小的钱</strong>”</p><ul><li>只使用带有验证签名器（比如 VLS）的自主保管钱包</li><li>热钱包也可以，只要你确定自己知道相关的风险</li><li>永远不要使用盲目签名钱包</li></ul></blockquote><blockquote><p><strong>企业用户&#x2F;交易所保证金</strong>：</p><ul><li>VLS 是唯一负责人的选择</li></ul></blockquote><p><strong>除非钱的数目小到你丢了也无所谓，否则就不要使用盲目签名模式。它会让攻击界面倍增，比其它选择都更危险。</strong></p><h2 id="呼吁开发者行动：不要发布盲目签名器"><a href="#呼吁开发者行动：不要发布盲目签名器" class="headerlink" title="呼吁开发者行动：不要发布盲目签名器"></a>呼吁开发者行动：不要发布盲目签名器</h2><p><strong>使用哪种装置？</strong></p><ul><li><p><strong>我是一家企业或者 app 的开发者，只想要一个安全的闪电钱包装置，不想做繁重的基础设施</strong></p><p>-&gt; 使用一个由 VLS 赋能的<strong>带设施非托管供应商</strong>：<a href="https://blockstream.com/lightning/greenlight/">Blockstream 的 Greenlight</a> 或者 <a href="https://breez.technology/">Breez SDK</a>。</p></li><li><p><strong>我希望控制我自己的闪电节点，但不希望从头开发所有东西</strong></p><p>-&gt; 使用 <a href="https://vls.tech/docs/latest/get-started/cln-vls/">CLN + VLS</a> ；安全又灵活，无需完全定制的插件。</p></li><li><p><strong>我希望完全控制权以及深入的集成灵活性</strong></p><p>-&gt; 使用 <a href="https://vls.tech/docs/latest/get-started/ldk-vls/">LDK + VLS</a> ；适合定制化的部署。</p></li></ul><p style="text-align:center">- - -</p><p><strong>使用哪种闪电钱包技术栈？</strong></p><p>选择你的起点：</p><ul><li><p><a href="https://vls.tech/docs/latest/get-started/cln-vls/">CLN + VLS</a></p><p>使用我们的 <code>vls-hsmd</code> 插件来转发来自 Core Lightning 节点的签名请求。</p></li><li><p><a href="https://vls.tech/docs/latest/get-started/ldk-vls/">LDK + VLS</a></p><p>通过 <code>vls-proxy</code> 库，集成到你的基于 LDK 的节点。</p></li><li><p><a href="https://vls.tech/docs/latest/get-started/docker/">Docker 沙盒</a></p><p>使用 Docker 运行 CLN + VLS + Bitcoind 。非常适合测试。</p></li><li><p><strong>LND 或 Eclair</strong></p><p>尚未支持 VLS 。请帮忙向 LND 和 Eclair 请求支持 VLS：</p><ul><li><a href="https://lightning.engineering/">LND</a></li><li><a href="https://acinq.co/">Eclair</a></li></ul></li></ul><p>没有技术上的借口再使用盲目签名器了。VLS 是 Apache 许可的开源软件，而且准备好进入生产环境了。</p><h2 id="你的行动：要求真正的自主保管"><a href="#你的行动：要求真正的自主保管" class="headerlink" title="你的行动：要求真正的自主保管"></a>你的行动：要求真正的自主保管</h2><p>闪电钱包生态已经将持有私钥与控制资金混淆了太久了。盲目签名是带有额外步骤的共享托管，并非自主保管。</p><p>VLS 证明了，真正的自主保管闪电钱包是可以做到的。不要再找借口，不要再用盲目签名模式。</p><h2 id="前进的道路"><a href="#前进的道路" class="headerlink" title="前进的道路"></a>前进的道路</h2><p>闪电网络的未来取决于我们对待托管模式的诚实。我们请求：</p><p><strong>用户</strong>：</p><ol><li>理解你真正信任的东西</li><li>选择与你的风险偏好相匹配的托管模式</li><li>向钱包供应商要求透明性</li><li>用你的聪投票：支持真正的自主保管</li></ol><p><strong>开发者</strong>：</p><ol><li>别再把盲目签名叫做 “非托管”</li><li>实现验证逻辑，或者在托管模式上诚实</li><li>在真正的安全性上竞争，而不是打营销战</li><li>区分出真正的非托管产品</li></ol><p><strong>闪电网络生态</strong>：</p><ol><li>将带验证签名确定为行业最低标准</li><li>指出盲目签名的实质：共享托管</li><li>用户将真正的自主保管放在优先地位的项目</li><li>完全淘汰盲目签名</li></ol><p>现在你知道真相了：那么你会怎么做呢？</p><ul><li><strong>今天</strong>：使用我们的问题来检查你当前使用的钱包</li><li><strong>这周</strong>：如有需要，移动资金到带有验证的非托管钱包</li><li><strong>未来</strong>：要求透明性，支持真正的解决方案。</li></ul><p>没有验证，你的私钥就不控制你的钱币。请做出明智的选择。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">没有验证，你的私钥就不控制你的钱币</summary>
    
    
    
    
    <category term="钱包" scheme="https://www.btcstudy.org/tags/%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Ark 作为一种通道工厂：压缩流动性管理以提高支付可行性</title>
    <link href="https://www.btcstudy.org/2026/02/06/ark-as-a-channel-factory-compressed-liquidity-management-for-improved-payment-feasibility/"/>
    <id>https://www.btcstudy.org/2026/02/06/ark-as-a-channel-factory-compressed-liquidity-management-for-improved-payment-feasibility/</id>
    <published>2026-02-06T04:06:17.000Z</published>
    <updated>2026-02-28T07:32:23.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Pickhardt</em></p><p><em>来源：<a href="https://delvingbitcoin.org/t/ark-as-a-channel-factory-compressed-liquidity-management-for-improved-payment-feasibility/2179">https://delvingbitcoin.org/t/ark-as-a-channel-factory-compressed-liquidity-management-for-improved-payment-feasibility/2179</a></em></p></blockquote><p>在过去几个月中，我在许多双边谈话中讨论了这篇文章中的想法。为了避免重复不连贯的主张并邀请更多反馈，我将它们写在这里。我向已经熟悉这些概念的读者们道歉，并欢迎评论、反驳和提出开放问题。</p><p>注：<strong>因为我的母语并不是英语，所以我用了 LLM（大语言模型）来润色我的文字；而其中的技术内容和论点都属于我自己。在我指导 LLM 的时候，我并没有偏离标准的格式和语言风格。</strong></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>闪电网络支持快速、非托管的比特币支付，前提是在一个支付流的沿路（通常只有一条路径）都有充足的流动性。然而，<strong>支付可行性</strong>（payment feasibility）（这样一个支付流的存在性）是一个结构性的约束，无法单单靠对路由的启发式分析或者链外的再平衡（rebalancing）来解决。在流动性不足的时候，<strong>就要发送链内交易来修改通道图谱</strong>，这在根本上限制了闪电网络扩大比特币支付吞吐量的能力。</p><p>众所周知多方通道能够提升资金效率，但在实践中很难协调。Ark 提出了一种机制，以回合为单位协调多方的状态更新，以相对较低的协调开销让成员们对一个新状态达成共识。本文想要挑战当前正在形成的观点：Ark 应主要用作一种服务于 “最后一公里”  的支付系统，彼此之间通过闪电通道连接。相反，本文主张，把 Ark 理解为<strong>闪电网络的基础设施</strong>，可能更好，尤其是，作为一种 “<strong>通道工厂</strong>”，它可以带来高效的流动性重新配置。本文的关注点是这样做的取舍、可行性约束，以及开放的研究问题。</p><p><strong>重要提醒</strong>：本文并没有明确反对将 Ark 用于支付，只是追问有没有更好的应用场景。</p><h2 id="1-回顾支付可行性和闪电网络的结构性限制"><a href="#1-回顾支付可行性和闪电网络的结构性限制" class="headerlink" title="1. 回顾支付可行性和闪电网络的结构性限制"></a>1. 回顾支付可行性和闪电网络的结构性限制</h2><p>一次闪电支付是可行的，当发送者与接收者在流动性图谱之间的<strong>最小割</strong>（minimum cut）超出了支付数量。在实践中，可行性是难以确定的，因为<a href="https://arxiv.org/abs/2103.08576">远端的通道余额存在不确定性</a>。这种不确定可以通过使用<a href="https://arxiv.org/abs/2107.05322">概率性路由和最优的可靠支付流来减少</a>。</p><p>然而，即使优化路由、手续费更新和再平衡能够提高利用率，<a href="https://github.com/renepickhardt/Lightning-Network-Limitations/blob/f670738cd2af93a55c3c919c9a864015f6dd042a/Limits%20of%20two%20party%20channels/paper/a%20mathematical%20theory%20of%20payment%20channel%20networks.pdf">它们无法改变全局的支付可行性</a>，除非通道图谱自身改变。</p><p>尤其是：</p><ul><li>链外的再平衡技术可以重新分布现有通道中的流动性。</li><li>它 <em>不会</em> 创造新的连接性或单向通行能力（directional capacity）。</li><li>在无法存在可行的支付流时，就需要发起一笔<strong>链内交易</strong>（开启通道、关闭通道、通道拼接，等等）。</li></ul><p>这个区别就是核心。即使一个节点可以将流动性从一条通道移动到另一条通道（通过环路支付），这样的操作也会影响远端的通道，因此不会定向地提高一笔可欲的支付的可行性。想要局部地改变可行性而不影响网络的其余部分，就只有通过链内交易介入。</p><p>《<a href="https://github.com/renepickhardt/Lightning-Network-Limitations/blob/f670738cd2af93a55c3c919c9a864015f6dd042a/Limits%20of%20two%20party%20channels/paper/a%20mathematical%20theory%20of%20payment%20channel%20networks.pdf">支付通道网络的一种数学理论</a>》中的形式化分析证明了，<strong>最大可行支付速率</strong>（maximum supported payment rate）极度依赖于：</p><ul><li>固定的可用的链内带宽，以及</li><li>预期的不可行支付比率。</li></ul><p>这对两方支付通道网络限制非常严重，在现实的假设之下，如果没有持续的链内带宽支持，预期的不可行支付比率可以变得非常高。这一局限性促使人们探索协调机制，以使用更少的链上足迹来重新构造支付网络图拓扑。</p><h2 id="2-Ark：回合与虚拟-UTXO"><a href="#2-Ark：回合与虚拟-UTXO" class="headerlink" title="2. Ark：回合与虚拟 UTXO"></a>2. Ark：回合与虚拟 UTXO</h2><p>Ark 引入了 “<strong>回合</strong>（rounds）” 的概念：同一回合的参与者们，在一个 Ark 服务提供商（ASP）的协调之下交换 “<strong>虚拟 UTXO</strong>（vTXO）”。这些 vTXO 代表着链外的价值承诺，可以在一段时间内重新分配。</p><p>看起来，Ark 风格的系统通过引入 ASP 作为协调员，减少了 coin pool（直译为 “钱币池”）的协调和在线交互要求；ASP 会在一个固定的时间窗口内提供过量的流动性，从而不必每个人都立即同一每一个新状态，而只需最终同意即可。这是一个非常好的属性。</p><p>然而，在 Ark <em>直接</em> 用作一个支付系统时，其三个属性就不可不察：</p><ol><li><strong>因为过期机制而带来的流动性锁定</strong>：vTXO 带有过期机制，在还未过期时， ASP 的资金是一直绑定的，等到过期之后才会释放。</li><li><strong>找零放大</strong>：支付通常要销毁一个输入、创建多个输出（收款和找零），这就增加了 ASP 必须垫付的流动性数量。</li><li><strong>回合间结算的信任因素</strong>：支付只能在回合边界上最终结算。在两个回合之间，花掉的 vTXO 在理论上是可以重复花费的，这就产生了关于托管和 ASP 角色的合规解释的问题。</li></ol><p>如果 vTXO 会在到期之前频繁支付，ASP 需要的运营资本<a href="https://bitcoin.stackexchange.com/questions/128113/how-well-does-ark-scale-bitcoin-payments">可能会显著增长（相对于净支付额）</a>。这让 Ark 可以独自提供低开销、可扩展的支付层的论述变得更加复杂。</p><h2 id="3-将-Ark-解读为一种通道工厂，和闪电网络的基础设施"><a href="#3-将-Ark-解读为一种通道工厂，和闪电网络的基础设施" class="headerlink" title="3. 将 Ark 解读为一种通道工厂，和闪电网络的基础设施"></a>3. 将 Ark 解读为一种通道工厂，和闪电网络的基础设施</h2><p>另一种解读是不把 Ark 当成一种与闪电网络竞争的支付系统，而是<strong>闪电网络之下的基础设施</strong>。更具体来说，可以把它理解成<strong>一种通道工厂，或者说多方通道机制</strong>。</p><p>在这种理解之下：</p><ul><li>vTXO 对应于闪电通道，</li><li>一个 Ark 回合自动可以打开、关闭和重塑许多通道，</li><li><strong>单笔链内交易</strong>就可以可以<strong>重新构造通道图谱的一大部分</strong>。</li></ul><p>这与路由和（链外）再平衡都有根本上的不同。它不是 <em>在</em> 一个固定的图谱中优化支付流，而是带来图谱自身的脱坡的结构性变化，这就有可能让以往不可行的支付成为可行。</p><p>多种通道操作 —— 注资、关闭、拼接 —— 都能被压缩到单笔 Ark 回合交易中。因为闪电网络已经为这样的变更要求链上确认，所以 Ark 也不会让时延恶化，因为 Ark 的回合最终可以在每个区块中发生。</p><h2 id="4-流动性重新配置和操作考虑"><a href="#4-流动性重新配置和操作考虑" class="headerlink" title="4. 流动性重新配置和操作考虑"></a>4. 流动性重新配置和操作考虑</h2><p>闪电网络运营者已经需要：</p><ul><li>监视通道，</li><li>响应链内事件，</li><li>偶尔再平衡或者关闭通道。</li></ul><p>在 Ark 回合中轮换 vTXO（例如，每个月几次），从操作上来看是同类的。具有更高利用率的通道可能要求更加频繁的轮换，这可以在通道还被主动使用时协调。</p><p>故障假设在细节上有所不同，但类型上是一样的：运营者需要定期参与，而不是持续监视。</p><h2 id="5-流动性池与动态分配"><a href="#5-流动性池与动态分配" class="headerlink" title="5. 流动性池与动态分配"></a>5. 流动性池与动态分配</h2><p>在一个通道工厂（或者说多方通道）中：</p><ul><li>流动性会在参与者之间形成池子，</li><li>各池子的规模可以一轮又一轮地调整，</li><li>需求可以被预测，或者动态响应。</li></ul><p>这与当前的 LSP 模式恰好相反：在 LSP 模式中，流动性是以用户为单位提供的，通常会保持闲置状态，或者分布不均。</p><p>而池化可以提高资金效率 —— 尤其是（但也不限于）对移动客户端 —— Ark 也是如此，只是引入了取舍，包括过期事件、协调开销和 ASP 的流动性管理。确定最优的超时参数（让 ASP 重新领取 vTXO）依然是一个开放问题。</p><h2 id="6-与闪电网络集成与托管考虑"><a href="#6-与闪电网络集成与托管考虑" class="headerlink" title="6. 与闪电网络集成与托管考虑"></a>6. 与闪电网络集成与托管考虑</h2><p>当 Ark 被用作一种基础设施时：</p><ul><li>支付发生在闪电 通道&#x2F;网络 中，</li><li>结算依然是原子化、端到端的，</li><li>ASP 协调流动性，但并不作为支付的中介。</li></ul><p>这保持了闪电通道的非托管、实时结算属性。相反，在支付中直接使用 Ark 会在回合间引入信任假设。</p><p>各司其职 —— 闪电通道用于支付、Ark 用于流动性协调 —— 保持了闪电网络的核心保证，比如支付的即时结算和强壮的隐私性，同时解决了结构性的可扩展性限制。</p><h2 id="7-路由、Gossip-和开放问题"><a href="#7-路由、Gossip-和开放问题" class="headerlink" title="7. 路由、Gossip 和开放问题"></a>7. 路由、Gossip 和开放问题</h2><p>通过 vTXO 来注资的通道缺少链上注资交易，因此在当前，无法通过闪电网络的 gossip 来公开。这带来了几个开放问题：</p><ul><li>这样的通道，要如何向路由者表示？</li><li>路由应该在工厂的层面上运行吗？</li><li>“流动性广告（liquidity advertisement）” 是否需要新的抽象？</li><li>这些机制会如何影响隐私性和可靠性？</li><li>应该限制基于 vTXO 的通道只能在 ASP 和用户间存在？还是可以直接在用户之间存在？</li></ul><h2 id="8-延申的开放问题"><a href="#8-延申的开放问题" class="headerlink" title="8. 延申的开放问题"></a>8. 延申的开放问题</h2><p>将 Ark 视为闪电网络的基础设施，而不是一种独立的支付系统，可以厘清一些取舍，但也提出了一些值得研究的其它开放问题：</p><ul><li><strong>激励因素与 ASP 的行为</strong>：激励因素应如何保持一致，从而让 ASP 的流动性管理决策能够提升闪电网络层面的支付可行性，而不仅仅是局部的盈利能力？多个 ASP 之间的竞争会如何影响流动性分配和定价？</li><li><strong>中心化压力</strong>：在多方构造中汇集流动性，是否会偏向少数量、大规模工厂的规模经济？这与闪电网络如今已经存在的支付中心和 LSP 的效应相比如何？</li><li><strong>故障模式和退出</strong>：根据 <a href="https://petertodd.org/2024/covenant-dependent-layer-2-review">Peter Todd 论述 Layer 2 的文章</a>（<a href="https://www.btcstudy.org/2024/09/11/soft-for-covenant-dependent-layer-2-review/">中文译本</a>）：ASP 故障（或者说大规模退出）的链内后果和运营后果是什么样的？系统的压力要如何优雅地释放？以及，最坏情况下，链内操作的代价是多大？</li><li><strong>时延与可行性</strong>：Ark 可以支持结构性的重新配置，但每逢一个回合才能配置一次。回合的频率和过期窗口要如何选择，才能平衡支付可行性、资金效率和用户体验？</li><li><strong>隐私性考虑</strong>：基于回合的协调机制是否会逐渐泄露关于需求模式的信息或用户的活动？匿名集与双向闪电通道相比如何？</li><li><strong>互操作性和路由抽象</strong>：vTXO 注资的通道如何向路由者表示（给定它没有链内的注资交易）？需要新的 gossip 消息或者工厂层面的抽象吗？</li></ul><p>这些问题也不专属于 Ark ，而是无论什么时候，只要多方流动性协调装置出现了，就会自然提出的问题。解决它们，对于理解这样的机制如何与闪电网络互补，是根本性的。 </p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>Pickhardt et al., <em>On the Uncertainty of Lightning Network Channel Balances</em> [<a href="https://arxiv.org/abs/2103.08576">2103.08576] Security and Privacy of Lightning Network Payments with Uncertain Channel Balances</a></li><li>Pickhardt &amp; Richter, <em>Optimally Reliable Payment Flows on the Lightning Network</em> [<a href="https://arxiv.org/abs/2107.05322">2107.05322] Optimally Reliable &amp; Cheap Payment Flows on the Lightning Network</a></li><li>Pickhardt <em>A Mathematical Theory of Payment Channel Networks</em> (draft) [Lightning-Network-Limitations&#x2F;Limits of two party channels&#x2F;paper&#x2F;a mathematical theory of payment channel networks.pdf at f670738cd2af93a55c3c919c9a864015f6dd042a · renepickhardt&#x2F;Lightning-Network-Limitations · GitHub](<a href="https://github.com/renepickhardt/Lightning-Network-Limitations/blob/f670738cd2af93a55c3c919c9a864015f6dd042a/Limits">https://github.com/renepickhardt/Lightning-Network-Limitations/blob/f670738cd2af93a55c3c919c9a864015f6dd042a/Limits</a> of two party channels&#x2F;paper&#x2F;a mathematical theory of payment channel networks.pdf)</li><li>Pickhardt <em>How well does Ark scale Bitcoin payments?</em> <a href="https://bitcoin.stackexchange.com/questions/128113/how-well-does-ark-scale-bitcoin-payments">https://bitcoin.stackexchange.com/questions/128113/how-well-does-ark-scale-bitcoin-payments</a> 5 Todd, <em>Covenant dependent layer 2 review</em> <a href="https://petertodd.org/2024/covenant-dependent-layer-2-review">Soft-Fork&#x2F;Covenant Dependent Layer 2 Review</a>.</li><li>BTC++ Talk on Lightning scaling and limitations <a href="https://www.youtube.com/watch?v=c3AuaHJordg">https://www.youtube.com/watch?v=c3AuaHJordg</a></li><li>Bitcoin Amsterdam LN vs Ark panel (2025) <a href="https://www.youtube.com/watch?v=AU52kQz2zIM">https://www.youtube.com/watch?v=AU52kQz2zIM</a></li></ol><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>在 BTC++ 和 Bitcoin Amsterdam 上与许多朋友的讨论以及得到的反馈，帮助我理清了这些论述。本研究就到了 Optensats 和 Patreons 的资助。</p>]]></content>
    
    
    <summary type="html">本文主张，把 Ark 理解为闪电网络的基础设施</summary>
    
    
    
    
    <category term="Ark" scheme="https://www.btcstudy.org/tags/Ark/"/>
    
    <category term="joinpool" scheme="https://www.btcstudy.org/tags/joinpool/"/>
    
  </entry>
  
  <entry>
    <title>让挖矿带来更多完全验证的比特币用户</title>
    <link href="https://www.btcstudy.org/2026/02/05/using-mining-to-create-more-fully-validating-bitcoin-users/"/>
    <id>https://www.btcstudy.org/2026/02/05/using-mining-to-create-more-fully-validating-bitcoin-users/</id>
    <published>2026-02-05T03:44:07.000Z</published>
    <updated>2026-02-28T07:32:23.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：DMND</em></p><p><em>来源：<a href="https://blog.dmnd.work/using-mining-to-create-more-fully-validating-bitcoin-users/">https://blog.dmnd.work/using-mining-to-create-more-fully-validating-bitcoin-users/</a></em></p></blockquote><p>比特币的价值依赖于它抵抗任意类型审查的能力。没有这个特性，比特币就失去了挑战和抵抗权威的力量，然后折服在传统世界通行的同一套规则之下。有鉴于此，比特币绝不能形成任何意义上的单点故障。<strong>只要有一个看门人，就有一个漏洞。只要有一个漏洞，它就一定会被利用。那时候，比特币作为一项自由及去中心化电子货币运动将宣告死亡</strong>。</p><p>为了保证网络的去中心化、健壮性和反脆弱性，我们需要维护这些终极属性中的终极元素，从而保护我们扛住时间的考验。不能让世界上的任何人觉得攻击比特币是小菜一碟。要做到这一点，最好的办法就是通过在全世界的各个角落运行比特币网络节点，让比特币尽可能分散。就像一种货币病毒，它越分散，成功的机会越高。</p><p>中本聪多次提到，以往所有的电子货币项目都失败了，原因在于它们的中心化属性。货币供给量的垄断是一种权力，政府和金融系统不会轻易放手。为了保证比特币不会被任何恶人打败，我们的使命是保证比特币的去中心化与日俱增，直至永远。</p><blockquote><p><em>“许多人都不假思索地认为电子货币是注定要失败的，因为从 1990 年代以来，所有尝试的公司都失败了。我希望各位能够看出，挫败他们的仅仅是这些系统的中心化控制本性。我认为，这（比特币）是我们第一次尝试一种去中心化的、不基于信任的系统。”</em></p></blockquote><p>比特币是点对点货币的开源实现。</p><p>纵观比特币已经实现的东西以及它当前作为一个全球网络的现状，事实是这个网络是非常去中心化的。而且，就像有人会说比特币的购买力不会有上限，比特币的去中心化程度也不会有上限。多多益善！去中心化达到一定程度之后，任何对比特币的攻击都不仅仅是对攻击者而言毫无意义，也是自我消解，因为攻击者的任何失败最终都会加强比特币抵御任何攻击的能力（在这个过程中增强比特币网络），然后削弱任何攻击的预期成功率。这是反脆弱性最纯粹的形式！</p><p><img src="/../images/using-mining-to-create-more-fully-validating-bitcoin-users/d6xahzm-pre-1.jpg" alt="img"></p><p style="text-align:center">- Hydra（九头蛇）——《启示录》中的魔法生物。每砍掉它的一个头，它都会再长出两个头。也就是每次攻击它，都会让它变得更加强大。Hydra 是反脆弱的。比特币是一个货币九头蛇。 -</p><p>那么什么程度的去中心化，才能让任何潜在的攻击都会被劝退？没人知道，我们只能预估。而且，最好的策略就是尽我们所能，让比特币尽可能去中心化。而我们所拥有的最重要的工具，就是在全世界部署尽可能多的节点。</p><p>节点是比特币中最重要的角色（需要加上 “之一”吗？）。节点会应用协议的规则，验证所有传遍网络的交易和区块。它们也转发所有信息给其他节点，并存储所有的区块。如果一笔交易，或一个区块，违反了协议的规则，节点会自动拒绝（保存、转发）它。<strong>节点本质上就是比特币游戏的裁判，确保每个人都公平参与游戏，就像我们希望的那样。</strong></p><p><img src="/../images/using-mining-to-create-more-fully-validating-bitcoin-users/wood.png" alt="wood"></p><p style="text-align:center">- 比特币节点正在工作 -</p><p>有越多节点加入网络，就有越多裁判会验证在比特币网络中发生的所有事。越多节点加入网络，就有越多比特币历史（区块链）的完整备份。越多节点加入网络，就有更多保证：每个人都会按照准则行事。每次有个节点加入网络，想要攻击比特币的人为了杀死这个货币九头蛇就得多砍掉一个头。如果你还没有运行一个节点，现在正是时候了。</p><p>不幸的是 —— 大多数比特币用户并不知情 —— 绝大部分矿工 <em>并没有</em> 运行节点。矿工们想要凭工作量获得支付，只需向矿池运营者提供有效的份额。人们常常说，矿工们会因为保护网络抵御所有的敌意支付而获得支付，他们会筑起一道能源之墙，那是厚实到无法穿透的。然而，如果我们想继续使用这个类比，我们就要看到，现在的矿工是矿池的 “雇员”，不是比特币网络的雇员。矿工与网络之间没有直接的连接，实际上，他们只是以哈希率的形式，向矿池售卖计算机算力。挑选进入区块的交易、创建区块、让这样的区块传遍网络以及接收所有必要的信息 —— 这些事情全都被外包给了矿池。这实质上意味着，矿池决定着网络中会不会有审查，因此，中本聪对一个开放且免许可的价值传输协议的最初愿景，正在遭到破坏。</p><p>而且，如果你觉得这样还不足以破坏去中心化程度的话，还有 “代理矿池” 这种东西。代理矿池基本上就是披着羊皮的狼 —— 使用不同的品牌名，但实际上是同一家矿池（同一个运营主体）。也就是说，可能表面上看，一家大矿池 A 控制着整个网络 20% 的哈希率，还有 3 个较小的矿池 B、C、D 分别控制着 5%，但实际上，是 A 控制着 35% 。这已经足以发动 “自私挖矿” 攻击并伤寒整个网络。因此，最终我们得到的只是几家 “主要的” 矿池在决定着哪些交易可以进入区块链。这种情况看起来一点也不去中心化 —— 没错，因为实际上这就不是去中心化。幸运的是，还有办法能够解决它。它叫做 “Stratum V2”。</p><p>Stratum V2 是一种新的挖矿（矿池）协议，它希望能带来一系列新特性，让比特币挖矿更加安全、更加高效，也更加去中心化。它的开源参考实现是由独立、社区运营的超过 15 名开发者，在过去三年中开发的，经历过超过 3 万次下游的压力测试。使用这种新协议，比特币的去中心化可能会达到新的高度。</p><p>你必定会问，一个挖矿协议，怎么做到呢？因为它让矿工可以创建自己的区块模板、挑选进入区块的交易。为了拥有这种能力，矿工必须运行一个节点。更多节点意味着更加去中心化、更加健壮的网络。一旦所有矿工都自己构造区块而不是依赖矿池，我们就能见证比特币在去中心化化的方向上迈出一大步。</p><p><strong>是时候提升比特币的去中心化了。你会来吗？</strong></p><p>（完）</p>]]></content>
    
    
    <summary type="html">Stratum V2 可以帮助提升比特币在挖矿领域以及整体上的去中心化</summary>
    
    
    
    
    <category term="矿池" scheme="https://www.btcstudy.org/tags/%E7%9F%BF%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CSFS 的有趣用法（其一）</title>
    <link href="https://www.btcstudy.org/2026/02/04/fun-with-csfs-i-by-jeremy-rubin/"/>
    <id>https://www.btcstudy.org/2026/02/04/fun-with-csfs-i-by-jeremy-rubin/</id>
    <published>2026-02-04T08:36:28.000Z</published>
    <updated>2026-02-28T07:32:23.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Jeremy Rubin</em></p><p><em>来源：<a href="https://rubin.io/bitcoin/2025/03/05/csfs-fun/">https://rubin.io/bitcoin/2025/03/05/csfs-fun/</a></em></p></blockquote><p>在这个系列博客中，我会记录一些我注意到的 CSFS 的有趣用法。</p><p>目标是记录一些其他人可能还不知道的东西。</p><p>它们是我发明的吗？可能是，也可能不是。欢迎指出前人已经作出的成果！</p><h2 id="不可替换且不可复用的地址"><a href="#不可替换且不可复用的地址" class="headerlink" title="不可替换且不可复用的地址"></a>不可替换且不可复用的地址</h2><p>创建一个 Taproot 输出并使用 “NUMS 点” 作为内部公钥（使用 NUMS 密钥路径以及只设一个脚本树叶子（tapleaf），意味着你总是知道所有的花费选择），并使用这样一个脚本树叶子（tapleaf）：要么满足 <code>&lt;PK&gt; CHECKSIG</code>（检查签名）脚本，要么提供一个证据，证明有这个公钥对任何两个不同的数据生成了超过 1 个签名；然后，在两者中选其一：</p><ul><li>使用 CTV ，它可以发送到 OP_RETUREN；</li><li>不使用 CTV，它变成任何人都可以花费的。</li></ul><p>这意味着，只要你观察到了从这个地址发出的一笔交易的签名，你就知道，发送者不会发送另一笔签名，除非愿意上自己的资金被烧掉。</p><p>更多乐趣：</p><p>这种 “模棱两可保险” 也可以用在不同输出、不同地址中，以保护带有新的担保品的地址，甚至可以是 <em>回溯性的</em>。</p><h2 id="函数查找表预编译"><a href="#函数查找表预编译" class="headerlink" title="函数查找表预编译"></a>函数查找表预编译</h2><p>假设我们希望给比特币添加一种操作码，它可以求值 <code>f(x)</code> 。</p><pre><code>设 x = musig(巨大的联盟，带有一次性的启动仪式)设 CSFS(key, sig, data) = ...</code></pre><p>请回忆<a href="https://rubin.io/bitcoin/2024/12/02/csfs-ctv-rekey-symmetry/">密钥串联技巧</a>（<a href="https://www.btcstudy.org/2025/07/28/csfs-ctv-rekey-symmetry-by-jeremy-rubin/">中文译本</a>）……通过密钥串联来创建一个带有下列逻辑的脚本：</p><pre><code>CSFS(X, sig_x, sig_arg)CSFS(Tweaked(X, arg), sig_arg, arg)CSFS(Tweaked(X, arg), sig_f, f(arg)))sig_f != sig_arg</code></pre><p>现在，（在签名人委员会内）对 <code>arg</code> 的所有值运行 <code>f(arg)</code> 。</p><p>这样一来，你就得到了一张查找表（lookup table），可以用在任何脚本的任意体积的树结构中，开销是常量：3 个签名和 2 个公钥，也就是 256 字节，比使用 taproot 预先生成的树结构在许多情况下都便宜。</p><p>这种技术还可以修改成与多个参数一起工作，只要结果是可以预先计算出来的。这就排除了比如 <code>OP_CAT</code> 这样的 “大输出空间” 函数，但查找表中可以有规则，比如默克尔树。</p><p>至于其用途，在（比如说）一棵默克尔树无论如何都要用一个密钥来签名的时候，使用上述技巧在信任上是等价的。例如，可以这样构造出一棵存储了用户余额的树，任何用户都能从签名集合中 “查找” 自己的余额。</p><p>对于 “标准库” 的典型用法，大的联盟可以用于一次性的受信任启动仪式（one-time-trusted-setup）。</p><h2 id="SIGHASH-标签检测"><a href="#SIGHASH-标签检测" class="headerlink" title="SIGHASH 标签检测"></a>SIGHASH 标签检测</h2><p>当前，比特币的脚本无法约束一个公钥使用哪个 sighash 标签。CSFS 则可以在 Taproot 输出中带来一个有局限的版本。以下是实现方法：</p><p>使用 CSFS，你可以从一个签名中获得交易的摘要并将它存入堆栈。</p><p>没有 OP_CAT，其用法是有限的 ……</p><p>但是，我们有以下公式：</p><p>^ <code>SigMsg()</code> 的输出长度是多少？<code>SigMsg()</code> 的总长度可以使用这个公式计算出来：<code> 174 - is_anyonecanpay * 49 - is_none * 32 + has_annex * 32</code></p><p>（译者注：这里的 <code>is_anyonecanpay</code> 和 <code>is_none</code> 、<code>has_annex</code> 都是布尔值，表示签名是否使用了这些 sighash 标签。）</p><p>也就是，最多只有 206 字节（就是在设置了 <code>has_annex</code> 的时候）。</p><p><em>注意：这个数字最终还要加上 1 字节的 sighash epoch ，以及 64 字节的 taggedhash 的值。</em></p><p>这意味着，使用 CSFS，你可以通过使用 OP_SIZE 来约束一个签名使用特定的 sighash 标签。</p><ul><li>is_anyonecanpay&#x3D;0， is_none&#x3D;0， has_annex&#x3D;0，大小是 174+65</li><li>is_anyonecanpay&#x3D;0， is_none&#x3D;0， has_annex&#x3D;1，大小是 206+65</li><li>is_anyonecanpay&#x3D;0， is_none&#x3D;1， has_annex&#x3D;0，大小是 142+65</li><li>is_anyonecanpay&#x3D;0， is_none&#x3D;1， has_annex&#x3D;1，大小是 174+65</li><li>is_anyonecanpay&#x3D;1， is_none&#x3D;0， has_annex&#x3D;0，大小是 125+65</li><li>is_anyonecanpay&#x3D;1， is_none&#x3D;0， has_annex&#x3D;1，大小是 157+65</li><li>is_anyonecanpay&#x3D;1， is_none&#x3D;1， has_annex&#x3D;0，大小是 93+65</li><li>is_anyonecanpay&#x3D;1， is_none&#x3D;1， has_annex&#x3D;1，大小是 125+65</li></ul><p>也就是说，你可以用 CSFS 来区分使用 <code>anyonecanpay</code> 和 <code>none</code> 和 <code>annex</code> 的标签组合，除了 <code>is_none</code> 和 <code>has_annex</code> 都设置或者都没设置的情形（因为体积相同，所以无法区分）。</p><p>唉，再换句话说，你可能只能对以下组合动脑筋了：</p><ul><li>is_anyonecanpay&#x3D;0， is_none&#x3D;1， has_annex&#x3D;0，大小是 142+65</li><li>is_anyonecanpay&#x3D;1， is_none&#x3D;1， has_annex&#x3D;0，大小是 93+65</li></ul><p>至于以下组合，则只能没那么感兴趣，但依然可以感兴趣，因为 annex 还不是标准交易：</p><ul><li>is_anyonecanpay&#x3D;0， is_none&#x3D;0， has_annex&#x3D;1，大小是 206+65</li><li>is_anyonecanpay&#x3D;1， is_none&#x3D;0， has_annex&#x3D;1，大小是 157+65</li></ul><p>注：给定这些组合，依然可以设置其它标签！</p>]]></content>
    
    
    <summary type="html">CSFS 的有趣用法</summary>
    
    
    
    
    <category term="CSFS" scheme="https://www.btcstudy.org/tags/CSFS/"/>
    
  </entry>
  
  <entry>
    <title>如何审核给 Bitcoin Core 提交的 PR</title>
    <link href="https://www.btcstudy.org/2026/02/03/how-to-review-pull-requests-in-bitcoin-core/"/>
    <id>https://www.btcstudy.org/2026/02/03/how-to-review-pull-requests-in-bitcoin-core/</id>
    <published>2026-02-03T12:12:49.000Z</published>
    <updated>2026-02-28T07:32:23.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：jon atack</em></p><p><em>来源：<a href="https://jonatack.github.io/articles/how-to-review-pull-requests-in-bitcoin-core">https://jonatack.github.io/articles/how-to-review-pull-requests-in-bitcoin-core</a></em></p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>审核（reviewing）和测试（testing），可能是给 Bitcoin Core 贡献代码的最佳起步方式。</p><p>丰富的审核和测试常常被长期的 Bitcoin Core 开发者提及，因为：</p><ul><li>资源瓶颈，以及</li><li>它是学习、开始贡献代码和积累在社区中的剩余的最佳方式，也是最有效益的方式。</li></ul><h2 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h2><p>本指南建立在这些文献的基础上：</p><ol><li>《<a href="https://johnnewbery.com/contributing-to-bitcoin-core-a-personal-account/">向 Bitcoin Core 贡献：个人经验</a>》，来自 <a href="https://x.com/jfnewbery">John Newbery</a>（2017）</li><li>《<a href="https://medium.com/@pierre_rochard/understanding-the-technical-side-of-bitcoin-2c212dd65c09">理解比特币的技术一面</a>》，来自 <a href="https://x.com/BitcoinPierre">Pierre Rochard</a>（2018）</li><li>硬核研讨会 <a href="https://www.youtube.com/watch?v=MJBhZg0ytiw">视频</a> &#x2F; <a href="https://diyhpl.us/wiki/transcripts/sf-bitcoin-meetup/2018-04-23-jeremy-rubin-bitcoin-core/">转录稿</a> &#x2F; <a href="https://drive.google.com/file/d/149Ta1WRXL5WEvnBdlL-HxmsFDXUbvFDy/view">幻灯片</a>，来自 <a href="https://x.com/JeremyRubin">Jeremy Rubin</a>（2018）</li></ol><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><a href="https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review">ACK，NACK</a>：它们的定义和起源可以在 <a href="https://www.freecodecamp.org/news/what-do-cryptic-github-comments-mean-9c1912bcc0a4/">这里</a> 和 <a href="https://searchnetworking.techtarget.com/definition/ACK">这里</a> 找到。</p><p>Nit：一个微小的，通常不造成阻塞的问题。</p><p><a href="https://help.github.com/en/articles/about-pull-requests">PR</a>：“<em>代码拉取请求（pull request）</em>” 的缩写，有时候也被称为 “合并请求（merge request）”。它是对源代码库中的代码或说明书的一次变更提议。</p><p><a href="https://en.wikipedia.org/wiki/Work_in_process">WIP</a>：“<em>还在开发中（work in progress）</em>” 的缩写。</p><h2 id="通识"><a href="#通识" class="headerlink" title="通识"></a>通识</h2><p>作为一名新人，我们的目标是尝试增加价值，以友好和谦逊的态度，同时尽可能多学习。（虽然这些目标也不是只对新人有意义；或者说，这个过程不会有终点。）</p><p>一个好办法是，不把它当成一个由你主导的事，而是问自己： “如何最好地服务大家？”</p><p>新的贡献者面对的最难问题之一是代码库的广度以及围绕它的技术复杂性。</p><p>要意识到还有你不知道的事。长期开发者有多年的开发经验和专业背景。社区已经建立了知识和经验的深度的集体财富。请记住，你的新想法可能已经有人提过、考虑过好几次了。</p><p>请记住，贡献者和维护者的时间精力都是有限的 —— 在你请求帮助的时候，应该谨慎并且尊重。目标是给予多于索求、帮助多于妨碍，同时加快速度。</p><p>多多尝试自己搞明白，至少要充分尊重其他人的时间。</p><p>关注 <a href="https://kiwiirc.com/nextclient/irc.libera.chat">#bitcoin-core-dev</a> 即时聊天室以及 <a href="https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev">bitcoin-dev</a> 邮件列表。</p><p>更多值得关注的 IRC 频道<a href="https://github.com/jonatack/bitcoin-development/blob/master/irc-channels.txt">可在此处找到</a>。</p><p>在你开始之前，要先投入大量时间：</p><ul><li>理解贡献的流程和指引，不仅仅要阅读<a href="https://github.com/bitcoin/bitcoin">代码库</a>里的说明书（尤其是《<a href="https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md">贡献指南</a>》、《<a href="https://github.com/jonatack/bitcoin-development/blob/master/irc-channels.txt">开发者笔记</a>》和《<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/productivity.md">生产力笔记</a>》这几篇）（以及广义地说，<a href="https://github.com/bitcoin/bitcoin/tree/master/doc">文档</a> 和 <a href="https://github.com/bitcoin/bitcoin/tree/master/test">测试</a> <a href="https://github.com/bitcoin/bitcoin/tree/master/src/test">代码库</a> 中的一切），还要关注 <a href="https://kiwiirc.com/nextclient/irc.libera.chat">#bitcoin-core-dev</a> IRC 频道中的互动，以及<a href="https://github.com/bitcoin/bitcoin/pulls">代码库中正在进行的代码审核</a>。</li><li>了解定期贡献者：他们做些什么、喜欢什么、想要什么，以及他们如何接收反馈。</li></ul><p>许多新来者一上来就打开 PR ，但这只是在几百个正在等待有价值审核的 PR 中增加一个。从审核已有的 PR 、理解什么类型的 PR 和审核是更有帮助的、与此同时逐步理解全景，会好得多。</p><p>一个有用的经验法则是：每当你要创建一个 PR，就先审核 5 ~ 15 个 PR 。</p><h3 id="全景"><a href="#全景" class="headerlink" title="全景"></a>全景</h3><p>全景（big picture）比 nit、拼写和代码风格都要重要得多。</p><p>全景审核有几个不同层级：“这个变更会影响什么行为吗” 或者 “这个变更安全吗” 与 “这是个好想法吗” 是不一样的。回答后面这个问题需要更多背景，这也是你会逐渐了解的事。别因为它而停止思考这些问题、也别放弃在这个层面上审核。</p><p>提升你对全景的理解的步骤：</p><ul><li>完成 <a href="https://github.com/chaincodelabs/study-groups">Chaincode Labs 的学习指南</a></li><li>考虑申请和参加最受推荐的 <a href="https://learning.chaincode.com/">Chaincode Labs 在线课程</a>（这个项目实际上也为搜寻正在找比特币工作和开源奖金的新开发者服务）</li><li>学习<a href="https://github.com/bitcoin/bips/">比特币升级提议</a>（通常以单数和缩写形式的 “BIP” 指代），并经常回顾</li><li>订阅 <a href="https://bitcoinops.org/">Bitcoin Optech 周报</a>并使用他们的 <a href="https://bitcoinops.org/en/topics/">topics 页面</a>作为手边资源</li><li>完成 “<a href="https://github.com/ChristopherA/Learning-Bitcoin-from-the-Command-Line">从命令行学习比特币</a>”</li></ul><p>追求质量而非数量，并在深入的工作和快速出成果之间取得平衡。</p><p>撰写说明有重要意义，比如说，关于各部件如何工作及如何交互的概要说明、清晰且准确的代码文档、一个函数是否有号的说明和 <a href="https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#coding-style-doxygen-compatible-comments">Doxygen 文档</a>、测试日志（既包括 <code>info</code> 也包括 <code>debug</code>），等等。</p><p>  测试覆盖面也是重要的，别犹豫，去提升和编写任何缺失的<a href="https://github.com/bitcoin/bitcoin/blob/master/src/test/">单元测试</a>、<a href="https://github.com/bitcoin/bitcoin/tree/master/test/functional/">功能测试</a>以及<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/fuzzing.md">模糊测试</a>。</p><p>称为一个谦虚、友善的贡献者。通过审核、<a href="https://github.com/bitcoin/bitcoin/pull/15996#issuecomment-491740946">提出测试</a>以及有用的修复措施、提议变更代码初始状态（rebase）来帮助 PR 前进，甚至，可以考虑在 PR 沉寂几个月之后提出接管请求。总而言之，互帮互助！</p><h3 id="NIT"><a href="#NIT" class="headerlink" title="NIT"></a>NIT</h3><p>尝试避免过度纠结 PR 中的 nit、细枝末节和代码风格，尤其是那些还打着 “WIP” 标签的 PR；并且，在一个 PR 才刚刚创建、作者还在寻求概念上的 ACK（支持）和方法上的 ACK 的时候（比如还在寻求普遍共识的阶段），不要急着挑刺。</p><p>长期贡献者都报告说，这样的活动让他们反感；而且，这样做会消耗你在项目中的社会资本。尝试理解人们需要什么样的审核，以及什么时候需要审核。</p><p>评论任何 nit 的最佳时机，都是在 PR 已经获得足够多 概念&#x2F;方法 上的 ACK（也即得到共识）之后，在 PR 终结、获得 “已测试 ACK” 之前。如 Pieter Wuille <a href="http://www.erisian.com.au/bitcoin-core-dev/log-2020-05-17.html#l-307">在 IRC 中说的</a>：“我感觉，对一个 PR 来说，最挫败的事情就是得到了大量关于 细枝末节&#x2F;nit&#x2F;代码风格 的评论，而依然不知道这个 PR 作为一个概念是不是可取的。”</p><p>给出对 nit 和代码风格的建议时，应该友善、轻松、鼓励 —— 比如，“请自由忽略”、“如果你恰好改变代码，可以顺带调整”，等等。</p><p>请记住，没有人有义务将你的审核意见考虑在内；如果作者认为你的意见已经超出了变更的范围、因此回复称不想采纳，那没有任何问题（尤其是在你的评论都是在纠缠 nit 的时候）。</p><h3 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h3><p>在你能够做到的时候，提高你审核的 PR 的难度和优先级。</p><p>审核的质量比数量重要得多。你可以通过为<a href="https://github.com/orgs/bitcoin/projects/1/views/1">高优先级的 PR</a> 和更难的 PR 提供深入、高质量的审核来学习以及<a href="https://jonatack.github.io/articles/on-reviewing-and-helping-those-who-do-it">增添更多价值</a>。这些 PR 可能会吓倒人们，可能会停滞几个月，因为缺乏高质量的审核、遍布吹毛求疵的代码风格和 rebase 评论而让作者的激情消磨殆尽。好好审核它们是给比特币提供真正的服务。</p><p>提升的过程需要时间；没有什么能够替代投入在了解背景、关注 <a href="https://github.com/bitcoin/bitcoin">代码</a>、<a href="https://github.com/bitcoin/bitcoin/issues">问题报告</a>、<a href="https://github.com/bitcoin/bitcoin/pulls">PR</a>、<a href="https://kiwiirc.com/nextclient/irc.libera.chat">#bitcoin-core-dev</a> IRC 频道和 <a href="https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev">bitcoin-dev</a> 邮件组的经年累月时间。</p><p>在开始一次审核之前，一个有用的问题是：“在这个阶段，它最需要的东西是什么？” 回答这个问题需要经验和积累起来的背景知识，但它的有用之处在于，可以确定如何以最少时间添加最大价值。取决于变更的复杂性和致命性，以及这个 PR 在审核流程中已经走过的阶段，审核可能要略读代码、在关键位置的一个相关的代码评论中应用大量背景知识，而不是运行包含 debug 开发、测试和审核每一次提交的完整审核。不过，在绝大多数情况下，完成合适的全面审核都是最好的、能够增加最多价值。</p><h3 id="一步一个脚印"><a href="#一步一个脚印" class="headerlink" title="一步一个脚印"></a>一步一个脚印</h3><p>把自我评价和愿望排除在外。不要把事情变成个人意气，应该推动事物前进。</p><p>有所怀疑的时候，假设他人有良好的意愿。</p><p>对人们和结果保持耐心。</p><p>公开表扬；私下批评，并且应该带有鼓励。</p><p>持续帮助。每天都要努力。</p><p>所有事情都是说起来容易做起来难，宽恕你自己，也宽恕其他人。</p><p>请记住：每当你要创建 1 个 PR，就先审核 5 ~ 15 个 PR（或者 处理&#x2F;测试 5 ~ 15 个问题报告）。</p><p>最后，要从不同背景、不同经验层级的人了解你的贡献的价值，而不仅仅是你的同事或熟人。联系新朋友（直接通过 IRC 消息挺好的），问问他们需要什么帮助。你可以偶尔请求帮助，但不要把这当成一种权利。多给予，少索取。</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p><em>别相信，去验证（Don’t trust, verify）。</em> 尽可能减少你的审核流程对 GitHub 的以来。只为 GitHub 的元数据而使用 GitHub 网站，例如，阅读评论和添加你自己的评论 —— 审核提交和代码的工作应该在你本机环境中完成。</p><h3 id="为本机拉取代码"><a href="#为本机拉取代码" class="headerlink" title="为本机拉取代码"></a>为本机拉取代码</h3><p>因此，审核过程的起点是为你的电脑拉取 PR 分支，从而在本机编译和审核。相应于你的想法、需要、磁盘空间、互联网带宽，有不同的方法。以下仅举几例：</p><ol><li>使用 <code>git checkout pr/&lt;number&gt;</code> 来拉取远端的 PR， 就像<a href="https://gist.github.com/piscisaureus/3342247">这篇短小精悍的 gist</a> 说的那样，可以修改成适合你的需要。</li><li>我的 git 配置的 <code>[remote &quot;origin&quot;]</code> 部分：<code>fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</code> </li><li>Bitcoin Core 贡献者 Luke Dashjr 的版本：“为了避免所有的合并分支，将 origin-pull remote 配置成”：<code>fetch = +refs/pull/*/head:refs/remotes/origin-pull/*/head</code> </li><li>Bitcoin Core 的文档：<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/productivity.md#reference-prs-easily-with-refspecs">使用 refspecs 轻松引用 PR</a></li><li>使用 <code>pull/&lt;number&gt;/head</code>（贡献者分支）和 <code>pull/&lt;number&gt;/merge</code>（合并到 master 分支），  GitHub 会<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally">将 PR 暴露成</a>上游代码库的分支，例如，<code>git fetch origin pull/17283/head &amp;&amp; git checkout FETCH_HEAD</code> 。也就是说，我倾向于尽可能少依赖 GitHub。</li></ol><p>你可以在贡献者分支上测试一个 PR，也可以在合并了变更的 master 分支上测试它。测试后者，可以检查自上一次 PR 提交以来是否有什么合并到 master 分支的东西打破了变更，非常有用。</p><p>然后，你可以开始在本机编译和测试，同时开始阅读代码。你应该能够熟练地从<a href="https://jonatack.github.io/articles/how-to-compile-bitcoin-core-and-run-the-tests">源代码编译 Bitcoin Core</a>，然后运行<a href="https://github.com/bitcoin/bitcoin/tree/master/src/test/README.md">单元测试</a>和<a href="https://github.com/bitcoin/bitcoin/blob/master/test/README.md">功能测试</a>，因为你需要为许多 PR 做测试。因此，Bitcoin Core 的《<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/productivity.md">生产力笔记</a>》是无可替代的。</p><p>阅读和了解 Bitcoin Core 的《<a href="https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md">开发者笔记</a>》。</p><h3 id="对比工具"><a href="#对比工具" class="headerlink" title="对比工具"></a>对比工具</h3><p>在编译和测试还在运行中时，开始在你本机环境中审核每一次代码提交，使用 <a href="https://git-scm.com/docs/gitk">gitk</a>、<a href="https://meldmerge.org/">meld</a>、<a href="https://yousseb.github.io/meld/">meld                    for macOS</a>、<a href="https://www.gnu.org/software/emacs/manual/html_node/ediff/index.html">GNU</a> <a href="https://www.emacswiki.org/emacs/EdiffMode">ediff</a> for Emacs、<a href="https://vim.fandom.com/wiki/A_better_Vimdiff_Git_mergetool">vimdiff</a> 或 <a href="https://github.com/whiteinge/diffconflicts">vim-diffconflicts</a> for Vim、opendiff on macOS、<a href="https://diffoscope.org/">diffoscope</a> 这样可以高亮差异部分的对比工具（这里还有一份<a href="https://github.com/fanquake/core-review/blob/master/diffoscope.md">对比工具使用技巧</a>）。</p><p>如果你使用 gitk 并且喜欢黑暗模式，我建议使用 <a href="https://github.com/dracula/gitk">Dracula for gitk</a> 。</p><h3 id="Git-Grep"><a href="#Git-Grep" class="headerlink" title="Git Grep"></a>Git Grep</h3><p>熟练地使用 <code>git grep</code> 来搜索代码库。你会一直使用它，直到在代码库中找到你需要的材料。在命令行环境中运行 <code>git grep --help</code> 来获得帮助。</p><h3 id="如果你不确定从哪里开始"><a href="#如果你不确定从哪里开始" class="headerlink" title="如果你不确定从哪里开始"></a>如果你不确定从哪里开始</h3><p>阅读代码、阅读 PR 评论，然后回头重新阅读两者。找出不理解的地方，然后搞清楚。如是不断重复。</p><p>一旦所有一切都开始明朗，那就在 regtest&#x2F;testnet 上运行 <code>bitcoind</code> （或者在主网上运行，只投入很少的钱），然后追踪和搜索相关的日志（运行 <code>bitcoin-cli help logging</code> 来获得不同的 <code>bitcoind</code> 日志类别以及如何 打开&#x2F;关闭 它们）。</p><p> 也许你可以添加一些自定义的日志逻辑，<code>LogPrintf</code> 或者 <code>assert</code>； 将它们添加到别人的代码中是一种特权（想了解为什么，请在代码库中运行 <code>git grep -ni logprintf</code> 或 <code>git grep asset</code>）。</p><p>运行相关的功能测试，查看 debug 日志。验证它们在 master 分支上的出错方式 符合预期。然后回到 PR 分支，逆转或改变新的测试，让它们失败，并理解其中的原因。</p><p>也许 C++ 的 <a href="https://www.gnu.org/software/gdb/documentation/">gdb</a> 或 Python 的 <a href="https://docs.python.org/3/library/pdb.html">pdb</a> （或者在任何功能测试代码中加入 <code>import pdb:pdb.set_trace()</code> ）可以获得断点视图。求值。运行 RPC 命令。</p><p>检查该 PR 是否忽略了任何调用站点、头文件或声明。</p><p>尝试重构代码到更好状态，并探索为什么这样行不通。做好实际花费时间是预计时间两倍长的准备。没错，这就是工作。</p><p>也许可以运行 strace（<code>man page strace</code>）来跟踪系统调用和信号。</p><p>取决于变更的内容，贡献基准测试、内存分析&#x2F;valgrind 或火焰图（flame graphs）到 PR 审核中，有时候会很有帮助，甚至是决定性的。</p><h3 id="技术资源"><a href="#技术资源" class="headerlink" title="技术资源"></a>技术资源</h3><p>我为自己整理了一份包含多种技术笔记的文档，我在开发 Bitcoin Core 时经常引用它们，放在这里：<a href="https://github.com/jonatack/bitcoin-development/blob/master/notes.txt">jonatack&#x2F;bitcoin-development&#x2F;notes.txt</a> 。这些笔记所在的代码库中还有有用的资料。另一个很好的资源库是 <a href="https://github.com/fanquake/core-review">fanquake&#x2F;core-review</a> 。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>两个很好的 gist，讲解了调试 Bitcoin Core ：</p><ul><li>《<a href="https://github.com/fjahr/debugging_bitcoin">调试 Bitcoin Core</a>》，来自 <a href="https://x.com/fjahr">Fabian Jahr</a></li><li>《<a href="https://gist.github.com/gubatron/36784ee38e45cb4bf4c7a82ecc87b6a8">使用 GDB 或 LLDB 深入和调试 Bitcoin Core</a>》，来自 <a href="https://www.gubatron.com/blog/">Angel Leon</a></li></ul><h3 id="添加缺失的测试"><a href="#添加缺失的测试" class="headerlink" title="添加缺失的测试"></a>添加缺失的测试</h3><p>虽然你是在审核，但自己编写测试可以帮助你理解代码的动作并验证变更的内容。而且，如果它们添加了有用的覆盖面，你可以向作者提议在 PR 中加入这些测试。提议自动化测试是开始贡献的非常有用的方式。有人审核代码并提供额外的测试，作者会很感激的。<a href="https://github.com/bitcoin/bitcoin/pull/15996#issuecomment-491740946">这里就有一个例子</a>。</p><h3 id="从全景到-nit"><a href="#从全景到-nit" class="headerlink" title="从全景到 nit"></a>从全景到 nit</h3><p>请记住，全景比 nit、拼写和代码风格都重要得多。请重新阅读上文的 “NIT” 一节。在审核中，应尝试避免评论这些东西，即使你没有别的东西要评论。我知道，这很难 —— 我也很多次管不住自己 —— 但有一些更好的替代：</p><h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p>作为一个审核员，（无需对代码的专门知识）你可以做的一个好事情是 <em>提出问题</em> 。PR 的作者通常乐于讨论自己的工作以及看到对它的兴趣。所以，花上 20 多分钟，看看变更的内容、找出看起来最令人困惑或者意外的地方，然后在 PR 评论中（或者 <a href="https://kiwiirc.com/nextclient/irc.libera.chat">#bitcoin-core-dev</a> 频道中）礼貌地问问这些问题。可能其他人也对同样的问题感到亦或，然后它可以得到更好的澄清和记录。这样一来，你既可以学到知识，又能帮助这个项目变得更加易于理解（本段要归功于 <a href="https://github.com/bitcoin/bitcoin/pull/15934#issuecomment-547095024">Russ Yanofsky</a>）。</p><h3 id="同侪审核"><a href="#同侪审核" class="headerlink" title="同侪审核"></a>同侪审核</h3><p>确保你学习并理解了 Bitcoin Core 的<a href="https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review">同侪审核流程</a>。这个流程 <a href="https://github.com/bitcoin/bitcoin/pull/15626">经常</a> <a href="https://github.com/bitcoin/bitcoin/pull/16149">更新</a>，所以要经常回顾。</p><p>“<a href="https://www.freecodecamp.org/news/what-do-cryptic-github-comments-mean-9c1912bcc0a4/">ACK</a>”（<a href="https://searchnetworking.techtarget.com/definition/ACK">起源</a>）一般用在审核员对自己如何审核以及手动测试的描述之后。作为一个新的贡献者，建议在审核评论中更加详细地提供关于你做了什么、想了什么的详细描述，以证明你理解了这项变更。</p><p>“Concept ACK（概念 ACK）” 意味着审核人认可并同意这项变更的目标，但（尚且）没有承认自己看了代码、测试了代码。这对 PR 作者来说也可能是一个有价值的信号，让他们知道这个 PR 是有价值的，并且是往正确的方向前进。相对应的，“概念 NACK” 则表示不同意这个 PR 的目标。</p><p>“Approach ACK（方法 ACK）” 则比概念 ACK 更进一步，意味着既同意 PR 的目标，又同意这个 PR 用来实现这一变更的方法。“方法 NACK”则表示同意目标，但不同意实现的方法。</p><p>审核人有时候会评论 “代码审核 ACK” 来表示代码看起来不错，但他们还没测试变更的内容，或者对概念还没有形成观点。添加更多的背景会更好：“代码审核 ACK <code>HEAD</code>，还不清楚概念的用意，我将验证 x、y、z ”等等。</p><p>还有其它 ACK 变体：“tACK” 或者 “tested ACK”，表示已经测试；而 “utACK” 或者 “untested ACK” 表示尚未测试。</p><p>手动测试新特性，或者报告问题，都是受到欢迎的。审核评论中出现了这样的字眼：“以下是我的测试内容和测试方法”，那是非常有帮助的，尤其是末尾还有一个 “ACK” 的话。</p><p>一些 PR 可能难以测试，或难以 ACK，因为它的复杂性、背景或缺乏测试和模拟的框架。比如说，如果你透彻审核了代码，留下 “我看起来代码是正确的，但对于它的动作，我无法自信到给出一个 ACK” 这样的评论，那也是非常有用的贡献。</p><p>还有其它有用的评论，比如， 对于包含了 move-only 的评论，“验证了 move-only 部分” 就是有用的；还有 “苦苦思索改变 X 有没有可能打破 Y，但没有想出任何结果（这种情况真的会发生吗？）”，等等。</p><h3 id="带有提交哈希值的-ACK"><a href="#带有提交哈希值的-ACK" class="headerlink" title="带有提交哈希值的 ACK"></a>带有提交哈希值的 ACK</h3><p>给出一个 ACK 的时候，通过附加 <code>HEAD</code> 提交（或者你审核的那一个提交）的哈希值来指明你审核的代码状态。免信任的、正确的方式是使用来自你的 <em>本机</em> 分支的哈希值，而不是来自 GitHub 网页的哈希值。这样一来，除非你的本机工具被攻破了，否则你可以保证，你是在 ACK 具体的一些变更。在强制推送（force push）发生、链接到的旧提交在 GitHub 上已经丢失时，这样做也是有用的。</p><p>一个完整的 ACK 应该是这样的：“ACK <code>fa2f991</code> ，我编译了、运行了测试，通过运行 X&#x2F;Y&#x2F;Z 手动进行了测试，并且审核了代码，它看起来不错，我同意它可以合并。”</p><p>当前的 Bitcoin Core 合并脚本会将（在合并的时刻）与 <code>HEAD</code> 提交相关的每一条 ACK 意见的第一段都复制到合并代码的提交中。所以，请记住，你在其中写下的任何东西都会被合并脚本复制，成为 git 历史上永远的一部分。</p><p>一个复杂或者更加高风险的 PR，可能需要至少 3 ~ 4 个有经验的 ACK ，才能合并。</p><h3 id="APACHE-投票系统"><a href="#APACHE-投票系统" class="headerlink" title="APACHE 投票系统"></a>APACHE 投票系统</h3><p>Bitcoin Core 的审核人们经常在评论中使用 <a href="https://www.apache.org/foundation/voting.html#expressing-votes-1-0-1-and-fractions">Apache 投票系统</a>。这里就是一个<a href="https://github.com/bitcoin/bitcoin/pull/11426#issuecomment-334091207">例子</a>。</p><h3 id="对人宽容一点"><a href="#对人宽容一点" class="headerlink" title="对人宽容一点"></a>对人宽容一点</h3><p>审核代码，而不是审核贡献者本身和他们的评论。</p><p>当你不能同意的时候，一次性说明你的观点，然后推进。<a href="https://github.com/bitcoin/bitcoin/pull/22245#issuecomment-862044403">这里就是一个例子</a>。不要用多次发言冲垮评论去，也别恐吓他人或过度反应。要有耐心，不要过激或霸凌他人。请记住，最重要的东西可能不是讨论中的问题，而是你跟其他贡献者的关系。</p><p>作为一个新贡献者，在给出 NACK 时要慎重。要默认假设是你对背景缺乏理解。如果你要给出 NACK，请提供好的推理。<a href="https://github.com/bitcoin/bitcoin/pull/12360#issuecomment-383342462">这里就是一个例子</a>。</p><h3 id="使用-OpenTimeStamp-签名提交"><a href="#使用-OpenTimeStamp-签名提交" class="headerlink" title="使用 OpenTimeStamp 签名提交"></a>使用 OpenTimeStamp 签名提交</h3><p>一些比特币贡献者会为 ACK 签名并附加 OpenTimeStamp（Open 时间戳）。虽然这超出了本文的范围，但使用 <a href="https://github.com/opentimestamps/opentimestamps-client/blob/master/doc/git-integration.md">OpenTimeStamp 的 Git 插件</a>来签名你的提交是非常简单的。</p><h3 id="可折叠的评论"><a href="#可折叠的评论" class="headerlink" title="可折叠的评论"></a>可折叠的评论</h3><p>一段时间以后，你会注意到，贡献者们有时候会使用<a href="https://github.com/bitcoin/bitcoin/pull/15600#issuecomment-604144041">可折叠的评论</a>来审核。<em>太酷了</em>，你会想，<em>这是怎么做到的</em> ？它用的是 HTML 的 <code>details</code> 标签。<a href="https://gist.github.com/joyrexus/16041f2426450e73f5df9391f7f7ae5f">这里有用法说明</a>。 </p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢 <a href="https://x.com/moneyball">Steve Lee</a>（moneyball）和 <a href="https://x.com/michaelfolkson">Michael Folkson</a> 审核本文并提出他们的建议。</p><p>通过关注值得致谢的 Bitcoin Core 开发者，本文包含了在 GitHub 和 IRC 上观察到的评论：Wladimir van der Laan、Marco Falke、Pieter Wuille、Gregory Maxwell、Anthony Towns 和 Russ Yanofsky 。</p><p>多年以来，我因为 BDFL（终身仁慈独裁者）在编程语言和开源项目中的影响力而失望。Wladimir van der Laan 为比特币贡献的 <a href="https://x.com/orionwl/status/1131564038444453889">长期</a> <a href="https://x.com/orionwl/status/1131827793908645888">谦逊</a> 的<a href="https://x.com/orionwl/status/1131924832071880705">服务</a>，点燃了我再次投身开源项目的可能性。</p><p>最后，衷心感谢各位 Bitcoin Core 贡献者对我的审核的耐心，主要有 John Newbery、Marco Falke、João Barbosa、practicalswift、Gregory Sanders、Jonas Schnelli、Pieter Wuille 和 Wladimir van der Laan 。还要感谢 Adam Jonas 和 John Newbery 在一开始的指引和建议。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">审核和测试，可能是给 Bitcoin Core 贡献代码的最佳起步方式</summary>
    
    
    
    
    <category term="贡献" scheme="https://www.btcstudy.org/tags/%E8%B4%A1%E7%8C%AE/"/>
    
  </entry>
  
  <entry>
    <title>Taproot 量子安全花费路径</title>
    <link href="https://www.btcstudy.org/2026/02/02/taproot-quantum-spend-paths/"/>
    <id>https://www.btcstudy.org/2026/02/02/taproot-quantum-spend-paths/</id>
    <published>2026-02-02T09:52:59.000Z</published>
    <updated>2026-02-28T07:32:23.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：BitMEX Research</em></p><p><em>来源：<a href="https://www.bitmex.com/blog/Taproot%20Quantum%20Spend%20Paths?category=Research">https://www.bitmex.com/blog/Taproot%20Quantum%20Spend%20Paths?category=Research</a></em></p></blockquote><p><strong>摘要</strong>：本文要讨论让比特币获得量子计算韧性的话题，重点是 Taproot 。在将比特币升级到量子安全的道路上，Taproot 实际上是一个非常有用的工具。我们将提倡 Taproot 的一个新的、量子安全的版本，以及相应的一种模式：钱包有能力通过一个量子安全的脚本树叶子或一个量子脆弱的脚本树叶子来花费同一笔资金。这样一来，用户可以一直使用量子脆弱的方法来花费比特币、从更小的签名获益；而在临近 “Qday”（量子计算机能够分解椭圆曲线点）时，再换用量子安全的花费方式。给定 Qday 具体日期的不确定性，以及任何冻结钱币的提议所需的长期安全性，这种特性可能不仅是有用的，甚至是必要的。</p><p><img src="/../images/taproot-quantum-spend-paths/qd.png" alt="qd"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文是我们在 2025 年 7 月发布的关于<a href="https://www.bitmex.com/blog/quantum-safe-lamport-signatures">量子安全签名</a>的文章（<a href="https://www.btcstudy.org/2025/08/25/quantum-safe-lamport-signatures/">中文译本</a>）的续篇。在本文中，我们将讨论一种新的量子安全的花费方法，如何能够跟 Taproot 形成绝妙搭配。再次强调，我们并非量子计算机的专家，并且据我们所知，量子计算机已经分解的最大数字是 15 ！不过，我们认为，让比特币更具量子攻击韧性，是一个实在的目标，也是值得我们努力和思考的东西。</p><p>一些人批评说，在重要问题（比如让比特币对量子计算机变得更加安全）上，近年来的比特币的开发者们要么做的不够多，要么不够专注。开发者们也曾被指责在没有意义的升级（比如 Taproot）上分心。然而，本文尝试解释的正是，在将比特币升级到量子安全这件事情上，Taproot 升级是非常有用的。</p><h2 id="密钥花费路径与-BIP-360"><a href="#密钥花费路径与-BIP-360" class="headerlink" title="密钥花费路径与 BIP-360"></a>密钥花费路径与 BIP-360</h2><p>当然，Taproot 输出今天已经存在了，并且与传统的输出类型 —— P2PKH、P2SH、P2WPKH 和 P2WSH  —— 相比，在量子计算机面前更加脆弱，因为这些传统的输出类型都隐藏了公钥，直到资金被花费时才会揭晓。因此，从量子安全的角度，Taproot 升级将比特币带回了 2010 年代，也就是 P2PK 输出类型还流行的时候。P2PK 与 Taproot 一样，会在收到资金时将公钥暴露在区块链上。</p><p>然而，这个弱点，只需要一个非常简单的软分叉升级就能补上。可以创造一种新的 Taproot 版本，一种量子安全的 Taproot 类型，完全移除密钥路径花费方法，只留下脚本路径花费方法。这就是 <a href="https://bip360.org/">BIP-360</a> ，也是我们赞同的提议。这一升级，将让 Taproot 提升到与 P2PKH、P2SH、P2WPKH 和 P2WSH 同一水平（从量子安全角度看）。剩余的量子计算风险在于，资金可能在交易广播到网络之后、被区块确认之前，被量子计算机窃取。</p><h2 id="Taproot-与量子安全升级的天作之合"><a href="#Taproot-与量子安全升级的天作之合" class="headerlink" title="Taproot 与量子安全升级的天作之合"></a>Taproot 与量子安全升级的天作之合</h2><p>从量子韧性的角度看，下一步就是要通过另一项软分叉、添加一种量子安全的 taproot 花费方法，可能是通过 <a href="https://groups.google.com/g/bitcoindev/c/Zx_NMqZH65Y/">OP_CAT</a>，又或者是添加一种基于哈希函数的量子安全签名方案（这样更加直接）。 然后，这种量子安全的赎回方案可以在新的 Taproot 类型中作为一个叶子脚本而启用。</p><p>这就是 Taproot 具有巨大优势的地方了。有了这两项升级 —— 禁用密钥花费路径、添加一种量子安全的 tapleaf 花费系统 —— 就可以创造出给予用户量子安全花费选项的地址。比如说，一个比特币地址可以带有两个 taproot 脚本树叶子，一个是量子安全的，另一个是量子脆弱的。这种地址让用户可以升级自己的钱包，确保自己的比特币在量子计算机面前是安全的，但依然保留使用体积更小的量子脆弱签名的能力，直至最后一刻。说得直白一些，这意味着用户收款 时还是只提供一个地址，但要花费时，却既可以选择用量子安全的花费方法，也可以选择用量子脆弱的花费方法。</p><p>当然，一个地址具有多种花费方法，这在 Taproot 以前就有了，比如使用 P2SH 就能做到。然而，如果使用 P2SH，用户要将完整的赎回脚本发布出来；而使用 Taproot，未使用的花费方法会被量子安全的哈希函数隐藏起来。</p><p>多种花费方法的比特币地址也可以在钱包软件的图形用户界面中显示出来。比如，<a href="https://lianawallet.com/">Liana 钱包</a>已经支持在多种定制化的脚本花费路径中选择一个来花费比特币。因此，上述的量子安全钱包也可以采取同样的逻辑：一个是 “量子安全花费” 按钮，另一个是 “量子脆弱花费” 按钮。</p><p><img src="/../images/taproot-quantum-spend-paths/liana.png" alt="liana"></p><p style="text-align:center">- 译者注：在 Liana 钱包的界面中，不同的花费方法靠不同的按钮来选择：常规的花费方法是 “Send（发送）” 按钮，紧急花费方法是 “Recovery（复原）” 按钮 -</p><p>让用户升级到量子安全的钱包有一个关键问题，就是（量子安全的花费方法）高得多的手续费。而有了我们这里的解决方案，这个问题就被大大缓解了，因为用户既升级到了一种量子安全的钱包，又不会立即面临手续费飙升。只有在 “Qday” 之后，用户才会需要使用体积更大的量子安全签名方案。给定量子计算机发展的速度是非常不确定的，这种选择能力，在我们看来是非常有价值的。</p><h2 id="关于冻结钱币的讨论"><a href="#关于冻结钱币的讨论" class="headerlink" title="关于冻结钱币的讨论"></a>关于冻结钱币的讨论</h2><p>在<a href="https://serve.podhome.fm/episodepage/CitadelDispatch/cd188-corallo--stealing-satoshis-satoshis">最近一期</a>的 Citadel Dispatch 播客中，Matt Odell 和 Matt Corallo 讨论了在哪种情况下，为了应对来自量子计算机的潜在风险，应该实施钱币冻结软分叉。Odell 基本上反对钱包冻结，而 Corallo 则一定程度上支持，在某些情况下可以冻结钱币。一些人不欢迎冻结钱币的想法。常见的意见是将冻结与盗窃相提并论。类比可能是将冻结量子脆弱的钱币与冻结属于朝鲜的钱币（或是犯罪分子的钱币）相比，这是显然几乎所有人都会反对的事。我们不同意将冻结量子脆弱的钱币与冻结朝鲜的钱币相比，但这是另外一个话题，我们想说的仅仅是，这些论点正在吸引一些关注。因此，从我们的角度看，是不是真的会冻结钱币，有相当大的不确定性。即使真的会发生冻结，计算出冻结的时机也是非常复杂的。</p><p><strong>冻结时机表</strong></p><table><thead><tr><th>因子</th><th>解释</th><th>对时机的影响</th></tr></thead><tbody><tr><td>一些人会反对冻结</td><td>冻结可能是有争议的，因此，钱币冻结软分叉可能只能获得少量共识，即使我们已临近 Qday</td><td>推迟冻结时间</td></tr><tr><td>避免人们因为来不及迁移而丢失钱币</td><td>我们可能需要在冻结软分叉激活与实际冻结之间设置足够长的时延，以留出人们转移钱币的时间。人们可能会在很难访问的冷存储中保管密钥，也可能没有听到与量子计算机有关的新闻，甚至，他们的钱包有时间锁</td><td>推迟冻结时间</td></tr><tr><td>避免冻结在 Qday 之后激活因此部分钱币依然因为量子计算攻击而丢失</td><td>如果冻结日期太晚，价值几百万的钱币可能被盗。因此，也许在预期的 Qday 和冻结激活日期之间，我们需要足够大的安全余量</td><td>让冻结提早</td></tr></tbody></table><p>除了有相反方向的考虑、让时间压力来回摇摆之外，我们可能还不仅仅要得出一个日期。可能要考虑四个日期，如下图所示。</p><p><strong>钱币冻结时机图示</strong></p><p><img src="/../images/taproot-quantum-spend-paths/time.png" alt="time"></p><p>给定 Qday 会不会到来、何时到来的不确定性，以及让钱币冻结能够有实际意义所需要的长时间周期，同时，也为了尽可能尊重比特币的抗审查属性，最终钱币冻结过早或太晚到来的风险相当大。也许早了好几年，又也许 Qday 之后好几年才冻结。</p><p>前述量子安全与量子脆弱花费方法并存的 Taproot 输出的一个绝妙之处在于，这种新的量子安全的  Taproot 输出永远不会被冻结。至少，我们将反对与这种量子安全的  Taproot 输出有关的冻结方案，甚至连禁用它的量子脆弱路径都反对，直至 Qday 真的到来。其中的道理在于，这是一种为量子安全而设计的新的输出类型，因此，迁移到这种输出的用户显然已经为量子计算机做好了准备。</p><p>因此，人们可以继续使用量子脆弱的签名来花费自己的钱币，直至 Qday 到来。使用这一方法，安全缓冲期会不会太长（过早冻结）（比如因为量子计算机的发展出人意料地停滞了数十年）也就没那么要紧了，因为人们会继续使用高效的量子脆弱的脚本树叶子来花费比特币。一旦 Qday 到来，最终的转变又是相对简单的，因为人们只需要被钱币软件提醒使用量子安全的花费路径。在 Qday 之后，钱包软件也可以升级，将量子脆弱的花费选项从图形使用界面移除。最终，可以有一次后 Qday 软分叉，禁止使用量子安全的 Taproot 输出类型下的量子脆弱的花费路径。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">在将比特币升级到量子安全的道路上，Taproot 实际上是一个非常有用的工具</summary>
    
    
    
    
    <category term="量子安全" scheme="https://www.btcstudy.org/tags/%E9%87%8F%E5%AD%90%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>电子现金与隐私性</title>
    <link href="https://www.btcstudy.org/2026/02/02/digital-cash-and-privacy-by-hal-finney/"/>
    <id>https://www.btcstudy.org/2026/02/02/digital-cash-and-privacy-by-hal-finney/</id>
    <published>2026-02-02T07:09:31.000Z</published>
    <updated>2026-02-28T07:32:23.226Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Hal Finney</em></p><p><em>来源：<a href="https://nakamotoinstitute.org/library/digital-cash-and-privacy/">https://nakamotoinstitute.org/library/digital-cash-and-privacy/</a></em></p><p>原文出版于 1993 年 8 月。</p></blockquote><p>我同意 “Anonymous” 的看法，在眼下，实际使用电子货币会遇上问题。但在一定程度上，这也要看你想解决什么问题。</p><p>关于迁移到电子支付，我的一个顾虑是，它会让个人隐私性降级，因为它让记录交易变得更加容易。有人可以建立答案来追踪我们每一个人的消费模式。</p><p>现在已经是这样了，当我通过手机或电脑来下单商品，然后用的 Visa 卡来支付的时候，会有一条清楚的记录，关于我花了多少钱、在哪花了钱。随着时间推移，越来越多交易会被这样记录下来，最终结果可能是隐私大泄露。</p><p>通过邮件来支付现金确实可以做到，但既不安全，也不便利。我认为，信用卡和借记卡的便利性，将会盖过绝大多数人的隐私性顾虑，然后我们就会身处这样一个世界：关于人们的私人生活，形成了大量的信息。</p><p>这就是我看到电子现金可以有作用的地方。想象一种类似于 Visa 的系统，在其中我对银行是匿名的。在这个模式中，银行会给我授予信用，就像信用卡一样。但是，它不是给我一个账户号码、让我可以通过手机知道、在电子邮件里附上，它给我的是按需请求电子现金的权利。</p><p>我保留一些电子现金，然后用在一些交易中。当我现金不够的时候，就发邮件给银行，以得到一些。每个月，我都发送一张支票给银行，以覆盖我的账户的支出，就像信用卡的体验一样。我跟这个银行的关系，与我今天跟信用卡公司的关系非常相似：频繁取款、每个月清账一次。</p><p>但相比于今天我们采用的系统，这样的电子现金系统有几个优点。它不会留下我在哪里花了我的钱的记录。银行只知道我每个月取了多少钱；但我可能马上就花掉，也可以留着不花，而他们不会知道。对于一些交易（例如软件），我对供应商可以是匿名的；至于另一些交易，供应商可能会知道我的家庭地址，但依然没有哪个中心能够记录我买的所有东西。</p><p>（它也有安全性上的优势。在今天采用的荒谬的系统中，只要知道你的 16 位账户号码，还有一个过期日期，任何人都能用你的名义来买任何东西！）</p><p>而且，我认为，没有什么让这样的系统不能跟信用卡一样合法化。唯一有区别的地方就是它不能跟踪用户在哪里花了自己的钱；就我所知，这项能力在信用卡中从来没有重要的法律意义。当然，今天没有人会否认，政府在促成每一笔金融交易都能得到跟踪的环境上有既得利益。</p><p>当然，这样的电子现金不能提供完全的匿名性。依然有可能大致知道每个人花了多少钱（虽然不可能阻止用户取出比月度开销多得多的现金，而只能用利息来吸引他们不要这样做；但也许，这人还可以出借多余的电子现金，从而在别的地方收获利息）。并且，它也根源于 “Anonymous” 所批评的 客户&#x2F;供应商 模式。但我认为，这种模式代表了电子交易的主体，不论是在今天，还是在不远的将来。</p><p>同样值得指出的是，成为一家能够接受信用卡支付的商家，并不是一件容易的事。几年前我所在的一家公司就走了一遍这个流程。我们通过邮件订单来销售软件，这让信用卡公司非常紧张。那时候有许多电话诈骗：用几个月时间来收集大量的信用卡号，然后突然要求大大量支付。等到用户收到自己的月度账单、发出抱怨的时候，供应商已经消失了。为了获得信用卡终端，我们拜访了一家声称可以 “帮助” 我们起步的公司。他们看起来就像是那种见不得光的企业。我们不得不虚报用途，说我们有 50% 的产品都是在展会时候卖出的，这些显然会被当作是场外销售。而且我们不得不先预付 3000 美元（似乎是用作贿赂）。哪怕是这样，要是我们在商业区没有办公室的话，可能还办不下来。</p><p>在电子现金系统中，这可能就不是什么问题了。电子现金的主要问题是重复花费，而只要你愿意联网验证（对于任何需要几个小时来发货的企业来说，这都是合理的），就能完全防止重复花费。所以，商家就没有机会先收集信用卡号码、再搞欺诈了。（可能依然会有商家拒不发货的问题，所以，并非所有风险都被消除了）。这可能最终会让电子现金比现在的信用卡得到更广泛的采用。</p><p>我不知道这样的系统会不会被用来支持非法交易、逃税、赌博，等等。那都不是本提议的目的。它提供了提升个人隐私性和安全性的好处，以一个也许能够合法化的框架，这就够了。</p>]]></content>
    
    
    <summary type="html">想象一种类似于 Visa 的系统，在其中我对银行是匿名的</summary>
    
    
    
    
    <category term="Hal-Finney" scheme="https://www.btcstudy.org/tags/Hal-Finney/"/>
    
  </entry>
  
  <entry>
    <title>崩溃与超级通货膨胀</title>
    <link href="https://www.btcstudy.org/2026/01/30/crashes-and-hyperinflation/"/>
    <id>https://www.btcstudy.org/2026/01/30/crashes-and-hyperinflation/</id>
    <published>2026-01-30T07:16:55.000Z</published>
    <updated>2026-02-28T07:32:23.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Daniel Krawise</em></p><p><em>来源：<a href="https://nakamotoinstitute.org/mempool/crashes-and-hyperinflation/">https://nakamotoinstitute.org/mempool/crashes-and-hyperinflation/</a></em></p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>梅纳德·凯恩斯（John Maynard Keynes）有一句名言：“市场保持不理性的时间，可以比你的一辈子还要长”。但反过来说也是成立的：市场可以突然变得理性，比你预期的短得多。当人们开始将不理性当作常态，那么理性的突然一击就会让他们措手不及。崩溃和超级通货膨胀（hyperinflation），就可以视作一个社会在其非理性中逐渐变得洋洋自得的下场。当人们在特定的企业上投入过多、不剩什么能够纠正错误时，崩溃就会到来。当人们开始接受较低水平的通货膨胀、把它当成理所当然时，超级通货膨胀就在路上了。</p><p>对这些现象的理解，将关系到理解人们何时倾向于持有现金、何时喜欢购买投资品；以及这些决定对经济体的影响；货币供给量的膨胀如何影响这些决定的激励因素。这就是本文的主题，以下是我对即将讨论的概念的定义。</p><p><em>货币</em>：货币是一个抽象的概念，用来指称最容易流动的商品（而不管它到底是什么）。拥有货币的好处，从投资者的角度看，在于它是最容易在市场上出手的商品 —— 这正是 “具有最强流动性” 的含义。这也意味着，如果有什么特别好的东西待售，那么手上持有现金的人会最先获得它。</p><p><em>现金</em>：不同时代有不同的东西成为货币。因为我想要讨论一种商品失去其货币地位的过程，所以我使用 “<em>现金</em> ” 来指称 <em>当前是货币</em> 的那种商品 —— 但它将来可能不再是货币。这样的事情发生的时候，货币地位将转移到一些别的商品上，而现金会成为没有价值的纸，或者是计算机上的没有价值的数字。<em>货币</em> 是一个抽象的概念，但 <em>现金</em> 是一种具体的商品。</p><p><em>储蓄</em>：投资者的投资组合中的现金部分。</p><p><em>投资品</em>：现金之外的商品，购买它的理由是预期它在未来会带来好处，而不是为了立即消费它。这可能是因为它提供收入，比如债券或带有股息的股票，也可能是因为你预期它的价格最终会上升。我并不区分不同类型的投资品，因为它们之间的区别对于我要讨论的问题并不重要。即使我使用一家公司的股票作为例子，我也可以很容易把它换成债券，或是商品期货、球星卡，等等。当我说 “股票市场” 的时候，我指的是所有投资品的视频，而不是狭义的股票市场。</p><p>本文只想对比现金与其它投资品并解释为什么某些人喜欢一种胜过另一种，这也是为什么本文不把现金当成一种投资品。然而，在一定意义上，现金也可以视为一种投资品 —— 一些人买它，是因为预期它在未来会变得更 “值钱”。如果他预期股票市场会崩盘，那么他也可能会先换成现金、期待在崩盘之后自己能以更便宜的价格再次买入股票。也有人会只持有现金、不持有投资品，因为现金具有即期的好处（present benefit，通常译为 “现值”），就是它的流动性。在下文中会有更详细的讨论。</p><p><em>通货膨胀</em>：在本文中，通货膨胀指的是货币供给量的增加，而不是价格的上升。这样定义的理由是，如果一名投资人知道货币供给量在增加，那么他会预期手上的现金会变得更没有价值（相对于如果供给量不增加的情形）。即使当前还没有明显的价格上升，他也会这样想。通常来说，投资者会学着对导致价格变化预期的原因作出反应，因为如果等待价格实际发生变化才作出反应，就已经错过机会了。</p><p>本文呈现的是一种理想化的经济体 —— 在其中，什么是货币、什么不是货币，有客观的答案；同时，货币是由发行者以一种极度简单的方式来管理的，那就是发行更多货币。现实中的经济体要复杂得多，但我的主张是，理解真实世界的方法，正是揭开其面纱、找出其中的理想化模式（此处不作辩护）。我并不认为，真实世界中的国家通货的运行模式，与我这里说的有什么本质的不同。</p><p>前段时间我还写过一篇讨论货币量增长的文章，《<a href="https://nakamotoinstitute.org/mempool/its-not-about-the-technology-its-about-the-money">无关科技、只关货币</a>》。本文可以认为是那篇文章的续篇，但也可以独立阅读。那篇文章主要讲的是货币的采用及其价值之间的正反馈，就是说，越多人使用一种商品作为货币，它作为货币就越是有用，结果是变得更容易流动。本文讲的是，货币在成熟之后，如何与经济体的其余部分互动；以及，为什么发行者的错误管理可能导致它失败。</p><h2 id="货币的价值"><a href="#货币的价值" class="headerlink" title="货币的价值"></a>货币的价值</h2><p>关于比特币，最开始让很多人感到困惑的事情是：它怎么可能变得有价值呢？它不过是计算机上的一串数字而已啊！我并不是说，当时认为比特币没有价值的人是笨蛋；实际上，他们唯一迟钝的地方在于，没有向 <em>所有</em> 形式的货币都提出同样的问题。那个时候，人们已经在为计算机上的数字付出真实的美元了（《魔兽世界》游戏里的金币、《Farmville》游戏里的升级），并且，那时候的 “真实的美元”，绝大部分 <em>同样</em> 不过是计算机里的数字。所以说，比特币作为一种形式的货币，从来就没有什么特殊之处。</p><p>为什么，我们不会把一美元的纸币丢在地上、大声质问 “它不过是一张纸而已！我从前怎么会觉得它有价值呢？” 这似乎不太可能发生，可是没有一种通货贯穿古今。我将主张，货币在投资中有重要功能，而那些成功投资货币的人所得到的好处，解释了为什么人们希望持有它。</p><p>首先，我想先简单地打消各位的一种念头：货币的价值来自于其作为一种交换媒介的用法。货币在用作一种交易媒介时是有用的，但这是因为它有价值，而不是反过来。这可以通过以下事实来证明：你可以在使用货币作为一种交易媒介的同时，完全不增加对它的需求量。如果你赚到钱之后总是马上就花掉，那么你就是把它当成交易媒介，然而，你抛弃它的速度如此之快，一直以立即打消了需求它而产生的效果。</p><p>为了让货币的价值增加，必须让人们在同一时间都想持有更多货币单位，或者都想长期持有它。换句话说，货币的价值反而是来自于人们将它用作储蓄的需求。有些人手停口停，只拥有应付眼下需要的货币。也有人拥有一大笔积蓄，但支出的速度与获得收入的速度大体相等。还有人花得比挣得 多&#x2F;少，从而储蓄会 增加&#x2F;减少。货币的价值，可以从人们想要大量（或少量）储蓄的理由来理解；而货币价值的变动，无论是快是慢，可以从人们对积蓄的评价改变的理由来理解。</p><h2 id="储蓄功能"><a href="#储蓄功能" class="headerlink" title="储蓄功能"></a>储蓄功能</h2><p>以下是持有现金的最实际的好处。持有现金的人，可以在自己要买什么东西上举棋不定，直到最后一刻。他们对意料之外的支出和机会都有更多的准备，因此，可以不必计划。对于没有储蓄的人来说是灾难的事情，有储蓄的人可以当成是普通的开支。绝大多数人，只要他们有足够多的收入，都会给自己的车子、房子和健康买保险。但如果一个人有大量的储蓄，就不需要那么多来自他人的帮助。</p><p>有储蓄的人也更有余力来帮助陷于灾难中的人。如果人们需要帮助，他不仅有能力表示友善，还能从中获得好处。企业都有一些特定的开支，是规律性的，如果凑不出来，就要倒闭。比如说，到日子就必须发工资。也总是有一些风险，让企业在有些时候无法获得足够多的收入。持有额外的现金，就能对冲这些风险；或者，可以使用现金来购买更多资本，或尝试扩大未来的生产能力。在不断变化并且不确定的环境中，维持正确的平衡会很难，所以，哪怕是非常稳健的企业，有时候也会急需现金。这时候，企业的股价会下跌，因为资不抵债的风险增加了。他们可能愿意以非常优厚的利率，向放贷人贷款。手上有现金的投资人，就可以使这样有价值的企业幸存下来，通过承担急需的支出，换来以优厚价格购买股票的机会、或是从债券中获得优厚的利息。</p><p>但是，这样的机会不是每天都有的。手上有现金的人才能抓住它。当一个人拿着现金，他就没有被锁住，并且为机会做好了准备。相反，投资的大量潜在收益取决于能够选择卖出的时机。一项投资品的价格可能会一直下跌，哪怕再长远一些来看，投资人是能够卖出获益的。如果投资者能够持有一项投资品足够长的时间、等待好的卖出机会出现，那么它带来回报的机会就大得多。此外，虽然在普通的日子里，股票看起来随时能卖出，但也有一些时候，绝大部分投资品（除了现金）的价格会同时下跌。在这种时候，想要快速卖出投资品可能就做不到了，因此，从一开始就持有现金会好得多。</p><p>因此，现金为它的主人带来的好处是，准备好了利用好的交易机会；并且，现金持有人因为准备好了前往需要帮助的地方，向经济体提供了相应的好处。现金持有者通过决定哪些受困的企业值得挽救并提供必要的现金，也为经济体带来了好处。</p><p>当然，现金自身并不能修复出问题的企业；它只能用来购买必要的资源。比如说，它可以用来给雇员发工资，使企业保持运营，直至新的收入带来。因此，在一个经济体中，现金持有人的存在，可以认为是经济体的一部分生产能力被保留了下来，以便纠正错误。</p><h2 id="过度投资的问题"><a href="#过度投资的问题" class="headerlink" title="过度投资的问题"></a>过度投资的问题</h2><p>现金持有人可以悠闲地生活，不去投资。谴责这样的人无所事事是个错误。悠闲生活的能力，同时也是随时投入 —— 到人们最需要的无论什么事情 —— 的能力。人们需要这种服务，因为人非圣贤，完全不犯错误是不可能的，所以经济体中的每一个人都依赖于其他人，并且我们也都会受到其他人的错误的影响。</p><p>一个人即使尚未投身于任何事情，也没法跑去解决可能发生的 <em>每一个</em> 问题。最终来说，他也有极限，在投入某件事情之后就无法承担更多。因此，如果有大量的货币体现为现金的形式，那么经济体就有大量的容错能力；相反，如果只有少量货币体现为现金，那经济体的容错能力就少得多。因此，过度投资（overinvestment）的问题在于减少了容错能力。如果每个人都决定立即将货币投入到生产中，那么，虽然理论上，可以同时实现更多目标，但失败的风险也会大得多。如果大量的现金持有人保持观望，那么冒险行为会更少，但成功的概率也会大得多。</p><p>因为发生在一家企业内的错误，可能会影响依赖于这家企业的企业，那么，当人们过度投资的时候，就不仅仅是出错的风险会更大，出错的后果也会严重得多。比如说，假设有两家企业 A 和 B，都作出了需要纠正的短期错误。在一个健康的经济体中，也许其中一家会破产，但另一家会被挽救；然而，在一个过度投资的经济体中，两家都会破产。现在，假设企业 C 可以容忍 A 或 B 中的一家不交货，却不能容忍两家都不交货。那么现在 C 也到破产边缘了。</p><p>因此，完全有可能，在一个过度投资的经济体中，一个小错误会引发大灾难，因为没有人准备好了纠正这个错误，哪怕它很微小。这就是经济危机。当太多人都已投入，没有足够多的人保持观望时，那么经济体中的每个人都必须跟其他人步调一致。在一个健康的经济体中，每个人都有更多空间可以搞砸事情。</p><h2 id="货币地位的保持"><a href="#货币地位的保持" class="headerlink" title="货币地位的保持"></a>货币地位的保持</h2><p>现在，我可以谈谈何以商品的货币地位可以长期保持了，尽管事实上，这几乎只是一种共同的幻觉。为什么人们不会一觉醒来然后把货币丢到大街上？在我的上一篇文章中，我解释了，货币的成长是一个逐步的过程 —— 一种商品，会一个接一个投资人将它当成货币之后逐渐获得货币地位。</p><p>你可能会想，这个过程反过来也是有可能的 —— 投资人对自己的货币失去信心，然后不断抛弃它，一个接一个。为了解释货币地位的长期保持，我们需要一个理论来解释，为什么一些人会买入另一个人想要抛弃的现金。</p><p>我们假设，一个投资人真的担心 TA 手上的现金会变得一文不值。这个人倾向于持有投资品而不是现金，而另一些人倾向于持有现金。或者，反过来，我们假设这个人是个股票狂，根本想不通现金有什么价值，所以，他卖掉了所有东西，把整副身家投入股市。不管是哪一种假设，结果都是一样的。在他卖出现金、换来投资品的时候，他就非常轻微地提高了股票市场相对于现金供给量的价格。从而，他也非常轻微地提高了现金丢失货币地位的风险，以及股票市场崩盘的风险。</p><p>另一位投资人可能会这样应对这位股票狂的举动：判断现金失去货币地位的风险与股票市场崩盘的风险哪个会变得更大。如果他判断股票市场崩盘的风险会变得更大，那么他会卖出股票、换来额外的现金，从而跟第一位投资者形成反向操作。如果他判断现金失去货币地位的风险变得更大，那么他会追随第一位的脚步，也抛弃自己的现金。</p><p>一种历史悠久且备受认可的通货，可能会被视为安全的，因为投资者们都有大量的亲身经历看到其他人依赖于现金作为一种避难所。因此，他们将倾向于（正确地）将股票市场视为比现金有更高的风险。另一方面，如果有理由相信其他投资人正在失去对手上的货币的信息，那么其他投资人偏爱股票市场风险而不是通货风险，也是有可能的。如果有足够多的人这样做，那么这种通货就会失去货币地位，就像他们一开始担心的那样。</p><p>因此，货币地位的长期保持，可以用这样的事实来解释：更多人更迫切地想减少对投资的风险暴露，而不是对现金失去货币地位的风险暴露。于是甚至存在一个货币的自然价格（natural price，也可译为 “中性写几个”）。它跟普通的价格不同，后者是两种商品交换的比例。但你可以认为货币的价格是货币的总供给量对经济体中所有投资品的价值（的某些度量）的比例。（在现实世界中，有许多不同的数字来表示这个价格，因为人们可能对如何正确度量这两者 —— 货币的总供给量与所有投资品的价值 —— 有分歧）。</p><h2 id="改变货币供给量"><a href="#改变货币供给量" class="headerlink" title="改变货币供给量"></a>改变货币供给量</h2><p>本节关于货币供给量的改变如何影响投资者在持有现金和购买投资品上的激励因素。通货紧缩指的是货币总供给量减少的情形，而通胀则是它增加的情形。关于货币总供给量的变化，最重要的事情是，它们发生在具体的地方，是具体行动的后果。不论什么时候，只要有通缩，就有造成通缩的人；只要有通胀，就有造成通胀的人。换句话说，货币不会偶然产生或消失 —— 持有它的总是具体的人。</p><p>通货紧缩是真正的慈善，因为造成通缩的人依靠工作或投资赚到了货币，然后就销毁了它而不要求换回任何东西。因此，人们也很少这样做。通胀是你需要担心的事情，因为造成通货膨胀的人是凭空获得了货币。这意味着，要是这种事情可以逃脱惩罚，那么每个人都会这样做。可以印钱的人，比起只能靠量入为出才能积累货币的人，拥有巨大的优势，因为他需要钱的时候只需要印出来就行了；他可以立即利用好的交易机会，而不必先投入工作、积累出一些现金。因此，有人能够印钱，会让其他人都不那么想持有现金。相反，他们会被激励去投资。</p><p>显然，制造通货膨胀的人并没有创造出更多资源来跟他创造的新货币相匹配。他只是驱赶人们远离储蓄、进入投资。物价会上升，因为所有人都在买东西。没有人留下来准备好纠正错误。投资人们做不到，因为他们的储蓄已经减少了。制造通货膨胀的人也做不到，因为物价已经上升，生产已经不像以前那样容易开展。因此，虽然对于经济体的其余人来说，制造通货膨胀的人看起来像是一个拿着大量现金的投资者，但经济体并没有得到安全好处。因为这是过度投资。</p><h2 id="不再是避难所"><a href="#不再是避难所" class="headerlink" title="不再是避难所"></a>不再是避难所</h2><p>在一个不稳定的市场中，如果一个错误持续传导，就像多米诺骨牌一样蔓延，以至于投资人纷纷逃回现金，投资品市场就崩盘了。而要让现金就会失去货币地位，通货的风险必须持续高于股票市场风险，哪怕越来越多投资人冲进股票市场。我说的这种情况是有可能的，但可能听起来有点奇怪，因为这样的废除货币的事件没有别的源头，只是一个孤独的投资人将他的偏执传染给了其他人。</p><p>但是，使用 “正确” 的通货膨胀计划，制造通胀的人就可以导致这一幕。通货膨胀的速度越快，投资者们就越偏好投资风险、轻视现金的安全性。没有一种广受认可的货币形式（established form of money），或者使用一种替代性的货币，经济体也依然能运行，只是超过一定速度的通货膨胀是不可持续的。需要发生的事情仅仅是制造通货膨胀的人将通胀率带到如此高的水平，以至于停止储蓄现金成为更受偏爱的事。</p><p>随着通货膨胀率提高，投资者越来越倾向于承担风险，持有现金的功能也被削弱了，这还是在它没被别的东西取代的时候发生的。相反，在最开始，经济体必须改变，以降低发生错误的概率。企业必须变得更加自给自足，降低对长期利润的依赖。换句话说，经济体要变得更加原始。</p><p>如果经济体补偿的速度还能跟上通胀者可以花费自己的新货币的速度，那么这个通胀者会发现，为了维持相同的消费水平，他必须让货币量膨胀得越来越快。如果他不想要降低自己的消费水平，那么他就要一直推高通货膨胀率，直至不可持续的水平。那时候，就是人们开始视现金如废纸、如无意义的数字，而不是价值储存物的时候了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇文章，可能是三部曲的最后一部。前两部分别是《<a href="https://nakamotoinstitute.org/reciprocal-altruism-in-the-theory-of-money/">货币理论中的互惠利他主义</a>》以及《<a href="https://nakamotoinstitute.org/mempool/its-not-about-the-technology-its-about-the-money">无关科技，只关货币</a>》。第一部尝试将货币的使用解释成一种游戏。第二部关于货币的成长。最后这一部，则是货币的死亡。</p><p>因为任何商品都可能被用作货币，最好将货币理解成一种行为，而不是一种东西。货币商品常常是没什么用途的东西；是容易统计但难以再生产的东西。货币很少有消费需求。即使是黄金，在工业和珠宝中都有重要用途，通常也只是被储存起来。因此，被使用的具体商品的特性，并不是让货币成为有用之物的理由。人们对待它的方式才让它有用起来。</p><p>人们对待货币的方式是，把它当成是一种适合流动的东西，换句话说，是一种在所有地方都受欢迎的东西。这并非任何一种商品的内在属性。它是一种因为传统而确立的属性。每一次人们接受货币的时候，都是在加强这个传统。这时候人们也是在投资于它，因为没有什么能保证这项传统能一直坚固，到了他们要花费这些货币的时候还巍然不动。但只要人们还在继续这样投资，这样的传统就会持续。</p><p>尽管积累货币的人并不一定有此感觉，但将货币视为利他主义的一种形式是有道理的（生物学家将这种形式称为 “互惠利他主义”）。在互惠利他主义中，一只动物会做一些消耗自身、但会立即给另一只动物带来好处的事。这只动物能够负担这个代价，是因为它火灾一个利他主义的群体中，所以它最终能够从另一只动物的利他主义中获得好处。</p><p>在一个群体中保持互惠利他主义有一个必要条件，就是非利他主义者可以被识别出来并排除在外。否则，一群好吃懒做的人就会靠利他主义者为生，直到利他主义无法为继。在一个货币经济体中，达成这一条件的办法是人们不能有负的余额。人们必须先是利他主义者（先赚钱），然后才能成为受益人（再花费）。</p><p>乍看起来，用利他主义来理解货币有点奇怪，因为人们常常认为求财是出于自利。然而，从生物学上来说，本来就没有真正的利他主义，或者说，即使有，也会很快被消耗至死。所以只有表面上的利他主义。互惠利他主义理论告诉我们的是，一只动物在短期内表现出利他主义、然后在无法自助时收获来自其他动物的帮助，这是有可能的。如果一个外星人突降地球、遇到了一位守财奴，可能也会以为这个守财奴是利他主义者，因为这个守财奴似乎只是出于其他人的要求而拼命工作、却没有换回任何有用的东西。只有当这个外星人看到其他人也尝试积累货币之后，才会理解守财奴的自利。</p><p>因为货币是一种社交行为，所以，它的价值取决于使用它的社会，而不是那种商品的物理属性。因为使用一种货币的人数可以变多也可以变少，并且因为这群人可以想要更多货币也可以想要更少货币，所以，一种货币可以因为一个人对所处社会的了解而变得更有用或更没用。换句话说，一个人可能发现所处的社会变得更多利他或更少利他了，从而，货币变得更有或更没有价值了。</p><p>这种网络效应，解释了货币最初如何从一种可能只有很小的价值的商品成长起来。因为最早投资一种货币的人，将比后来的投资人得到多得多的奖赏，所以最早的投资人有动机承担额外的风险、在它看起来没有价值的时候先行一步。在这样做的时候，他们马上就让这种东西变得更加有用，因为他们形成了一些初步的需求，是其他人可以依赖的。随着货币的成长，最具有先见之明的投资人拉着货币从它的初始状态走向经济体的中心位置。</p><p>货币的死亡也是同样的过程，最具有先见之明的投资人先行逃离，然后越来越多人紧随其后，直到现金不再具有货币的价值。理论上，这个过程可能独自发生，但人们会预期这是由于一位更加优越的竞争者来到市场上，或是由于一种通胀性的货币政策让它变得非常无用。</p><p>这种网络效应也解释了为什么货币会成长也会收缩，但它不能解释为什么货币会到达一个均衡状态。它也无法解释为什么人们会持有比眼前需要更多的现金。理由在于，现金有投资功能，所以投资人需要持有大量现金。货币的均衡价格是这样一个点：投资人们不想再持有更多现金，相反愿意持有更多股票（或债券，或其它投资品）。</p><p>这就是我理解货币的方式。现在，为了社会的福祉，去赚取尽可能多的比特币吧！</p><p><strong>进阶阅读</strong></p><ul><li>《货币，银行信贷与经济周期》，Jesús Huerta de Soto</li><li>《人，货币与国家》，Murray Rothbard</li><li>《经济周期的奥地利学派理论》</li><li>《货币与信用理论》，Ludwig von Mises</li></ul>]]></content>
    
    
    <summary type="html">一个社会在其非理性中逐渐变得洋洋自得的下场</summary>
    
    
    
    <category term="货币理念" scheme="https://www.btcstudy.org/categories/%E8%B4%A7%E5%B8%81%E7%90%86%E5%BF%B5/"/>
    
    
    <category term="货币" scheme="https://www.btcstudy.org/tags/%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>深入分析联合保管多签名的阈值选择</title>
    <link href="https://www.btcstudy.org/2026/01/28/a-deep-dive-into-collaborative-multisig-quorum-options/"/>
    <id>https://www.btcstudy.org/2026/01/28/a-deep-dive-into-collaborative-multisig-quorum-options/</id>
    <published>2026-01-28T12:41:22.000Z</published>
    <updated>2026-02-28T07:32:23.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Tom Honzik</em></p><p><em>来源：<a href="https://www.unchained.com/blog/collaborative-multisig-quorum-options">https://www.unchained.com/blog/collaborative-multisig-quorum-options</a></em></p></blockquote><p>Unchained 已经领导<a href="https://www.unchained.com/blog/what-is-multisig">联合保管</a>比特币服务行业接近十年。我们开发出的产品专门基于 2-of-3 多签名在场要求（quorum），它代表了持有比特币而不担心单点故障的最简单的多签名钱包结构。我们认为，2-of-3 在场要求，是绝大部分人在绝大部分场景下的最佳选择，而更大的在场要求会带来不必要的复杂性。</p><p>在我们<a href="https://www.unchained.com/blog/what-is-multisig">介绍多签名钱包的文章</a>中，我们创建了一个金字塔图来介绍（在场要求）这个概念。我们指出，2-of-3 一般来说是理想的，1-of-N 和 N-of-N 在场要求则无法消除单点故障；同时，一些超过 2-of-3 的在场要求，对于具有特殊需求或者说精细需求的个人和企业，可能是有用的：</p><p><img src="/../images/a-deep-dive-into-collaborative-multisig-quorum-options/f904d5766f.png" alt="img"></p><p>现在，Unchaied 也支持更大范围的多签名在场要求，所以值得更加深入地分析各种选择的长处和弱点。本文将深入介绍各种选项的取舍，从而让你可以对自己的比特币保管安全模型作出明智的选择。我们将从介绍少量概念开始，比如：在场要求的类型、关键类别、自主访问和代理保险。</p><h2 id="多签名金字塔内的在场要求类型"><a href="#多签名金字塔内的在场要求类型" class="headerlink" title="多签名金字塔内的在场要求类型"></a>多签名金字塔内的在场要求类型</h2><p>在我们对超过 2-of-3 的多签名在场要求的分析中，我们发现，将金字塔上的在场要求分成三种类型，将便于理解：<em>中值</em>、<em>小于中值</em>、<em>大于中值</em>。各个类别内的在场要求都有共性。</p><h3 id="中值在场要求"><a href="#中值在场要求" class="headerlink" title="中值在场要求"></a>中值在场要求</h3><p>中值在场要求是沿着多签名金字塔的中线发现的，包括 2-of-3、3-of-5、4-of-7，等等。有个公式可以确定一个 K-of-N 的在场要求是不是一个中值在场要求：<em>2K - 1 &#x3D; N</em> 。</p><p><img src="/../images/a-deep-dive-into-collaborative-multisig-quorum-options/68f2cee3d.png" alt="img"></p><p>中值在场要求可能是最流行的，原因可能在于，它平等对抗你的比特币所面临的两种主要威胁：丢失和盗窃。如果一种参与要求 “太靠左了”，比如 1-of-N ，那么它对盗窃的保护就相对较少，盗贼可能只需要找出一个物件，就足以访问你的资金。如果一种在场要求 “太靠右了”，比如 N-of-N ，那么它对丢失的保护就相对较少，因为它意味着，只要一个私钥损坏或遗忘，你就无法访问自己的资金了。因此，中值在场要求对这些顾虑提供了平等的保护。</p><h3 id="小于中值的在场要求"><a href="#小于中值的在场要求" class="headerlink" title="小于中值的在场要求"></a>小于中值的在场要求</h3><p>小于中值的早场要求是在金字塔的左半边发现的，包括 2-of-4、2-of-5、2-of-6、3-of-6，等等。确定它的公式是：<em>2K - 1 &lt; N</em> 。请注意，在本分析中，我们抛弃 1-of-N 这种在场要求，因为它无法消除单点故障。</p><p><img src="/../images/a-deep-dive-into-collaborative-multisig-quorum-options/68f2cee3d77b0.png" alt="68f2cee3d77b0"></p><p>相比于中值要求，小于中值的在场要求有所侧重 —— 对丢失私钥的保护更多，但对未经授权的访问（也即盗窃）的保护稍微少一些。这也不让人意外，因为，如果密钥总数量不变，更小比例的密钥就足以取走比特币，那这些比特币当然是更容易访问的。</p><h3 id="大于中值的在场要求。"><a href="#大于中值的在场要求。" class="headerlink" title="大于中值的在场要求。"></a>大于中值的在场要求。</h3><p>大于中值的早场要求是在金字塔的右半边发现的，包括 3-of-4、4-of-5、4-of-6、5-of-6，等等。确定它的公式是：<em>2K - 1 &gt; N</em> 。同样地，在本分析中，我们也抛弃 N-of-N 这种在场要求，因为它无法消除单点故障。</p><p><img src="/../images/a-deep-dive-into-collaborative-multisig-quorum-options/68f2cee3d77b0bf90.png" alt="68f2cee3d77b0bf90"></p><p>大于中值的在场要求与小于中值的早场要求取舍相反。它们对盗窃提供了更多的保护，但对丢失提供了相对更少的保护。因为需要更大比例的密钥来取走比特币，那么访问当然是更难的。</p><h2 id="密钥分类：自主管理和代理人管理"><a href="#密钥分类：自主管理和代理人管理" class="headerlink" title="密钥分类：自主管理和代理人管理"></a>密钥分类：自主管理和代理人管理</h2><p>本分析的另一个重要元素是，用在一个多签名装置中的密钥，也可以分成两种主要类型。<em>自主管理的密钥</em>，是由你自己持有的密钥；或者，在比特币财库的情形是，是由你们集体组织中的一个成员持有的密钥。而 <em>代理人管理的密钥</em>，则是由一个<a href="https://www.unchained.com/blog/what-is-a-bitcoin-key-agent">密钥代理人</a>持有的 —— TA 并非这些比特币的主人之一，只是被主人雇佣来保管和操作多签名装置中的一个密钥的人。这个区分很重要，因为它意味着，在任何给定的多签名在场要求中，都可以形成截然不同的保管结构。</p><p>为了说清楚，请形象一个 2-of-3 在场要求的多签名保管装置，它可能有 4 种不同的密钥类型 <em>安排</em>。每一种安排都会产生独特的可以授权取款的密钥组合集合，我们称之为 “<em>访问模式</em> ”：</p><table><thead><tr><th>密钥安排（总共 3 个密钥）</th><th>访问模式（需要 2 个密钥）</th></tr></thead><tbody><tr><td>自主管理的密钥数量：3<br>代理人管理的密钥数量：0</td><td>2 个自主管理的密钥</td></tr><tr><td>自主管理的密钥数量：2<br>代理人管理的密钥数量：1</td><td>2 个自主管理的密钥；1 个自主管理的密钥，1 个代理人管理的密钥</td></tr><tr><td>自主管理的密钥数量：1<br>代理人管理的密钥数量：2</td><td>2 个代理人管理的密钥；1 个自主管理的密钥，1 个代理人管理的密钥</td></tr><tr><td>自主管理的密钥数量：0<br>代理人管理的密钥数量：3</td><td>2 个代理人管理的密钥</td></tr></tbody></table><p>从上表可知，一些安排会比别的安排提供更多的访问模式，从而可能对寻求可选性的人更有吸引力，因为（在这些安排中）从冷存储中取出比特币时他们必须亲身参与。</p><h3 id="关于密钥安排与访问模式的记号"><a href="#关于密钥安排与访问模式的记号" class="headerlink" title="关于密钥安排与访问模式的记号"></a>关于密钥安排与访问模式的记号</h3><p>在本文中，我们将使用一种缩写系统，以更准确地表示密钥安排与访问模式。“2 个自主管理的密钥及 1 个代理人管理的密钥” 这样的安排，将被缩写为 “2S&#x2F;1A”（使用斜杠符号）。至于 “1 个自主管理的密钥 + 1 个代理人管理的密钥” 这样的访问模式，将被缩写为 “1S + 1A”（使用加号）。</p><p>此外，有时候，在多签名安排中会存在多种不同密钥的组合，都符合某一种访问模式；在比较不同的安排时，这个事实也是有关的。一种访问模式允许的不同密钥组合可以表示为 “ (1S+1A)<sup>2</sup> ”，意思是在这种访问模式中，还有两种不同的密钥组合。</p><p>使用这些记号之后，关于 2-of-3 多签名在场要求的表格可以这样表达：</p><table><thead><tr><th>密钥安排</th><th>访问模式</th></tr></thead><tbody><tr><td>3S&#x2F;0A</td><td>(2S)<sup>3</sup></td></tr><tr><td>2S&#x2F;1A</td><td>(2S)<sup>1</sup> ，(1S + 1A)<sup>2</sup></td></tr><tr><td>1S&#x2F;2A</td><td>(1S + 1A)<sup>2</sup>，(2A)<sup>1</sup></td></tr><tr><td>0S&#x2F;3A</td><td>(2A)<sup>3</sup></td></tr></tbody></table><h3 id="代理人管理密钥的子类别"><a href="#代理人管理密钥的子类别" class="headerlink" title="代理人管理密钥的子类别"></a>代理人管理密钥的子类别</h3><p>虽然每一个自主保管的密钥，一般来说可以认为是彼此相似的（主要的区别跟它们的存放位置有关），但代理人管理的密钥则可以根据代理人的分类进一步区分。尤其是，区分由精通密钥代理的 <em>专业机构</em> 持有的密钥，与 <em>亲友</em>（承担管理某个密钥的责任的密友或家庭成员）持有的密钥，是常见做法。在 “<a href="https://www.unchained.com/connections">Connections</a>” 特性推出之后，Unchained 已经支持这两种类型的代理人管理密钥。</p><p>区分这些代理人管理的密钥的类型也是有用的。专业机构一般来说在密钥管理上会比亲友更有经验，因为他们有谨慎设计的护栏和流程。同时，亲友则在机构流程可视为繁琐障碍的情形中具有优势，比如在时间紧急的情况下。</p><h2 id="自主访问与代理人保险"><a href="#自主访问与代理人保险" class="headerlink" title="自主访问与代理人保险"></a>自主访问与代理人保险</h2><p>评价一种多签名在场要求安排的最重要指标之一就是它能否提供用户自主访问渠道，以及&#x2F;或者 一个代理人保险。<em>自主访问</em> 意味着保管中的比特币可以完全由自主管理的密钥来访问，无需任何密钥代理人的帮助。而 <em>代理人保险</em> 则意味着即使所有自主管理的密钥都丢失，保管中的比特币也依然能取出，因为安排中有足够多的代理人管理的密钥，可以授权取出比特币。</p><p>只要你希望能够独立访问自己的比特币、无需第三方参与，自主访问特性就是有用的；但是，如果你担心攻击者勒索你交出资金的可能性，那自主访问可能就是不讨喜的了。如果你担心自己会弄丢所有的自主管理密钥，那么代理人保险可能是个好功能；但如果你担心你的密钥代理会恶意串通、夺走你的比特币，那这个功能又是讨厌的了。</p><table><thead><tr><th></th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td><strong>自主访问</strong></td><td>完全独立控制资金，无需来自密钥代理人的帮助</td><td>在面对人身攻击时，资金可能更加危险</td></tr><tr><td><strong>代理保险</strong></td><td>即使你所有的密钥都丢失或被盗了，资金也有可能复原</td><td>理论上，密钥代理可能串通来盗取资金</td></tr></tbody></table><p>还值得指出的是，上面提到的这两种特性的劣势都可以通过特定的技术来缓解。如果一种安排包含了自主访问，并且自主管理的密钥在空间上充分分散，那么人身威胁就不那么可能导致资金丢失。如果一种安排包含了代理人保险，在挑选代理人时谨慎小心，就可以让串通的概率变得非常低。有可能让密钥代理人们不知道彼此的存在。你可以在专业机构和亲友之间分割密钥代理的责任，从而，串谋变得需要多种类型的背叛 —— 既包括 机构&#x2F;政府 的背叛，又包括个人层面的背叛。</p><h2 id="评估中值在场要求"><a href="#评估中值在场要求" class="headerlink" title="评估中值在场要求"></a>评估中值在场要求</h2><p>中值在场要求这种要求很有趣，因为它使你必须在自主访问和代理人保险之间作出选择。在中值在场要求的装置中，没有一种密钥安排能同时具有这两种特性，也没有一种安排是两者皆失的。</p><p>我们来仔细看看中值在场要求的最简单例子，2-of-3 和 3-of-5 。</p><h3 id="2-of-3-多签名"><a href="#2-of-3-多签名" class="headerlink" title="2-of-3 多签名"></a>2-of-3 多签名</h3><table><thead><tr><th>密钥安排</th><th>访问模式</th><th>自主访问</th><th>代理人保险</th></tr></thead><tbody><tr><td>3S&#x2F;0A</td><td>(2S)<sup>3</sup></td><td>有</td><td>无</td></tr><tr><td>2S&#x2F;1A</td><td>(2S)<sup>1</sup> ，(1S + 1A)<sup>2</sup></td><td>有</td><td>无</td></tr><tr><td>1S&#x2F;2A</td><td>(1S + 1A)<sup>2</sup>，(2A)<sup>1</sup></td><td>无</td><td>有</td></tr><tr><td>0S&#x2F;3A</td><td>(2A)<sup>3</sup></td><td>无</td><td>有</td></tr></tbody></table><p>2-of-3 多签名在场要求是受到最广泛推荐的在场要求，因为它的总密钥数量最少且管理复杂性最小，同时，又能成功对抗单点故障。它也提供了多种多样的密钥安排选择，来满足不同的目标。3S&#x2F;0A 这种安排可以完全依靠自身的努力来搭建，不使用任何密钥代理，它的取舍我们在<a href="https://www.unchained.com/features/diy-vs-collaborative-multisig">较早的一篇文章</a>中分析过。2S&#x2F;1A 是建立联合保管关系的一种好方法，它无需放弃自主访问。1S&#x2F;2A 和 0S&#x2F;3A 则是尽可能减少你的密钥保管责任的方法，而且你不需要信任单个比特币托管商。</p><h3 id="3-of-5-多签名"><a href="#3-of-5-多签名" class="headerlink" title="3-of-5 多签名"></a>3-of-5 多签名</h3><table><thead><tr><th>密钥安排</th><th>访问模式</th><th>自主访问</th><th>代理人保险</th></tr></thead><tbody><tr><td>5S&#x2F;0A</td><td>(3S)<sup>10</sup></td><td>有</td><td>无</td></tr><tr><td>4S&#x2F;1A</td><td>(3S)<sup>4</sup> ，(2S + 1A)<sup>6</sup></td><td>有</td><td>无</td></tr><tr><td>3S&#x2F;2A</td><td>(3S)<sup>1</sup> ，(2S + 1A)<sup>6</sup>，(1S + 2A)<sup>3</sup></td><td>有</td><td>无</td></tr><tr><td>2S&#x2F;3A</td><td>(2S + 1A)<sup>3</sup>，(1S+2A)<sup>6</sup>，(3A)<sup>1</sup></td><td>无</td><td>有</td></tr><tr><td>1S&#x2F;4A</td><td>(1S+2A)<sup>6</sup>，(3A)<sup>4</sup></td><td>无</td><td>有</td></tr><tr><td>0S&#x2F;5A</td><td>(3A)<sup>10</sup></td><td>无</td><td>有</td></tr></tbody></table><p>以更多的密钥和更多的复杂性为代价，3-of-5 在场要求不仅能够消除单点故障，还能消除 “双点故障”（比如说，任何两个密钥丢失，资金也依然能复原）。这是能够实现这一点的最小的在场要求，就像 4-of-7 是能够消除 “三点故障” 的最小在场要求一样，以此类推。在现实中，绝大部分人都只需要打败单点故障，就能成功地长期保护自己的比特币。</p><p>3-of-5 在场要求有一些密钥安排较为有趣，比如 3S&#x2F;2A，它实现了自主访问，但在大部分自主保管的密钥丢失的条件下也有复原路径可用。2S&#x2F;3A 则可通过 3 个不同的代理人实现代理人保险，同时，只要其中一个代理人加上你的两个自主管理的密钥，就能取出资金。</p><h2 id="评估小于中值的在场要求"><a href="#评估小于中值的在场要求" class="headerlink" title="评估小于中值的在场要求"></a>评估小于中值的在场要求</h2><p>小于中值的在场要求较为特殊，因为不需要获得占大多数的密钥，就能花费资金。因此，这一分类以最少的密钥总数产生了最多的访问模式和密钥组合。它是唯一一种可能产生 <em>既可以</em> 自主访问 <em>又具有</em> 代理人保险的安排的在场要求。</p><p>我们来看小于中值的在场要求的两个最简单的例子，2-of-4 和 2-of-5 。</p><h3 id="2-of-4-多签名"><a href="#2-of-4-多签名" class="headerlink" title="2-of-4 多签名"></a>2-of-4 多签名</h3><table><thead><tr><th>密钥安排</th><th>访问模式</th><th>自主访问</th><th>代理人保险</th></tr></thead><tbody><tr><td>4S&#x2F;0A</td><td>(3S)<sup>6</sup></td><td>有</td><td>无</td></tr><tr><td>3S&#x2F;1A</td><td>(2S)<sup>3</sup> ，(1S + 1A)<sup>3</sup></td><td>有</td><td>无</td></tr><tr><td>2S&#x2F;2A</td><td>(2S)<sup>1</sup> ，(1S + 1A)<sup>4</sup>，(2A)<sup>1</sup></td><td>有</td><td>有</td></tr><tr><td>1S&#x2F;3A</td><td>(1S + 1A)<sup>3</sup>，(2A)<sup>3</sup></td><td>无</td><td>有</td></tr><tr><td>0S&#x2F;3A</td><td>(2A)<sup>3</sup></td><td>无</td><td>有</td></tr></tbody></table><p>2-of-4 多签名提供的访问模式与 2-of-3 多签名所提供的没有很大区别，只有一个例外：2S&#x2F;2A 。这种安排是特殊的，因为它表明，2-of-4 在场要求是能够产生 3 种访问模式的最小多签名在场要求。类似地，3-of-6 是能够产生 4 种访问模式的最小要求，以此类推。</p><p>2S&#x2F;2A 这种密钥安排，也是同时拥有自主访问和代理人保险的最简单方式。这可能是一种有吸引力的选择，如果你希望既能 <em>不必依赖于</em> 来自代理人的帮助、独立访问自己的比特币，在完全弄丢自己的自主管理密钥时又有 <em>可能</em> 获得来自代理人的协助。</p><h3 id="2-of-5-多签名"><a href="#2-of-5-多签名" class="headerlink" title="2-of-5 多签名"></a>2-of-5 多签名</h3><table><thead><tr><th>密钥安排</th><th>访问模式</th><th>自主访问</th><th>代理人保险</th></tr></thead><tbody><tr><td>5S&#x2F;0A</td><td>(2S)<sup>10</sup></td><td>有</td><td>无</td></tr><tr><td>4S&#x2F;1A</td><td>(2S)<sup>6</sup> ，(1S + 1A)<sup>4</sup></td><td>有</td><td>无</td></tr><tr><td>3S&#x2F;2A</td><td>(2S)<sup>3</sup> ，(1S + 1A)<sup>6</sup>，(2A)<sup>1</sup></td><td>有</td><td>有</td></tr><tr><td>2S&#x2F;3A</td><td>(2S)<sup>1</sup>，(1S+1A)<sup>6</sup>，(2A)<sup>3</sup></td><td>有</td><td>有</td></tr><tr><td>1S&#x2F;4A</td><td>(1S+1A)<sup>4</sup>，(2A)<sup>6</sup></td><td>无</td><td>有</td></tr><tr><td>0S&#x2F;5A</td><td>(2A)<sup>10</sup></td><td>无</td><td>有</td></tr></tbody></table><p>对比 2-of-5 多签名与 2-of-4 多签名，我们发现，它没有不同的访问模式集合。主要区别在于，在产生任何一种访问模式时，都有更多的密钥组合可能，这对 2-of-6、2-of-7 这些密钥总数更多的在场要求上也是成立的。如果你有理由让某种访问模式比其它模式更优先，这个事实可能有它的意义。</p><h2 id="评估大于中值的在场要求"><a href="#评估大于中值的在场要求" class="headerlink" title="评估大于中值的在场要求"></a>评估大于中值的在场要求</h2><p>大于中值的在场要求的独特性在于，需要获得绝对多数的密钥才能花费资金。因此，这一分类产生了最少的访问模式和密钥组合。它是唯一一种可能产生 <em>既无法</em> 自主访问 <em>又没有</em> 代理人保险的安排的在场要求。</p><p>我们来看大于中值的在场要求的两个最简单的例子，3-of-4 和 4-of-5 。</p><h3 id="3-of-4-多签名"><a href="#3-of-4-多签名" class="headerlink" title="3-of-4 多签名"></a>3-of-4 多签名</h3><table><thead><tr><th>密钥安排</th><th>访问模式</th><th>自主访问</th><th>代理人保险</th></tr></thead><tbody><tr><td>4S&#x2F;0A</td><td>(3S)<sup>4</sup></td><td>有</td><td>无</td></tr><tr><td>3S&#x2F;1A</td><td>(3S)<sup>1</sup> ，(2S + 1A)<sup>3</sup></td><td>有</td><td>无</td></tr><tr><td>2S&#x2F;2A</td><td>(2S + 1A)<sup>2</sup>，(1S + 2A)<sup>2</sup></td><td>无</td><td>无</td></tr><tr><td>1S&#x2F;3A</td><td>(1S + 2A)<sup>3</sup>，(3A)<sup>1</sup></td><td>无</td><td>有</td></tr><tr><td>0S&#x2F;3A</td><td>(3A)<sup>4</sup></td><td>无</td><td>有</td></tr></tbody></table><p>在密钥安排相同时，3-of-4 多签名所能提供的访问模式，与 3-of-5 多签名基本上是相同的，只有 2S&#x2F;2A 有所区别。它是既没有自主访问、又没有代理人保险的最简单密钥安排。这对一些既担心人身威胁、因此希望取款流程有密钥代理人参与，同时又希望杜绝密钥代理人勾结的人可能有吸引力。两种担心都与盗窃威胁有关，这是大于中值的在场要求优先防止的风险（相比丢失密钥的危险）。</p><h3 id="4-of-5-多签名"><a href="#4-of-5-多签名" class="headerlink" title="4-of-5 多签名"></a>4-of-5 多签名</h3><table><thead><tr><th>密钥安排</th><th>访问模式</th><th>自主访问</th><th>代理人保险</th></tr></thead><tbody><tr><td>5S&#x2F;0A</td><td>(4S)<sup>5</sup></td><td>有</td><td>无</td></tr><tr><td>4S&#x2F;1A</td><td>(4S)<sup>1</sup> ，(3S + 1A)<sup>4</sup></td><td>有</td><td>无</td></tr><tr><td>3S&#x2F;2A</td><td>(3S + 1A)<sup>2</sup> ，(2S + 2A)<sup>3</sup></td><td>无</td><td>无</td></tr><tr><td>2S&#x2F;3A</td><td>(2S + 2A)<sup>3</sup>，(1S+3A)<sup>2</sup></td><td>无</td><td>无</td></tr><tr><td>1S&#x2F;4A</td><td>(1S+3A)<sup>4</sup>，(4A)<sup>1</sup></td><td>无</td><td>有</td></tr><tr><td>0S&#x2F;5A</td><td>(4A)<sup>5</sup></td><td>无</td><td>有</td></tr></tbody></table><p>相比 3-of-4，4-of-5 在场要求增加了一个密钥，并且也要求多一个密钥来授权取款。这使得移动资金变得更加困难，并提高了完全失去访问权的风险。只要装置中的两个密钥丢失或损耗，保管中的比特币就永远无法访问了。虽然其它在场要求（比如 2-of-3）也有这种情况，但如果密钥总数更多（比如 5 个），那么丢失和损坏的风险也会放大。有一些大于中值的在场要求（比如 4-of-6），因为离金字塔的边缘更远（更靠近中线），风险会小一些。</p><h2 id="确定你的理想保管装置"><a href="#确定你的理想保管装置" class="headerlink" title="确定你的理想保管装置"></a>确定你的理想保管装置</h2><p>如我们前面所证明的，多签名钱包有许多在场要求和密钥安排可供选择，带来了高度可定制的比特币保管装置。有些选项似乎是首屈一指的，但如果你理解所有相关的取舍，你可以优先考虑你最在乎的特性，从而缩小选择范围。</p><table><thead><tr><th></th><th>长处</th><th>短处</th></tr></thead><tbody><tr><td><strong>密钥总数较少且在场要求低</strong></td><td>相对简单，在分析和管理时更少变量</td><td>定制能力亦相对受限</td></tr><tr><td><strong>密钥总数较多且在场要求高</strong></td><td>可以满足更具体和精细的需要</td><td>更多密钥材料和其它变量需要管理，复杂性由此增加</td></tr><tr><td><strong>中值在场要求</strong></td><td>平等对待丢失和盗窃的风险</td><td>没有优先对待哪种担心</td></tr><tr><td><strong>小于中值的在场要求</strong></td><td>失去访问能力的风险较小</td><td>可能增加盗窃漏洞</td></tr><tr><td><strong>大于中值的在场要求</strong></td><td>因为盗窃而损失资金的风险较小</td><td>可能增加资金变得无法访问的漏洞</td></tr><tr><td><strong>更大比例的自主保管密钥</strong></td><td>较少依赖密钥代理人</td><td>带来更多管理密钥材料的个人责任</td></tr><tr><td><strong>更大比例的代理人管理密钥</strong></td><td>尽可能降低了个人的密钥管理责任</td><td>更加依赖密钥代理人</td></tr></tbody></table><p>一些可以追问自我的问题有：</p><ul><li>你是否愿意并且有信心保管你的比特币密钥？</li><li>自主访问特性对你来说是好还是不好？</li><li>代理人保险对你来说是好还是不好？</li><li>带有更多元素的复杂安排是否本身让你困扰，还是说它是满足你的企业或组织的需要的必要方式？</li><li>你是否强烈倾向于优先获得某些保护，比如防止你的比特币因为丢失访问能力而丢失，或是盗窃？</li></ul><p>在思考这些问题时，大部分人可能会发现，2-of-3 在场要求里面的某种密钥安排是能满足他们的目标的。然而，也有人会为了增加定制能力而走向 3-of-5 在场要求，或者为了同时获得自主访问和代理人保险而走向 2-of-4 在场要求，为了长期锁定资金而选择 3-of-4 在场要求，或是采用 4-of-6 在场要求来模拟 3-of-4 同时增加对抗密钥丢失的保护。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">在场要求、密钥安排、访问模式、自主与保险</summary>
    
    
    
    
    <category term="多签名钱包" scheme="https://www.btcstudy.org/tags/%E5%A4%9A%E7%AD%BE%E5%90%8D%E9%92%B1%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>为富状态的比特币脚本探索 Lamport 和 Winternitz 签名</title>
    <link href="https://www.btcstudy.org/2026/01/27/exploring-lamport-and-winternitz-signatures-for-stateful-bitcoin-scripts/"/>
    <id>https://www.btcstudy.org/2026/01/27/exploring-lamport-and-winternitz-signatures-for-stateful-bitcoin-scripts/</id>
    <published>2026-01-27T11:18:44.000Z</published>
    <updated>2026-02-28T07:32:23.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Nicolas Vescovo</em></p><p><em>来源：<a href="https://www.rootstocklabs.com/blog/exploring-lamport-and-winternitz-signatures-for-stateful-bitcoin-scripts/">https://www.rootstocklabs.com/blog/exploring-lamport-and-winternitz-signatures-for-stateful-bitcoin-scripts/</a></em></p></blockquote><p>“BitVM” 这一框架的设计目的是将任意链外计算的乐观主义验证（optimistic verification）带给比特币网络，从而允许更加复杂的操作，比如 “zk rollup” 和侧链桥。BitVM 通过引入支持乐观主义验证的机制，增强了比特币的灵活。“BitVMX” 则使用不同的技术，让部分操作能够更快、更高效地检查，取得了更好的成果。在这一语境下，“乐观主义验证” 表示基于一种假设的验证方法 —— 假设<strong>操作都是有效的，除非能证明不是</strong>。</p><p>为了保证这样的系统的安全性，BitVM 和 BitVMX 使用 Lamport 签名和 Winternitz 签名。这些密码学方法是确保整个过程具有 “富状态性（statefulness）” 的关键。通过使用这些签名方案，BitVM 和 BitVMX 提供了强大的安全性，可以抵御多种攻击并保证所有操作都得到了正确执行。</p><p>本文解释了 “Lamport 签名” 和 “Winternitz 签名” 分别是什么样的、后者如何延申了前者的概念，以及它们如何用在 BitVM 中。我们也将解释，这些签名如何在 BitVM 和 BitVMX 中带来富状态性、确保特定的变量一旦被设定，在后续的脚本中就无法再修改和复用。</p><h2 id="理解-Lamport-签名和-Winternitz-签名"><a href="#理解-Lamport-签名和-Winternitz-签名" class="headerlink" title="理解 Lamport 签名和 Winternitz 签名"></a>理解 Lamport 签名和 Winternitz 签名</h2><p>一种电子签名方案就是一种用来验证电子消息（或者说文档）的真实性和完整性的数学方案。简单来说：</p><ul><li>Lamport 签名使用了<strong>一次性的电子承诺</strong>（基本上基于哈希函数）来提供不可伪造的签名。</li><li>Winternitz 签名则利用<strong>一种单向函数的多轮迭代</strong>（通常会形成链条）来实现密码学安全性。</li></ul><p><strong>Lamport 签名</strong>：由 Leslie Lamport 在 1970 年代晚期提出，是一种基于哈希函数的电子签名方案。它利用密码学哈希函数的单向特性来获得安全性。Lamport 签名因其简洁性以及抵御量子计算攻击的能力而闻名。它的模式是预先生成大量的密钥对，然后用它来签名。不过，其巨大的签名体积，也可能会限制其应用。</p><p><strong>Winternitz 签名</strong>：由 Ralph Merkle 和 Robert Winternitz 分别独立提出，是另一种基于哈希函数的电子签名。它提供了跟 Lamport 签名相似的安全性，且更加高效。相比 Lamport 签名，Winternitz 签名利用了一种链条结构，降低了签名的大小，这使它更加实用。通过允许用户调整 Winternitz 参数，这些签名可以在计算速度和签名体积之间取得平衡，实质上，是将 Lamport 签名方案一般化了。</p><h2 id="Lamport-签名：形式化视角"><a href="#Lamport-签名：形式化视角" class="headerlink" title="Lamport 签名：形式化视角"></a>Lamport 签名：形式化视角</h2><p>在本章中，我们提供了对 Lamport 签名如何生成、使用和验证的分步骤解释。我们探索了密钥生成过程、消息签名和签名验证的技术方面。最后，我们讨论了与之有关的安全性考虑和弱点。</p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>为需要签名的消息中的每一个比特 i 生成两串随机的字符串（比特序列），分别记为 $S_{i, 0}$ 和 $S_{i, 1}$ 。如果消息的长度是 n 比特，那么 i 的取值范围是从 0 到 $n-1$ 。</p><p>私钥就是由这些随机字符串对 $(S_{i, 0}, S_{i, 1})$ 组成的（其中 $i &#x3D; 0, 1, …, n-1$）。</p><p>对于私钥中的每一对字符串 $(S_{i, 0}, S_{i, 1})$ ，计算这些字符串的哈希值并保持配对：$(H(S_{i, 0}), H(S_{i, 1}))$ 。</p><p>公钥则是由这些哈希值对 $(H(S_{i, 0}), H(S_{i, 1}))$ 组成的（其中 $i &#x3D; 0, 1, …, n-1$）。</p><h3 id="签名消息"><a href="#签名消息" class="headerlink" title="签名消息"></a>签名消息</h3><p>将待签名的消息 m 转化为二进制形式，即 $m &#x3D; m_0m_1…m_{n-1}$ ，每一个 $m_i$ 都是一个比特（其值为 0 或 1 ）。</p><p>对于消息的每一个比特 $m_i$ ，在签名中包含对应的私钥 $S_{i, m_i}$ 。</p><p>最终，签名就是一个有 n 个元素的序列：<code>(S_&#123;0, m_0&#125;, S_&#123;1, m_1&#125;,...,S_&#123;&#123;n-1&#125;, m_&#123;n-1&#125;&#125;)​</code>。</p><h3 id="验证一个签名"><a href="#验证一个签名" class="headerlink" title="验证一个签名"></a>验证一个签名</h3><p>给定一条消息 m 及其签名 <code>(S_&#123;0, m_0&#125;, S_&#123;1, m_1&#125;,...,S_&#123;&#123;n-1&#125;, m_&#123;n-1&#125;&#125;)​</code> 。</p><p>将消息 m 转化为二进制形式：$m &#x3D; m_0m_1…m_{n-1}$ 。</p><p>对于每一个比特  $m_i$ ，计算签名中对应元素的哈希值：$H(S_{i, m_i})$ 。</p><p>验证计算出来的每一个哈希值 $H(S_{i, m_i})$ 都跟公钥中的对应元素（$H(S_{i,0})$ 或 $H(S_{i, 1})$）相匹配。</p><h3 id="安全考虑"><a href="#安全考虑" class="headerlink" title="安全考虑"></a>安全考虑</h3><ul><li><strong>一次性使用</strong>：仅在每一对密钥只用来签名一条消息时，Lamport 签名方案才是安全的。使用同一对密钥来签名多条消息会揭晓部分私钥，从而牺牲安全性。</li><li><strong>哈希函数</strong>：Lamport 签名方案的安全性依赖于所用的密码学哈希函数的强度 —— 它应该能抵抗原像攻击、第二原像攻击以及碰撞攻击。</li></ul><h2 id="为什么它们叫-“一次性签名”？"><a href="#为什么它们叫-“一次性签名”？" class="headerlink" title="为什么它们叫 “一次性签名”？"></a>为什么它们叫 “一次性签名”？</h2><p>Lamport 签名方案被称作 “一次性签名”，因为在这种方案中，一旦同一把公钥用来签名多于一条消息，其安全性就会急剧下降。其中的道理在于，每多签名一条消息，就会多揭晓一些关于私钥的信息，从而让攻击者更容易伪造签名。</p><p>在观察到一个签名之后，攻击者就知道了公钥中的每一对哈希值中的一个的原像。然而，有了两个签名，攻击者就能知道其中一半哈希值对的两个原像，以及另一半哈希值对的一个原像。有了三个签名，攻击者就能知道其中四分之三的哈希值对的两个原像；以此类推。这种逐步的曝光，意味着同一个公钥每多签一个名，其安全性实质上都会减半。</p><p>（译者注：作者在上一段的推理中使用了消息的比特随机分布的假设。）</p><p>举个例子，如果一个公钥被设计成对第二原像攻击提供 256 比特的安全性以及对碰撞攻击提供 128 比特的安全性，在它签名三次之后，实用的攻击就有可能发动。在它签名四次之后，找出 消息-签名 的配对就变得非常简单了。因为攻击者可以使用已知的哈希值（及其原像）来为自己选定的消息构造新的有效签名，漏洞由此产生；在消息有一些灵活性的语境中尤其如此。</p><h2 id="在使用超过一次时-Lamport-签名的漏洞"><a href="#在使用超过一次时-Lamport-签名的漏洞" class="headerlink" title="在使用超过一次时 Lamport 签名的漏洞"></a>在使用超过一次时 Lamport 签名的漏洞</h2><p>Lamport 签名在同一公钥重复签名时的主要漏洞在于，攻击者能够利用从以往观察到的签名中获得的信息，为任意消息伪造签名。假设一个攻击者能够知晓使用同一个公钥为多条消息生成的签名。这时候，TA 就能将已知的签名拼凑在一起，构造出新的有效签名。</p><p>比如说，考虑一个消息长度为 16 比特的情形：</p><p>签过名的消息有：m<sub>1</sub> &#x3D; 0001111101110001  以及 m<sub>2</sub> &#x3D;  0111110000111111 。攻击者就能为一条新消息 m<sup>* </sup> &#x3D; 0101111000110101 伪造签名，只需要将对上述两条消息的签名中的对应部分拼凑起来。但凡是使用从 m<sub>1</sub> 和 m<sub>2</sub> 的对应位置的比特构造出的 m<sup>* </sup> ，就都能伪造出有效的签名 —— 只需要对应于这些比特的值的哈希值的原像，就能构造出签名。</p><p>如果消息在签名之前哈希过（也即签名的不是消息本身，而是消息的哈希值），那么攻击就要变得更加复杂，但依然是可行的。攻击者必须找出一条消息 m<sup>* </sup> ，其哈希值与以往签过名的消息的哈希值有足够多相同的部分。每多一条可以观察到的签名，都可以减少攻击所需的哈希函数求值的次数，也就是让伪造变得更加容易。</p><p>本质上，在使用 Lamport 签名方案时，为了保持安全性，每个公钥都只应使用一次。为多条消息的签名重复使用一个公钥，将允许攻击者获得足够多的信息来伪造新的签名，最终打破这种密码系统的完整性。</p><h2 id="Winternitz-签名：理论视角"><a href="#Winternitz-签名：理论视角" class="headerlink" title="Winternitz 签名：理论视角"></a>Winternitz 签名：理论视角</h2><p>如我们已经介绍过的，Winternitz 一次性签名（WOTS）是 Lamport 签名的一种强化，极大地缩小了签名和公钥的体积。但天下可没有免费的午餐。这种提升的代价是，生成和验证签名都要更花功夫。在本章中，我们会提供一种形式化的定义，并解释 Winternitz 签名是如何工作的。</p><h3 id="参数与启动"><a href="#参数与启动" class="headerlink" title="参数与启动"></a>参数与启动</h3><ul><li>W：Winternitz 参数，一个正整数，决定一次能处理的比特数量。</li><li>n：哈希输出的长度（以比特计）。</li><li>l：消息摘要的分段数量，计算方式是  $l &#x3D; \lceil n&#x2F;W \rceil$ 。这里的 $\lceil \rceil$ 意味着取大于或等于给定数字的最小整数 。</li><li>l’：校验和的长度，计算方式是 $l’ &#x3D; \lceil (\log_2(l * (2^W - 1)))&#x2F;W \rceil$</li><li>L：签名的总长度，L &#x3D; l + l’ 。</li></ul><h3 id="密钥生成-1"><a href="#密钥生成-1" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>生成 L 个长度为 n 的随机比特串 $S_i$ ，其中 $i &#x3D; 0, 1, …, L-1$ 。</p><p>私钥就是由这些随机比特串组成的：$S &#x3D; (S_0, S_1, …, S_{L-1})$ 。</p><p>对于每一个私钥碎片 $S_i$ ，连续应用哈希函数 $2^W$ 次：$P_i &#x3D; H^{2^W}(S_i)$ 。</p><p>公钥就是用这些哈希结果组成的：$P &#x3D; (P_0, P_1, …, P_{L-1})$</p><h3 id="签名消息-1"><a href="#签名消息-1" class="headerlink" title="签名消息"></a>签名消息</h3><p>将待签名的消息 m 分割为长为 W 比特的 l 个碎片：$m &#x3D; (m_0, m_1, …, m_{l-1})$ 。</p><p>计算校验和 C ：$C &#x3D; \sum_{i&#x3D;0}^{l-1}(2^W - 1 - m_i)$ 。</p><p>将校验和 C 转化为长为 W 比特的 l’ 个碎片：$C &#x3D; (c_0, c_1, …, c_{l’-1})$  。一般来说，会把第一个元素当成校验和：$C &#x3D; (c_0)$ 。</p><p>对于摘要的每一个碎片 $m_i$ 以及校验和 $c_i$ ，通过哈希对应的私钥碎片 $m_i$ 次来生成签名 $\sigma_i$ ：$\sigma_i &#x3D; H^{m_i}(S_i)$ ，其中  $i &#x3D; 0, 1, …, l-1$  。</p><p>类似的，对于校验和的部分：$\sigma_{l+j} &#x3D; H^{c_j}(S_{l+j})$ ，其中 $j &#x3D; 0, 1, …, l’-1$  。</p><p>完整的签名就是这些碎片的拼接：$\sigma &#x3D; (\sigma_0, \sigma_1, …, \sigma_{L-1})$ 。</p><h3 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h3><p>给定消息 m 及其签名$\sigma &#x3D; (\sigma_0, \sigma_1, …, \sigma_{L-1})$ 。</p><p>将消息 m 分割成 l 份：$m &#x3D; (m_0, m_1, …, m_{l-1})$ 。</p><p>计算校验和 C 并将它分割成 l’ 份：$C &#x3D; (c_0, c_1, …, c_{l’-1})$  。</p><p>对于每一个签名碎片 $\sigma_i$ ，应用哈希函数 $2^W - 1 - m_i$ 次，期待它能推导出公钥碎片：<br>$$<br>P_i : \widehat{P_i} &#x3D; H^{2^W - 1 - m_i}(\sigma_1) , \qquad i &#x3D; 0, 1, …, l -1<br>$$<br>类似地，对于校验和的部分：<br>$$<br>\widehat{P_{l+j}} &#x3D; H^{2^W - 1 - c_{j}}(\sigma_{l+j}) , \qquad j &#x3D; 0, 1, …, l’ -1<br>$$<br>如果派生出来的公钥 $(\widehat{P_0}, \widehat{P_1},…, \widehat{P_{L-1}})$ 与公钥 $P &#x3D; (P_0, P_1, …, P_{L-1})$ 相匹配，则说明这是个有效的签名。</p><h3 id="安全考虑-1"><a href="#安全考虑-1" class="headerlink" title="安全考虑"></a>安全考虑</h3><ul><li><strong>参数挑选</strong>：W 的选择会影响签名体积与计算效率的取舍。更大的 W 值会降低签名的体积，但会提高签名和验证的计算负担。</li><li><strong>一次性使用</strong>：与 Lamport 签名一样，Winternitz 签名也是一次性使用的。在多条消息的签名中重复使用同一对密钥，会因为揭晓关于私钥的信息而牺牲安全性。</li></ul><p>下图演示了当 W &#x3D; 2 ，l &#x3D; 5 时，Winternitz 链条的序列（从私钥派生公钥）。每一个箭头都表示一次哈希求职。（译者注：此处原文有误，已纠正。）</p><p><img src="/../images/exploring-lamport-and-winternitz-signatures-for-stateful-bitcoin-scripts/image59.png" alt="image59"></p><h2 id="为什么校验和是必要的？"><a href="#为什么校验和是必要的？" class="headerlink" title="为什么校验和是必要的？"></a>为什么校验和是必要的？</h2><p>从技术角度看，Winternitz 签名方案中的校验和，对于保持安全性和保证签名过程的完整性，都是必要的。</p><p>Winternitz 签名方案的模式是将消息分割成碎片，然后根据各碎片的值将对应的私钥碎片哈希一定的次数（译者注：此处原文有误，已纠正）。然而，这个过程就带来了一个漏洞：只要攻击者知道一个签名（它由各哈希链条上的某个值组成），就可以使用哈希链条上的后续元素来构造有效的签名。这是因为，只要揭晓了哈希链条上的一个成员，攻击者就可以计算出所有后续的哈希值（它们本身就是同一私钥碎片对某个值的签名），从而打破签名的完整性。</p><p>为了消除这种风险，检验和就是关键了。它保证了，对消息的任何改动，都会让校验和也发生对应的、一致的改动，而这种计算，在没有私钥的情况下是计算上不可行的。因为，想要使用一些哈希链条上的后续的值，将需要知道签名校验和的哈希链条上比较靠前的值（在没有私钥的情况下，这是不可能做到的）。校验和是一个额外的验证层，让没有原像攻击能力的攻击者无法在不知道私钥的情况下为另一条消息生成一个有效的签名。</p><p>（译者注：此处的推理是，由于哈希链条是单向的，所以，在不考虑校验和的情况下，知晓一条 WOTS 签名只允许攻击者为数值更大的各个 $m_i$ 伪造签名，也即使用哈希链条上更靠后的值。然而，在使用前述校验和 $C &#x3D; \sum_{i&#x3D;0}^{l-1}(2^W - 1 - m_i)$ 的情况下，更大的 $m_i$ 将带来更小的 C，签名这样的 C 将要求使用私钥哈希链条上更为靠前的值，想要从已知的签名中推导出它意味着逆转哈希运算，这是计算上不可行的。因此，如无私钥，就无法制作出签名。）</p><p>此外，校验和也保证了签名过程的完整性。它是一个最终的检查，验证在签名过程中没有遗漏或替换某个比特。这保证了整条消息都被考虑到了、在签名中有了正确的表示。</p><p>此外，校验和还验证了签名的整体完整性。也就是说，应用了正确的哈希迭代次数，从而保证签名既准确又安全。</p><p>没有校验和，这种方案是很容易被攻击的。攻击者可以很容易替换掉消息碎片，并在没有私钥的情况下创建出有效的签名。缺乏校验和也可能导致不完整验证，让替换或截短的消息也被当成是签过名的。</p><h2 id="BitVM-和-BitVMX：Lamport-签名和-Winternitz-签名闪耀的地方"><a href="#BitVM-和-BitVMX：Lamport-签名和-Winternitz-签名闪耀的地方" class="headerlink" title="BitVM 和 BitVMX：Lamport 签名和 Winternitz 签名闪耀的地方"></a>BitVM 和 BitVMX：Lamport 签名和 Winternitz 签名闪耀的地方</h2><p>我们已经提到，BitVM 和 BitVMX 是为了将任意链外计算的乐观验证带给比特币网络而设计的框架。两者都能使用 Lamport 签名或 Winternitz 签名来创建健壮的数据承诺。在这个语境下，一个承诺是特定的一段数据在某个时间点已经存在、被安全记录、且签过名的密码学保证。这些承诺可以在未来验证者的挑战中被引用。这些签名的使用，保证了每一个承诺都是可以验证并且抗篡改的。</p><p>如果验证者同意操作者，那就不需要做什么，操作就会正常处理；但如果验证者不同意操作者，因为双方都曾公开签名这些承诺，所以协议允许双方使用对方的信息来证明对方尝试欺诈或正在执行错误的操作。</p><p>BitVM 带来的一项关键创新是能够跨越多笔交易而保持和引用状态。这是通过使用一次性签名来承诺每一步骤时刻的状态来实现的。通过利用 Lamport 签名，BitVM 保证了每一次状态转换都得到了安全的承诺，并且可以在后续操作中可靠地引用。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Lamport 签名和 Winternitz 签名有一系列好的属性，使它们适合在 BitVM 和 BitVMX 中使用。它们集成到这些协议中，极大地加强了比特币的脚本编程能力，带来了高效且安全的富状态操作。它们在数据承诺中的用法，保证了网络可以处理更加复杂的交易但保持安全性和性能。这些密码学技术，是比特币未来的关键，因为它们为更加高级和安全的去中心化应用（比如信任最小化的侧链桥、乐观验证的零知识证据）铺平了道路。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">BitVM 带来的一项关键创新是能够跨越多笔交易而保持和引用状态</summary>
    
    
    
    
    <category term="哈希签名" scheme="https://www.btcstudy.org/tags/%E5%93%88%E5%B8%8C%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>为什么客户端验证的闪电通道没你想的那么难</title>
    <link href="https://www.btcstudy.org/2026/01/26/fake-channels-and-rgb-lightning/"/>
    <id>https://www.btcstudy.org/2026/01/26/fake-channels-and-rgb-lightning/</id>
    <published>2026-01-26T08:20:52.000Z</published>
    <updated>2026-02-28T07:32:23.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Peter Todd</em></p><p><em>来源：<a href="https://petertodd.org/2025/fake-channels-and-rgb-lightning">https://petertodd.org/2025/fake-channels-and-rgb-lightning</a></em></p></blockquote><p>关于闪电网络协议，一个反直觉的事情是：转发你的支付的路径上的中间通道，没必要是 “真的” 通道。如果 Alice 想要给 David 支付比特币，通过路径  Alice ↔ Bob ↔ Charlie ↔ David ，那么无论 Bob 与 Charlie 之间的闪电通道是真的 —— 锁定了比特币的真实通道 —— 还是假的，都不重要！实际上，对 Alice 来说，甚至连 David 收到的是不是比特币也不重要。对她来说重要的是，David 接受了支付（揭晓了原像）；如果他不揭晓原像，Alice 绝不会平白无故付钱给他。</p><p>同样地，如果是 Alice 要从 David 这里 <em>接收</em> 比特币支付，通过 David ↔ Charlie ↔ Bob ↔ Alice 路径，那么 Alice 也不在乎 David 支付给 Charlie 的是不是真的比特币，Charlie 给 Bob 是什么也不重要。她关心的只是 —— 无论如何，Bob 已被说服，要发送真正的比特币给她。</p><p>现有的闪电网络协议确实保证了公开的通道对应于有效的 UTXO 。但这样做的 <em>理由</em> 仅仅是为了对抗 DoS 攻击：一定要有 <em>某些</em> 方法来限制人们可以广播的通道数量。将闪电通道 UTXO 与 gossip 公告绑定，恰好是我们（当前）选择的办法。</p><h2 id="使用客户端验证-token-的闪电通道"><a href="#使用客户端验证-token-的闪电通道" class="headerlink" title="使用客户端验证 token 的闪电通道"></a>使用客户端验证 token 的闪电通道</h2><p>闪电支付可以通过公开的 “假通道” 来安全地路由，这个事实，对于建立在比特币之上的闪电网络，一直只是个理论话题。它曾被当成一种在相互信任的双方之间建立通道时降低流动性要求的方法。但这样的想法从未实现过。</p><p>然而，对于建立客户端验证的 token 上的闪电通道来说，那就大大不同了。</p><p>回顾一下，客户端验证的 token 使用 “<a href="https://rgb.tech/">RGB</a>” 这样的协议、将比特币网络当成一种纯粹的抗重复花费机制：比特币协议只是用来保证给定的一个钱币只有一份历史。而这份历史的 <em>有效性</em> 是由客户端（用户自己）验证的。因此，如果 Alice 想给 Bob 一个代表 1 美元的前保持（基于 RGB 协议），她只需说服 Bob 这个钱币是真实的，办法是给 Bob 这个钱币的完整历史（从创建她手上这个钱币的交易，一路追溯到其创世输出）。</p><p>因为这个历史并不是全局的，客户端验证具有极大的可扩展性潜能。我曾经在<a href="https://petertodd.org/2017/scalable-single-use-seal-asset-transfer">这篇博</a>客中解释过，一种客户端验证的 token 可以用字面意义上每秒数十亿笔交易的总吞吐量。但是，这些交易依然是一种链内交易，也就是依然需要时间来确认；而闪电交易可以是近乎即时的。</p><p>因此，RGB 和 “Taproot Assets” 都在开发交易客户端验证 token 的闪电通道。</p><p>这就回到了 “假” 通道的问题：虽然可能需要几 MB 的交易数据来证明你手上的一个 RGB token 是真实地，如果你将这个 token 用在一条闪电通道中，你 <em>不需要</em> 知道任何其他人的闪电通道中的 RGB token 是不是真实的！只要有证据证明你的通道是真实地、完全自主保管地，就够了；如果其他人被骗去接受假的钱币，那也不是你的问题。</p><h2 id="Taproot-Asset-“宇宙”"><a href="#Taproot-Asset-“宇宙”" class="headerlink" title="Taproot Asset “宇宙”"></a>Taproot Asset “宇宙”</h2><p>这就带来了一个有趣的问题：Taproot Asset 协议中的 “资产宇宙（<a href="https://github.com/Roasbeef/bips/blob/bd3cdc153beaa901f26ef6504ea89e8f5e00b921/bip-tap.mediawiki#user-content-Asset_Universes">Universes</a>）”，真是必要的吗？这一设计背后的想法是，轻客户端将 —— 不是自己验证，而是 —— 信任第三方 “宇宙” 来为他们想要交易的资产执行钱币验证。这些宇宙，被预期知晓一种资产的所有交易（最起码是绝大部分的交易），并且会创建巨大的、签过名的默克尔树，来承诺给定一个区块高度时刻的所有有效钱币。</p><p>如果标准的 “轻” 钱包只使用闪电通道，只需下载几 MB 的数据，就能完全客户端验证自己的钱币，而无需依赖任何第三方。因为中间的闪电通道是否真实并不重要，请客户端甚至可以基于 gossip 消息，自行构造路线（例如，使用一种稀缺性证据的抗 DoS 机制）。</p><p>（完）</p>]]></content>
    
    
    <summary type="html">以最少的信息利用一个网络</summary>
    
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/categories/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="闪电网络" scheme="https://www.btcstudy.org/tags/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Bitcoin Core v30.0 及 v30.1 在钱包迁移中可能出现误删除错误</title>
    <link href="https://www.btcstudy.org/2026/01/26/wallet-migration-failure-may-delete-unrelated-wallet-files-in-bitcoin-core-30-0-and-30-1/"/>
    <id>https://www.btcstudy.org/2026/01/26/wallet-migration-failure-may-delete-unrelated-wallet-files-in-bitcoin-core-30-0-and-30-1/</id>
    <published>2026-01-26T07:26:03.000Z</published>
    <updated>2026-02-28T07:32:23.275Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>作者：Bitcoin Core</em></p><p><em>来源：<a href="https://bitcoincore.org/en/2026/01/05/wallet-migration-bug/">https://bitcoincore.org/en/2026/01/05/wallet-migration-bug/</a></em></p></blockquote><blockquote><p>编者注：<code>Bitcoin Core</code> 软件一直有一个内置的钱包模块。从 v30.0 版本开始，<code>Bitcoin Core</code> 不再支持在旧版本的 <code>Bitcoin Core</code> 中创建的 “传统钱包（Legacy wallets）”，而只支持 “描述符钱包（descriptor wallets）”；用户需要将传统钱包迁移为描述符钱包，才能在 <code>Bitcoin Core</code> 中继续使用。</p><p>本公告提到的严重故障，正是在 v30.0 及 v30.1 版本中使用钱包迁移功能时出现的，为此，用户应绝对避免在这两个版本中使用钱包迁移功能，要么使用更老的版本，要么使用更新的版本。</p><ul><li>公告中提到的 v30.2 版本已经放出，可在此处下载：<a href="https://bitcoincore.org/en/download">https://bitcoincore.org/en/download</a></li><li>关于传统钱包迁移为描述符钱包的指南，见此处：<a href="https://www.btcstudy.org/2025/11/05/bitcoin-core-document-managing-the-wallet/">https://www.btcstudy.org/2025/11/05/bitcoin-core-document-managing-the-wallet/</a></li></ul></blockquote><p>我们已经注意到了，<code>Bitcoin Core</code> 30.0 及 30.1 版本中引入了一个钱包迁移故障。在罕见的情况下，当一个钱包 <code>.dat</code> 文件迁移失败时，程序可能会删除整个钱包文件夹，从而有可能导致资金损失。修复措施即将到来，将在 30.2 版本中发布。但出于充分的谨慎，我们已经从 bitcoincore.org 下载页面中移除了受影响的版本的二进制文件。</p><p>此刻，我们请求用户不要使用图形界面（GUI）以及命令行调用（RPC）来尝试钱包迁移，应该等待 30.2 版本的发布。所有其他用户，包括已在软件内建立钱包的用户，不受此故障影响，可以继续使用已有的版本。</p><p>具体来说，该故障发生的前提是有一个默认的（未命名的）钱包 <code>.dat</code> 文件 —— 从 0.21 版本（5 年前发行）开始，<code>Bitcoin Core</code> 就不再默认创建这样的钱包文件了 —— 并且该文件在迁移或加载中失败。可能触发此故障的其中一个条件是打开了区块修剪功能（pruning），并且在修剪正在发生的时候弹出（unload）钱包了。</p>]]></content>
    
    
    <summary type="html">严重故障</summary>
    
    
    
    
    <category term="尽责披露" scheme="https://www.btcstudy.org/tags/%E5%B0%BD%E8%B4%A3%E6%8A%AB%E9%9C%B2/"/>
    
  </entry>
  
</feed>
