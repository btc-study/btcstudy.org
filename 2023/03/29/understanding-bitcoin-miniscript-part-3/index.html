<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><title>理解比特币 Miniscript（三）：解析与分析</title><meta name=keywords content="比特币, 中本聪, 比特币区块链, 闪电网络, 比特币 layer 2, 健全货币, 密码货币, 密码朋克, 学习比特币, BTC, BTC Study, Bitcoin, bitcoin, proof of work"><meta name=description content=比特币思想的中文集结地><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1,initial-scale=1"><link rel=icon href=/favicon.ico><link rel=stylesheet href="/style/common/bulma.css?v=1682773100887"><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href="/style/common/iconfont.css?v=1682773100887"><link rel=stylesheet href="/style/base.css?v=1682773100887"><link rel=stylesheet href="/style/common/helper.css?v=1682773100887"><link rel=stylesheet href="/style/themes/animation.css?v=1682773100887"><script>function ready(){var e=document.querySelector(".body-container"),t=localStorage.getItem("theme")||"light";["light","dark"].includes(t)||(t="light",localStorage.setItem("theme","light")),e.classList.remove("appearance-auto"),e.classList.add("appearance-"+t),quickInitialTheme()}function quickInitialTheme(){var e=localStorage.getItem("theme")||"light",t=document.querySelector(".logo-light"),o=document.querySelector(".logo-dark"),d=document.querySelector("#mobile-header-logo > .logo-light"),l=document.querySelector("#mobile-header-logo > .logo-dark"),a=document.getElementById("theme-btn"),i=document.querySelector(".slide-theme-light"),c=document.querySelector(".slide-theme-dark");document.body.classList.add(e),("dark"===e?(t.classList.add("hidden"),o.classList.remove("hidden"),d.classList.add("hidden"),l.classList.remove("hidden"),a.classList.remove("icon-icon_dark"),a.classList.add("icon-icon_light"),i):c).classList.remove("hidden")}document.addEventListener("DOMContentLoaded",ready)</script><script src="/js/common.js?v=1682773100887"></script><script src=/js/libs/zepto.min.js></script><link rel=stylesheet href="/style/post.css?v=1682773100887"><link rel=stylesheet href="/style/themes/highlight.css?v=1682773100887"><meta name=generator content="Hexo 6.3.0"><link rel=alternate href=/atom.xml title="BTC Study" type=application/atom+xml></head><body class="is-flex is-flex-direction-column" onload=initialTheme()><div class=clip></div><div class="body-container appearance-auto"><header class="header-widget is-hidden-mobile is-flex is-flex-shrink-0 is-align-items-center is-justify-content-center" id=header><div class="is-flex header-widget-container is-flex-shrink-0 is-align-items-center"><section class="is-hidden-mobile is-flex-shrink-0"><h1><a href=/ ><svg class=logo-light width=125px height=23px viewBox="0 0 125 23" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><title>BTCStudy</title><g id=页面-1 stroke=none stroke-width=1 fill=none fill-rule=evenodd><g id=首页-响应式 transform="translate(-249.000000, -23.000000)" fill-rule=nonzero><g id=BTCStudy transform="translate(249.680000, 23.192000)"><path d="M9.072,17.808 C11.312,17.808 13.024,17.408 14.208,16.608 C15.392,15.808 15.984,14.672 15.984,13.2 C15.984,12.192 15.712,11.332 15.168,10.62 C14.624,9.908 13.872,9.384 12.912,9.048 C13.632,8.68 14.188,8.18 14.58,7.548 C14.972,6.916 15.168,6.2 15.168,5.4 C15.168,4.056 14.608,2.988 13.488,2.196 C12.368,1.404 10.736,1.008 8.592,1.008 L8.592,1.008 L-5.68434189e-14,1.008 L-5.68434189e-14,17.808 L9.072,17.808 Z M7.968,7.68 L4.704,7.68 L4.704,4.44 L7.968,4.44 C9.568,4.44 10.368,4.976 10.368,6.048 C10.368,7.136 9.568,7.68 7.968,7.68 L7.968,7.68 Z M8.688,14.376 L4.704,14.376 L4.704,10.968 L8.688,10.968 C10.352,10.968 11.184,11.536 11.184,12.672 C11.184,13.808 10.352,14.376 8.688,14.376 L8.688,14.376 Z M26.544,17.808 L26.544,4.776 L31.68,4.776 L31.68,1.008 L16.632,1.008 L16.632,4.776 L21.792,4.776 L21.792,17.808 L26.544,17.808 Z M41.592,18.144 C43.128,18.144 44.512,17.872 45.744,17.328 C46.976,16.784 48,16 48.816,14.976 L48.816,14.976 L45.792,12.24 C44.704,13.552 43.384,14.208 41.832,14.208 C40.92,14.208 40.108,14.008 39.396,13.608 C38.684,13.208 38.132,12.644 37.74,11.916 C37.348,11.188 37.152,10.352 37.152,9.408 C37.152,8.464 37.348,7.628 37.74,6.9 C38.132,6.172 38.684,5.608 39.396,5.208 C40.108,4.808 40.92,4.608 41.832,4.608 C43.384,4.608 44.704,5.264 45.792,6.576 L45.792,6.576 L48.816,3.84 C48,2.816 46.976,2.032 45.744,1.488 C44.512,0.944 43.128,0.672 41.592,0.672 C39.832,0.672 38.252,1.044 36.852,1.788 C35.452,2.532 34.352,3.568 33.552,4.896 C32.752,6.224 32.352,7.728 32.352,9.408 C32.352,11.088 32.752,12.592 33.552,13.92 C34.352,15.248 35.452,16.284 36.852,17.028 C38.252,17.772 39.832,18.144 41.592,18.144 Z" id=BTC fill=#F2A900></path><path d="M56.64,18.144 C58.24,18.144 59.6,17.9 60.72,17.412 C61.84,16.924 62.68,16.272 63.24,15.456 C63.8,14.64 64.08,13.728 64.08,12.72 C64.08,11.552 63.772,10.628 63.156,9.948 C62.54,9.268 61.812,8.772 60.972,8.46 C60.132,8.148 59.072,7.856 57.792,7.584 C56.656,7.344 55.832,7.112 55.32,6.888 C54.808,6.664 54.552,6.328 54.552,5.88 C54.552,5.432 54.768,5.068 55.2,4.788 C55.632,4.508 56.32,4.368 57.264,4.368 C58.768,4.368 60.32,4.8 61.92,5.664 L61.92,5.664 L63.384,2.136 C62.568,1.656 61.624,1.292 60.552,1.044 C59.48,0.796 58.392,0.672 57.288,0.672 C55.672,0.672 54.308,0.912 53.196,1.392 C52.084,1.872 51.248,2.524 50.688,3.348 C50.128,4.172 49.848,5.096 49.848,6.12 C49.848,7.288 50.152,8.216 50.76,8.904 C51.368,9.592 52.096,10.092 52.944,10.404 C53.792,10.716 54.848,11.008 56.112,11.28 C57.264,11.536 58.1,11.78 58.62,12.012 C59.14,12.244 59.4,12.6 59.4,13.08 C59.4,13.992 58.488,14.448 56.664,14.448 C55.704,14.448 54.728,14.296 53.736,13.992 C52.744,13.688 51.872,13.288 51.12,12.792 L51.12,12.792 L49.56,16.296 C50.36,16.856 51.4,17.304 52.68,17.64 C53.96,17.976 55.28,18.144 56.64,18.144 Z M71.856,18.024 C72.48,18.024 73.068,17.96 73.62,17.832 C74.172,17.704 74.64,17.52 75.024,17.28 L75.024,17.28 L73.896,14.088 C73.496,14.36 73.032,14.496 72.504,14.496 C72.088,14.496 71.756,14.364 71.508,14.1 C71.26,13.836 71.136,13.472 71.136,13.008 L71.136,13.008 L71.136,8.688 L74.112,8.688 L74.112,5.28 L71.136,5.28 L71.136,1.896 L66.576,1.896 L66.576,5.28 L64.68,5.28 L64.68,8.688 L66.576,8.688 L66.576,13.056 C66.576,14.704 67.032,15.944 67.944,16.776 C68.856,17.608 70.16,18.024 71.856,18.024 Z M82.248,18.024 C83,18.024 83.712,17.888 84.384,17.616 C85.056,17.344 85.632,16.944 86.112,16.416 L86.112,16.416 L86.112,17.808 L90.456,17.808 L90.456,4.8 L85.896,4.8 L85.896,11.064 C85.896,12.104 85.668,12.876 85.212,13.38 C84.756,13.884 84.168,14.136 83.448,14.136 C82.744,14.136 82.208,13.912 81.84,13.464 C81.472,13.016 81.288,12.304 81.288,11.328 L81.288,11.328 L81.288,4.8 L76.728,4.8 L76.728,12.072 C76.728,14.056 77.228,15.544 78.228,16.536 C79.228,17.528 80.568,18.024 82.248,18.024 Z M99.048,18.024 C100.744,18.024 102.016,17.52 102.864,16.512 L102.864,16.512 L102.864,17.808 L107.208,17.808 L107.208,0 L102.648,0 L102.648,5.928 C101.8,5.032 100.6,4.584 99.048,4.584 C97.864,4.584 96.784,4.856 95.808,5.4 C94.832,5.944 94.06,6.724 93.492,7.74 C92.924,8.756 92.64,9.936 92.64,11.28 C92.64,12.624 92.924,13.808 93.492,14.832 C94.06,15.856 94.832,16.644 95.808,17.196 C96.784,17.748 97.864,18.024 99.048,18.024 Z M100.008,14.4 C99.208,14.4 98.552,14.124 98.04,13.572 C97.528,13.02 97.272,12.256 97.272,11.28 C97.272,10.32 97.528,9.568 98.04,9.024 C98.552,8.48 99.208,8.208 100.008,8.208 C100.808,8.208 101.46,8.48 101.964,9.024 C102.468,9.568 102.72,10.32 102.72,11.28 C102.72,12.256 102.464,13.02 101.952,13.572 C101.44,14.124 100.792,14.4 100.008,14.4 Z M112.368,22.68 C113.728,22.68 114.88,22.356 115.824,21.708 C116.768,21.06 117.568,19.936 118.224,18.336 L118.224,18.336 L123.84,4.8 L119.496,4.8 L116.28,12.744 L113.088,4.8 L108.408,4.8 L113.976,17.976 C113.784,18.36 113.548,18.64 113.268,18.816 C112.988,18.992 112.632,19.08 112.2,19.08 C111.832,19.08 111.468,19.012 111.108,18.876 C110.748,18.74 110.44,18.552 110.184,18.312 L110.184,18.312 L108.6,21.504 C109.032,21.856 109.596,22.14 110.292,22.356 C110.988,22.572 111.68,22.68 112.368,22.68 Z" id=Study fill-opacity=0.85 fill=#000000></path></g></g></g></svg><svg class="logo-dark hidden" width=125px height=23px viewBox="0 0 125 23" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><title>BTCStudy</title><g id=页面-1 stroke=none stroke-width=1 fill=none fill-rule=evenodd><g id=首页-响应式 transform="translate(-249.000000, -23.000000)" fill-rule=nonzero><g id=BTCStudy transform="translate(249.680000, 23.192000)"><path d="M9.072,17.808 C11.312,17.808 13.024,17.408 14.208,16.608 C15.392,15.808 15.984,14.672 15.984,13.2 C15.984,12.192 15.712,11.332 15.168,10.62 C14.624,9.908 13.872,9.384 12.912,9.048 C13.632,8.68 14.188,8.18 14.58,7.548 C14.972,6.916 15.168,6.2 15.168,5.4 C15.168,4.056 14.608,2.988 13.488,2.196 C12.368,1.404 10.736,1.008 8.592,1.008 L8.592,1.008 L-5.68434189e-14,1.008 L-5.68434189e-14,17.808 L9.072,17.808 Z M7.968,7.68 L4.704,7.68 L4.704,4.44 L7.968,4.44 C9.568,4.44 10.368,4.976 10.368,6.048 C10.368,7.136 9.568,7.68 7.968,7.68 L7.968,7.68 Z M8.688,14.376 L4.704,14.376 L4.704,10.968 L8.688,10.968 C10.352,10.968 11.184,11.536 11.184,12.672 C11.184,13.808 10.352,14.376 8.688,14.376 L8.688,14.376 Z M26.544,17.808 L26.544,4.776 L31.68,4.776 L31.68,1.008 L16.632,1.008 L16.632,4.776 L21.792,4.776 L21.792,17.808 L26.544,17.808 Z M41.592,18.144 C43.128,18.144 44.512,17.872 45.744,17.328 C46.976,16.784 48,16 48.816,14.976 L48.816,14.976 L45.792,12.24 C44.704,13.552 43.384,14.208 41.832,14.208 C40.92,14.208 40.108,14.008 39.396,13.608 C38.684,13.208 38.132,12.644 37.74,11.916 C37.348,11.188 37.152,10.352 37.152,9.408 C37.152,8.464 37.348,7.628 37.74,6.9 C38.132,6.172 38.684,5.608 39.396,5.208 C40.108,4.808 40.92,4.608 41.832,4.608 C43.384,4.608 44.704,5.264 45.792,6.576 L45.792,6.576 L48.816,3.84 C48,2.816 46.976,2.032 45.744,1.488 C44.512,0.944 43.128,0.672 41.592,0.672 C39.832,0.672 38.252,1.044 36.852,1.788 C35.452,2.532 34.352,3.568 33.552,4.896 C32.752,6.224 32.352,7.728 32.352,9.408 C32.352,11.088 32.752,12.592 33.552,13.92 C34.352,15.248 35.452,16.284 36.852,17.028 C38.252,17.772 39.832,18.144 41.592,18.144 Z" id=BTC fill=#F2A900></path><path d="M56.64,18.144 C58.24,18.144 59.6,17.9 60.72,17.412 C61.84,16.924 62.68,16.272 63.24,15.456 C63.8,14.64 64.08,13.728 64.08,12.72 C64.08,11.552 63.772,10.628 63.156,9.948 C62.54,9.268 61.812,8.772 60.972,8.46 C60.132,8.148 59.072,7.856 57.792,7.584 C56.656,7.344 55.832,7.112 55.32,6.888 C54.808,6.664 54.552,6.328 54.552,5.88 C54.552,5.432 54.768,5.068 55.2,4.788 C55.632,4.508 56.32,4.368 57.264,4.368 C58.768,4.368 60.32,4.8 61.92,5.664 L61.92,5.664 L63.384,2.136 C62.568,1.656 61.624,1.292 60.552,1.044 C59.48,0.796 58.392,0.672 57.288,0.672 C55.672,0.672 54.308,0.912 53.196,1.392 C52.084,1.872 51.248,2.524 50.688,3.348 C50.128,4.172 49.848,5.096 49.848,6.12 C49.848,7.288 50.152,8.216 50.76,8.904 C51.368,9.592 52.096,10.092 52.944,10.404 C53.792,10.716 54.848,11.008 56.112,11.28 C57.264,11.536 58.1,11.78 58.62,12.012 C59.14,12.244 59.4,12.6 59.4,13.08 C59.4,13.992 58.488,14.448 56.664,14.448 C55.704,14.448 54.728,14.296 53.736,13.992 C52.744,13.688 51.872,13.288 51.12,12.792 L51.12,12.792 L49.56,16.296 C50.36,16.856 51.4,17.304 52.68,17.64 C53.96,17.976 55.28,18.144 56.64,18.144 Z M71.856,18.024 C72.48,18.024 73.068,17.96 73.62,17.832 C74.172,17.704 74.64,17.52 75.024,17.28 L75.024,17.28 L73.896,14.088 C73.496,14.36 73.032,14.496 72.504,14.496 C72.088,14.496 71.756,14.364 71.508,14.1 C71.26,13.836 71.136,13.472 71.136,13.008 L71.136,13.008 L71.136,8.688 L74.112,8.688 L74.112,5.28 L71.136,5.28 L71.136,1.896 L66.576,1.896 L66.576,5.28 L64.68,5.28 L64.68,8.688 L66.576,8.688 L66.576,13.056 C66.576,14.704 67.032,15.944 67.944,16.776 C68.856,17.608 70.16,18.024 71.856,18.024 Z M82.248,18.024 C83,18.024 83.712,17.888 84.384,17.616 C85.056,17.344 85.632,16.944 86.112,16.416 L86.112,16.416 L86.112,17.808 L90.456,17.808 L90.456,4.8 L85.896,4.8 L85.896,11.064 C85.896,12.104 85.668,12.876 85.212,13.38 C84.756,13.884 84.168,14.136 83.448,14.136 C82.744,14.136 82.208,13.912 81.84,13.464 C81.472,13.016 81.288,12.304 81.288,11.328 L81.288,11.328 L81.288,4.8 L76.728,4.8 L76.728,12.072 C76.728,14.056 77.228,15.544 78.228,16.536 C79.228,17.528 80.568,18.024 82.248,18.024 Z M99.048,18.024 C100.744,18.024 102.016,17.52 102.864,16.512 L102.864,16.512 L102.864,17.808 L107.208,17.808 L107.208,0 L102.648,0 L102.648,5.928 C101.8,5.032 100.6,4.584 99.048,4.584 C97.864,4.584 96.784,4.856 95.808,5.4 C94.832,5.944 94.06,6.724 93.492,7.74 C92.924,8.756 92.64,9.936 92.64,11.28 C92.64,12.624 92.924,13.808 93.492,14.832 C94.06,15.856 94.832,16.644 95.808,17.196 C96.784,17.748 97.864,18.024 99.048,18.024 Z M100.008,14.4 C99.208,14.4 98.552,14.124 98.04,13.572 C97.528,13.02 97.272,12.256 97.272,11.28 C97.272,10.32 97.528,9.568 98.04,9.024 C98.552,8.48 99.208,8.208 100.008,8.208 C100.808,8.208 101.46,8.48 101.964,9.024 C102.468,9.568 102.72,10.32 102.72,11.28 C102.72,12.256 102.464,13.02 101.952,13.572 C101.44,14.124 100.792,14.4 100.008,14.4 Z M112.368,22.68 C113.728,22.68 114.88,22.356 115.824,21.708 C116.768,21.06 117.568,19.936 118.224,18.336 L118.224,18.336 L123.84,4.8 L119.496,4.8 L116.28,12.744 L113.088,4.8 L108.408,4.8 L113.976,17.976 C113.784,18.36 113.548,18.64 113.268,18.816 C112.988,18.992 112.632,19.08 112.2,19.08 C111.832,19.08 111.468,19.012 111.108,18.876 C110.748,18.74 110.44,18.552 110.184,18.312 L110.184,18.312 L108.6,21.504 C109.032,21.856 109.596,22.14 110.292,22.356 C110.988,22.572 111.68,22.68 112.368,22.68 Z" id=Study fill-opacity=0.85 fill=#FFFFFF></path></g></g></g></svg></a></h1></section><div class="is-flex is-flex-direction-column header-menu-wrap"><aside class="is-flex-shrink-0 is-flex is-flex-direction-row is-align-items-center" id=header-menu><a class="is-inline-block header-activity mr-4" href=/ >首页</a><a class="is-inline-block mr-4" href=/archives>全站目录</a><a class="is-inline-block mr-4" href=/tags>标签</a><a class="is-inline-block mr-4" href=/maps>地图</a><a class="is-inline-block mr-4" href=/mempool>mempool</a><a class="is-inline-block mr-4" target=_blank rel=noopener href=https://123btc.org/ >123btc</a><div class="right-content is-flex is-flex-direction-row is-align-items-center"><div class="size-wrap mr-1"><i class="iconfont icon-a-bianzu5" id=change-size-btn></i><div class=size-input-wrap><div class=input-wrap><input id=size-change-input type=range min=12 max=32 step=2></div></div></div><i class="iconfont icon-icon_dark mr-1" id=theme-btn></i><div class=search-wrap><input class=pl-3 id=search-input placeholder=请输入搜索关键词><i class="iconfont icon-icon_search" id=search-input-btn></i></div></div></aside><div class="header-title is-hidden-mobile is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height hidden" id=postTopic><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">理解比特币 Miniscript（三）：解析与分析</p><div class="size-wrap mr-1"><i class="iconfont icon-a-bianzu5" id=change-size-btn2></i><div class=size-input-wrap><div class=input-wrap><input id=size-change-input2 type=range min=12 max=32 step=2></div></div></div></div></div></div></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-space-between is-hidden-tablet" id=mobile-header><div class="is-flex is-flex-direction-row is-align-items-center"><i class="iconfont icon-icon_bar mobile-header-menu"></i><div id=mobile-header-logo><svg class=logo-light width=125px height=23px viewBox="0 0 125 23" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><title>BTCStudy</title><g id=页面-1 stroke=none stroke-width=1 fill=none fill-rule=evenodd><g id=首页-响应式 transform="translate(-249.000000, -23.000000)" fill-rule=nonzero><g id=BTCStudy transform="translate(249.680000, 23.192000)"><path d="M9.072,17.808 C11.312,17.808 13.024,17.408 14.208,16.608 C15.392,15.808 15.984,14.672 15.984,13.2 C15.984,12.192 15.712,11.332 15.168,10.62 C14.624,9.908 13.872,9.384 12.912,9.048 C13.632,8.68 14.188,8.18 14.58,7.548 C14.972,6.916 15.168,6.2 15.168,5.4 C15.168,4.056 14.608,2.988 13.488,2.196 C12.368,1.404 10.736,1.008 8.592,1.008 L8.592,1.008 L-5.68434189e-14,1.008 L-5.68434189e-14,17.808 L9.072,17.808 Z M7.968,7.68 L4.704,7.68 L4.704,4.44 L7.968,4.44 C9.568,4.44 10.368,4.976 10.368,6.048 C10.368,7.136 9.568,7.68 7.968,7.68 L7.968,7.68 Z M8.688,14.376 L4.704,14.376 L4.704,10.968 L8.688,10.968 C10.352,10.968 11.184,11.536 11.184,12.672 C11.184,13.808 10.352,14.376 8.688,14.376 L8.688,14.376 Z M26.544,17.808 L26.544,4.776 L31.68,4.776 L31.68,1.008 L16.632,1.008 L16.632,4.776 L21.792,4.776 L21.792,17.808 L26.544,17.808 Z M41.592,18.144 C43.128,18.144 44.512,17.872 45.744,17.328 C46.976,16.784 48,16 48.816,14.976 L48.816,14.976 L45.792,12.24 C44.704,13.552 43.384,14.208 41.832,14.208 C40.92,14.208 40.108,14.008 39.396,13.608 C38.684,13.208 38.132,12.644 37.74,11.916 C37.348,11.188 37.152,10.352 37.152,9.408 C37.152,8.464 37.348,7.628 37.74,6.9 C38.132,6.172 38.684,5.608 39.396,5.208 C40.108,4.808 40.92,4.608 41.832,4.608 C43.384,4.608 44.704,5.264 45.792,6.576 L45.792,6.576 L48.816,3.84 C48,2.816 46.976,2.032 45.744,1.488 C44.512,0.944 43.128,0.672 41.592,0.672 C39.832,0.672 38.252,1.044 36.852,1.788 C35.452,2.532 34.352,3.568 33.552,4.896 C32.752,6.224 32.352,7.728 32.352,9.408 C32.352,11.088 32.752,12.592 33.552,13.92 C34.352,15.248 35.452,16.284 36.852,17.028 C38.252,17.772 39.832,18.144 41.592,18.144 Z" id=BTC fill=#F2A900></path><path d="M56.64,18.144 C58.24,18.144 59.6,17.9 60.72,17.412 C61.84,16.924 62.68,16.272 63.24,15.456 C63.8,14.64 64.08,13.728 64.08,12.72 C64.08,11.552 63.772,10.628 63.156,9.948 C62.54,9.268 61.812,8.772 60.972,8.46 C60.132,8.148 59.072,7.856 57.792,7.584 C56.656,7.344 55.832,7.112 55.32,6.888 C54.808,6.664 54.552,6.328 54.552,5.88 C54.552,5.432 54.768,5.068 55.2,4.788 C55.632,4.508 56.32,4.368 57.264,4.368 C58.768,4.368 60.32,4.8 61.92,5.664 L61.92,5.664 L63.384,2.136 C62.568,1.656 61.624,1.292 60.552,1.044 C59.48,0.796 58.392,0.672 57.288,0.672 C55.672,0.672 54.308,0.912 53.196,1.392 C52.084,1.872 51.248,2.524 50.688,3.348 C50.128,4.172 49.848,5.096 49.848,6.12 C49.848,7.288 50.152,8.216 50.76,8.904 C51.368,9.592 52.096,10.092 52.944,10.404 C53.792,10.716 54.848,11.008 56.112,11.28 C57.264,11.536 58.1,11.78 58.62,12.012 C59.14,12.244 59.4,12.6 59.4,13.08 C59.4,13.992 58.488,14.448 56.664,14.448 C55.704,14.448 54.728,14.296 53.736,13.992 C52.744,13.688 51.872,13.288 51.12,12.792 L51.12,12.792 L49.56,16.296 C50.36,16.856 51.4,17.304 52.68,17.64 C53.96,17.976 55.28,18.144 56.64,18.144 Z M71.856,18.024 C72.48,18.024 73.068,17.96 73.62,17.832 C74.172,17.704 74.64,17.52 75.024,17.28 L75.024,17.28 L73.896,14.088 C73.496,14.36 73.032,14.496 72.504,14.496 C72.088,14.496 71.756,14.364 71.508,14.1 C71.26,13.836 71.136,13.472 71.136,13.008 L71.136,13.008 L71.136,8.688 L74.112,8.688 L74.112,5.28 L71.136,5.28 L71.136,1.896 L66.576,1.896 L66.576,5.28 L64.68,5.28 L64.68,8.688 L66.576,8.688 L66.576,13.056 C66.576,14.704 67.032,15.944 67.944,16.776 C68.856,17.608 70.16,18.024 71.856,18.024 Z M82.248,18.024 C83,18.024 83.712,17.888 84.384,17.616 C85.056,17.344 85.632,16.944 86.112,16.416 L86.112,16.416 L86.112,17.808 L90.456,17.808 L90.456,4.8 L85.896,4.8 L85.896,11.064 C85.896,12.104 85.668,12.876 85.212,13.38 C84.756,13.884 84.168,14.136 83.448,14.136 C82.744,14.136 82.208,13.912 81.84,13.464 C81.472,13.016 81.288,12.304 81.288,11.328 L81.288,11.328 L81.288,4.8 L76.728,4.8 L76.728,12.072 C76.728,14.056 77.228,15.544 78.228,16.536 C79.228,17.528 80.568,18.024 82.248,18.024 Z M99.048,18.024 C100.744,18.024 102.016,17.52 102.864,16.512 L102.864,16.512 L102.864,17.808 L107.208,17.808 L107.208,0 L102.648,0 L102.648,5.928 C101.8,5.032 100.6,4.584 99.048,4.584 C97.864,4.584 96.784,4.856 95.808,5.4 C94.832,5.944 94.06,6.724 93.492,7.74 C92.924,8.756 92.64,9.936 92.64,11.28 C92.64,12.624 92.924,13.808 93.492,14.832 C94.06,15.856 94.832,16.644 95.808,17.196 C96.784,17.748 97.864,18.024 99.048,18.024 Z M100.008,14.4 C99.208,14.4 98.552,14.124 98.04,13.572 C97.528,13.02 97.272,12.256 97.272,11.28 C97.272,10.32 97.528,9.568 98.04,9.024 C98.552,8.48 99.208,8.208 100.008,8.208 C100.808,8.208 101.46,8.48 101.964,9.024 C102.468,9.568 102.72,10.32 102.72,11.28 C102.72,12.256 102.464,13.02 101.952,13.572 C101.44,14.124 100.792,14.4 100.008,14.4 Z M112.368,22.68 C113.728,22.68 114.88,22.356 115.824,21.708 C116.768,21.06 117.568,19.936 118.224,18.336 L118.224,18.336 L123.84,4.8 L119.496,4.8 L116.28,12.744 L113.088,4.8 L108.408,4.8 L113.976,17.976 C113.784,18.36 113.548,18.64 113.268,18.816 C112.988,18.992 112.632,19.08 112.2,19.08 C111.832,19.08 111.468,19.012 111.108,18.876 C110.748,18.74 110.44,18.552 110.184,18.312 L110.184,18.312 L108.6,21.504 C109.032,21.856 109.596,22.14 110.292,22.356 C110.988,22.572 111.68,22.68 112.368,22.68 Z" id=Study fill-opacity=0.85 fill=#000000></path></g></g></g></svg><svg class="logo-dark hidden" width=125px height=23px viewBox="0 0 125 23" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><title>BTCStudy</title><g id=页面-1 stroke=none stroke-width=1 fill=none fill-rule=evenodd><g id=首页-响应式 transform="translate(-249.000000, -23.000000)" fill-rule=nonzero><g id=BTCStudy transform="translate(249.680000, 23.192000)"><path d="M9.072,17.808 C11.312,17.808 13.024,17.408 14.208,16.608 C15.392,15.808 15.984,14.672 15.984,13.2 C15.984,12.192 15.712,11.332 15.168,10.62 C14.624,9.908 13.872,9.384 12.912,9.048 C13.632,8.68 14.188,8.18 14.58,7.548 C14.972,6.916 15.168,6.2 15.168,5.4 C15.168,4.056 14.608,2.988 13.488,2.196 C12.368,1.404 10.736,1.008 8.592,1.008 L8.592,1.008 L-5.68434189e-14,1.008 L-5.68434189e-14,17.808 L9.072,17.808 Z M7.968,7.68 L4.704,7.68 L4.704,4.44 L7.968,4.44 C9.568,4.44 10.368,4.976 10.368,6.048 C10.368,7.136 9.568,7.68 7.968,7.68 L7.968,7.68 Z M8.688,14.376 L4.704,14.376 L4.704,10.968 L8.688,10.968 C10.352,10.968 11.184,11.536 11.184,12.672 C11.184,13.808 10.352,14.376 8.688,14.376 L8.688,14.376 Z M26.544,17.808 L26.544,4.776 L31.68,4.776 L31.68,1.008 L16.632,1.008 L16.632,4.776 L21.792,4.776 L21.792,17.808 L26.544,17.808 Z M41.592,18.144 C43.128,18.144 44.512,17.872 45.744,17.328 C46.976,16.784 48,16 48.816,14.976 L48.816,14.976 L45.792,12.24 C44.704,13.552 43.384,14.208 41.832,14.208 C40.92,14.208 40.108,14.008 39.396,13.608 C38.684,13.208 38.132,12.644 37.74,11.916 C37.348,11.188 37.152,10.352 37.152,9.408 C37.152,8.464 37.348,7.628 37.74,6.9 C38.132,6.172 38.684,5.608 39.396,5.208 C40.108,4.808 40.92,4.608 41.832,4.608 C43.384,4.608 44.704,5.264 45.792,6.576 L45.792,6.576 L48.816,3.84 C48,2.816 46.976,2.032 45.744,1.488 C44.512,0.944 43.128,0.672 41.592,0.672 C39.832,0.672 38.252,1.044 36.852,1.788 C35.452,2.532 34.352,3.568 33.552,4.896 C32.752,6.224 32.352,7.728 32.352,9.408 C32.352,11.088 32.752,12.592 33.552,13.92 C34.352,15.248 35.452,16.284 36.852,17.028 C38.252,17.772 39.832,18.144 41.592,18.144 Z" id=BTC fill=#F2A900></path><path d="M56.64,18.144 C58.24,18.144 59.6,17.9 60.72,17.412 C61.84,16.924 62.68,16.272 63.24,15.456 C63.8,14.64 64.08,13.728 64.08,12.72 C64.08,11.552 63.772,10.628 63.156,9.948 C62.54,9.268 61.812,8.772 60.972,8.46 C60.132,8.148 59.072,7.856 57.792,7.584 C56.656,7.344 55.832,7.112 55.32,6.888 C54.808,6.664 54.552,6.328 54.552,5.88 C54.552,5.432 54.768,5.068 55.2,4.788 C55.632,4.508 56.32,4.368 57.264,4.368 C58.768,4.368 60.32,4.8 61.92,5.664 L61.92,5.664 L63.384,2.136 C62.568,1.656 61.624,1.292 60.552,1.044 C59.48,0.796 58.392,0.672 57.288,0.672 C55.672,0.672 54.308,0.912 53.196,1.392 C52.084,1.872 51.248,2.524 50.688,3.348 C50.128,4.172 49.848,5.096 49.848,6.12 C49.848,7.288 50.152,8.216 50.76,8.904 C51.368,9.592 52.096,10.092 52.944,10.404 C53.792,10.716 54.848,11.008 56.112,11.28 C57.264,11.536 58.1,11.78 58.62,12.012 C59.14,12.244 59.4,12.6 59.4,13.08 C59.4,13.992 58.488,14.448 56.664,14.448 C55.704,14.448 54.728,14.296 53.736,13.992 C52.744,13.688 51.872,13.288 51.12,12.792 L51.12,12.792 L49.56,16.296 C50.36,16.856 51.4,17.304 52.68,17.64 C53.96,17.976 55.28,18.144 56.64,18.144 Z M71.856,18.024 C72.48,18.024 73.068,17.96 73.62,17.832 C74.172,17.704 74.64,17.52 75.024,17.28 L75.024,17.28 L73.896,14.088 C73.496,14.36 73.032,14.496 72.504,14.496 C72.088,14.496 71.756,14.364 71.508,14.1 C71.26,13.836 71.136,13.472 71.136,13.008 L71.136,13.008 L71.136,8.688 L74.112,8.688 L74.112,5.28 L71.136,5.28 L71.136,1.896 L66.576,1.896 L66.576,5.28 L64.68,5.28 L64.68,8.688 L66.576,8.688 L66.576,13.056 C66.576,14.704 67.032,15.944 67.944,16.776 C68.856,17.608 70.16,18.024 71.856,18.024 Z M82.248,18.024 C83,18.024 83.712,17.888 84.384,17.616 C85.056,17.344 85.632,16.944 86.112,16.416 L86.112,16.416 L86.112,17.808 L90.456,17.808 L90.456,4.8 L85.896,4.8 L85.896,11.064 C85.896,12.104 85.668,12.876 85.212,13.38 C84.756,13.884 84.168,14.136 83.448,14.136 C82.744,14.136 82.208,13.912 81.84,13.464 C81.472,13.016 81.288,12.304 81.288,11.328 L81.288,11.328 L81.288,4.8 L76.728,4.8 L76.728,12.072 C76.728,14.056 77.228,15.544 78.228,16.536 C79.228,17.528 80.568,18.024 82.248,18.024 Z M99.048,18.024 C100.744,18.024 102.016,17.52 102.864,16.512 L102.864,16.512 L102.864,17.808 L107.208,17.808 L107.208,0 L102.648,0 L102.648,5.928 C101.8,5.032 100.6,4.584 99.048,4.584 C97.864,4.584 96.784,4.856 95.808,5.4 C94.832,5.944 94.06,6.724 93.492,7.74 C92.924,8.756 92.64,9.936 92.64,11.28 C92.64,12.624 92.924,13.808 93.492,14.832 C94.06,15.856 94.832,16.644 95.808,17.196 C96.784,17.748 97.864,18.024 99.048,18.024 Z M100.008,14.4 C99.208,14.4 98.552,14.124 98.04,13.572 C97.528,13.02 97.272,12.256 97.272,11.28 C97.272,10.32 97.528,9.568 98.04,9.024 C98.552,8.48 99.208,8.208 100.008,8.208 C100.808,8.208 101.46,8.48 101.964,9.024 C102.468,9.568 102.72,10.32 102.72,11.28 C102.72,12.256 102.464,13.02 101.952,13.572 C101.44,14.124 100.792,14.4 100.008,14.4 Z M112.368,22.68 C113.728,22.68 114.88,22.356 115.824,21.708 C116.768,21.06 117.568,19.936 118.224,18.336 L118.224,18.336 L123.84,4.8 L119.496,4.8 L116.28,12.744 L113.088,4.8 L108.408,4.8 L113.976,17.976 C113.784,18.36 113.548,18.64 113.268,18.816 C112.988,18.992 112.632,19.08 112.2,19.08 C111.832,19.08 111.468,19.012 111.108,18.876 C110.748,18.74 110.44,18.552 110.184,18.312 L110.184,18.312 L108.6,21.504 C109.032,21.856 109.596,22.14 110.292,22.356 C110.988,22.572 111.68,22.68 112.368,22.68 Z" id=Study fill-opacity=0.85 fill=#FFFFFF></path></g></g></g></svg></div><div class="mobile-header-title is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height hidden" id=postTopicMobile><p class=is-full-height>理解比特币 Miniscript（三）：解析与分析</p></div></div></div><i class="iconfont icon-icon_search mobile-header-searchIcon"></i><div class=mobile-search-wrap><div class=search-input><input class=pl-3 id=mobile-search-input placeholder=请输入搜索关键词><i class="iconfont icon-icon_search mobile-search-input-btn"></i><button class=mobile-search-input-btn>搜 索</button></div></div></header><div class=mobile-slide-menu><a class=header-activity href=/ >首页</a><a href=/archives>全站目录</a><a href=/tags>标签</a><a href=/maps>地图</a><a href=/mempool>mempool</a><a target=_blank rel=noopener href=https://123btc.org/ >123btc</a><div><p class="slide-menu-theme is-flex is-flex-direction-row is-justify-content-space-between is-align-items-center"><span>主题设置</span><span><i class="iconfont icon-icon_light slide-theme-light hidden"></i><i class="iconfont icon-icon_dark slide-theme-dark hidden"></i></span></p><p class=slide-menu-fontsize><span>字体设置</span><span><i class="iconfont icon-bianzubeifen"></i><i class="iconfont icon-bianzu"></i></span></p></div></div><div class="search-mask hidden"><script src="/js/header.js?v=1682773100887"></script></div><main><main class="container is-max-widescreen content section post-page pt-4"><div class="columns is-flex-desktop is-justify-content-center"><div class="column is-3 silde-bar is-hidden-mobile"><ol class=toc><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%BD%AC%E5%8C%96%E6%88%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91><span class=toc-text>第一步：转化成抽象语法树</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%A3%80%E6%9F%A5%E7%89%87%E6%AE%B5%E5%92%8C%E5%8F%82%E6%95%B0%E5%8F%B7><span class=toc-text>第二步：检查片段和参数号</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%B1%95%E5%BC%80%E5%B0%81%E8%A3%85%E5%99%A8><span class=toc-text>第三步：展开封装器</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E8%A7%A3%E5%BC%80%E7%B3%96%E8%A1%A3><span class=toc-text>第四步：解开糖衣</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5><span class=toc-text>第五步：类型检查</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%AC%AC%E5%85%AD%E6%AD%A5%EF%BC%9A%E4%BA%A7%E7%94%9F%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC><span class=toc-text>第六步：产生比特币脚本</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%AC%AC%E4%B8%83%E6%AD%A5%EF%BC%9A%E7%94%9F%E6%88%90%E6%94%B6%E6%AC%BE%E5%9C%B0%E5%9D%80><span class=toc-text>第七步：生成收款地址</span></a></li><li class="toc-item toc-level-2"><a class=toc-link href=#%E7%BB%93%E8%AE%BA><span class=toc-text>结论</span></a></li></ol></div><div class="column is-9 post-container"><h1 class="mt-0 mb-2" id=postTitle>理解比特币 Miniscript（三）：解析与分析</h1><div class=page-author><div class="is-flex is-flex-direction-row page-data mr-6"><img class=mr-1 src=/images/default_avatar.png alt=benma><div class=page-author-info><strong>benma</strong><time class=has-text-grey datetime=2023-03-29T06:14:13.000Z>2023-03-29</time></div></div><div class=is-flex><a href=/tags/%E5%BC%80%E5%8F%91><i class="page-tag mr-1 px-1">开发</i></a><a href=/tags/Miniscript><i class="page-tag mr-1 px-1">Miniscript</i></a></div></div><article class="mt-4 post-content"><blockquote><p><em>作者：benma</em></p><p><em>来源：<a target=_blank rel=noopener href=https://shiftcrypto.ch/blog/understanding-bitcoin-miniscript-part-3/ >https://shiftcrypto.ch/blog/understanding-bitcoin-miniscript-part-3/</a></em></p><p><em>本文为 “理解比特币脚本” 系列的第三篇。前篇见<a href=https://www.btcstudy.org/2023/03/22/understanding-bitcoin-miniscript-part-2/ >此处</a>。</em></p></blockquote><p><img src=/images/understanding-bitcoin-miniscript-part-3/nodes-1.jpg alt="Understanding Bitcoin Miniscript - Part III"></p><p>在本系列的<a target=_blank rel=noopener href=https://shiftcrypto.ch/blog/understanding-bitcoin-miniscript-part-2/ >上一篇文章</a>中，我们介绍了 Miniscript 是什么，以及它如何映射成 Bitcoin Script。</p><p>要在细节上理解 Miniscript 的工作原理，看一种它的实现案例 —— 包括如何分析代码的正确性、如何创建收款地址以及如何花费资金 —— 会有所帮助。</p><p>那么，我们来了解和编写一种 Go 语言的实现。</p><p>我们将始终以 <a target=_blank rel=noopener href=https://bitcoin.sipa.be/miniscript/ >https://bitcoin.sipa.be/miniscript/</a> 为参考，因为它包含了所有 Miniscript 片段的详述和特性。</p><p>每一个章节的顶部和底部都会包含一个跳到 Go 在线运行环境的链接，你可以在那里运行代码、检查结果以及修补它。</p><p>简而言之，我们将把一段 Miniscript 转化成一个<a target=_blank rel=noopener href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>抽象语法树</a>（AST），然后执行一系列的树转换和树遍历，以执行正确性分析、创建对应的 Bitcoin Script、创建收款地址，等等。</p><p><strong>声明：下文中的实现没有经过审核和测试。请不要用在生产环境中。它只能用于教学目的。</strong></p><h2 id=第一步：转化成抽象语法树><a href=#第一步：转化成抽象语法树 class=headerlink title=第一步：转化成抽象语法树></a>第一步：转化成抽象语法树</h2><p><a target=_blank rel=noopener href=https://go.dev/play/p/5cvol49tupG>点击这里，在 Go 在线环境中运行代码</a></p><p>Miniscript 表达式很简单，也容易转化成一棵 <a target=_blank rel=noopener href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>AST</a>。不像 数学&#x2F;代数 表达式，Miniscript 表达式不包含任何中置操作符（infix operator）、分组圆括号，而且圆括号仅用来包围片段的参数。因此，它是易于表达也易于解析的。</p><p>我们来定义所需的 AST：</p><pre><code class=go>// AST 是用来表示一个 Miniscript 表达式的抽象语法树。
type AST struct &#123;
    wrappers   string
    identifier string
    args       []*AST
&#125;
</code></pre><p>像 <code>or_b</code> 这样的标识符将被存储在 <code>identifier</code> 字段中。如有任何封装器，例如 <code>ascd:X</code>，封装其都会被分离，然后存储在 <code>wrappers</code> 字段中。最后，片段的参数将递归存储在 <code>args</code> 中。</p><p>为了将一个表达式转化成一棵树，我们需要老旧而可靠的堆栈数据结构：</p><pre><code class=go>type stack struct &#123;
    elements []*AST
&#125;

func (s *stack) push(element *AST) &#123;
    s.elements = append(s.elements, element)
&#125;

func (s *stack) pop() *AST &#123;
    if len(s.elements) == 0 &#123;
        return nil
    &#125;
    top := s.elements[len(s.elements)-1]
    s.elements = s.elements[:len(s.elements)-1]
    return top
&#125;

func (s *stack) top() *AST &#123;
    if len(s.elements) == 0 &#123;
        return nil
    &#125;
    return s.elements[len(s.elements)-1]
&#125;

func (s *stack) size() int &#123;
    return len(s.elements)
&#125;
</code></pre><p>为了将表达式使用堆栈转化成一棵树，我们先将一个表达式拆分成以圆括号和逗号分割的部分。不走运的是，Go 标准库里面没有线程的函数，所以我让 ChatGPT 给我写了一段代码，而且很成功：</p><pre><code class=go>/ - 使用 ChatGPT 编写。
// splitString 函数使用 separator 作为分割元素单元，将一个字数串
// 基于多种 separator 分割成字符串切片。它也将
// 把输出切片中的空元素移除。
func splitString(s string, isSeparator func(c rune) bool) []string &#123;
    // Create a slice to hold the substrings
    substrs := make([]string, 0)

    // Set the initial index to zero
    i := 0

    // Iterate over the characters in the string
    for i &lt; len(s) &#123;
        // Find the index of the first separator in the string
        j := strings.IndexFunc(s[i:], isSeparator)
        if j == -1 &#123;
            // If no separator was found, append the remaining substring and return
            substrs = append(substrs, s[i:])
            return substrs
        &#125;
        j += i
        // If a separator was found, append the substring before it
        if j &gt; i &#123;
            substrs = append(substrs, s[i:j])
        &#125;

        // Append the separator as a separate element
        substrs = append(substrs, s[j:j+1])
        i = j + 1
    &#125;
    return substrs
&#125;
</code></pre><p>一个快速的单元测试，确认了这段代码是能工作的：</p><pre><code class=go>func TestSplitString(t *testing.T) &#123;
    separators := func(c rune) bool &#123;
        return c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;,&#39;
    &#125;

    require.Equal(t, []string&#123;&#125;, splitString(&quot;&quot;, separators))
    require.Equal(t, []string&#123;&quot;0&quot;&#125;, splitString(&quot;0&quot;, separators))
    require.Equal(t, []string&#123;&quot;0&quot;, &quot;)&quot;, &quot;(&quot;, &quot;1&quot;, &quot;(&quot;&#125;, splitString(&quot;0)(1(&quot;, separators))
    require.Equal(t,
        []string&#123;&quot;or_b&quot;, &quot;(&quot;, &quot;pk&quot;, &quot;(&quot;, &quot;key_1&quot;, &quot;)&quot;, &quot;,&quot;, &quot;s:pk&quot;, &quot;(&quot;, &quot;key_2&quot;, &quot;)&quot;, &quot;)&quot;&#125;,
        splitString(&quot;or_b(pk(key_1),s:pk(key_2))&quot;, separators))
&#125;
</code></pre><p>我们已经准备好遍历这些碎片和 圆括号&#x2F;逗号，然后建立一棵表达式树了。</p><p>无论什么时候，只要见到标识符（圆括号和逗号以外的任何东西），我们就把标识符推入栈中，它将成为它所有的子参数的父节点。无论什么时候，只要遇到逗号或者后圆括号，我们就知道这表示参数的结尾，所以我们从参数从堆栈中弹出，加入到父节点中。一些无效的序列会被明确排除，例如 “()” 和 “(”，它们不会是有效的 miniscript。</p><pre><code class=go>func createAST(miniscript string) (*AST, error) &#123;
    tokens := splitString(miniscript, func(c rune) bool &#123;
        return c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;,&#39;
    &#125;)

    if len(tokens) &gt; 0 &#123;
        first, last := tokens[0], tokens[len(tokens)-1]
        if first == &quot;(&quot; || first == &quot;)&quot; || first == &quot;,&quot; || last == &quot;(&quot; || last == &quot;,&quot; &#123;
            return nil, errors.New(&quot;invalid first or last character&quot;)
        &#125;
    &#125;

    // Build abstract syntax tree.
    var stack stack
    for i, token := range tokens &#123;
        switch token &#123;
        case &quot;(&quot;:
            // Exclude invalid sequences, which cannot appear in valid miniscripts: &quot;((&quot;, &quot;)(&quot;, &quot;,(&quot;.
            if i &gt; 0 &amp;&amp; (tokens[i-1] == &quot;(&quot; || tokens[i-1] == &quot;)&quot; || tokens[i-1] == &quot;,&quot;) &#123;
                return nil, fmt.Errorf(&quot;the sequence %s%s is invalid&quot;, tokens[i-1], token)
            &#125;
        case &quot;,&quot;, &quot;)&quot;:
            // End of a function argument - take the argument and add it to the parent&#39;s argument
            // list. If there is no parent, the expression is unbalanced, e.g. `f(X))``.
            //
            // Exclude invalid sequences, which cannot appear in valid miniscripts: &quot;(,&quot;, &quot;()&quot;, &quot;,,&quot;, &quot;,)&quot;.
            if i &gt; 0 &amp;&amp; (tokens[i-1] == &quot;(&quot; || tokens[i-1] == &quot;,&quot;) &#123;
                return nil, fmt.Errorf(&quot;the sequence %s%s is invalid&quot;, tokens[i-1], token)
            &#125;

            arg := stack.pop()
            parent := stack.top()
            if arg == nil || parent == nil &#123;
                return nil, errors.New(&quot;unbalanced&quot;)
            &#125;
            parent.args = append(parent.args, arg)
        default:
            if i &gt; 0 &amp;&amp; tokens[i-1] == &quot;)&quot; &#123;
                return nil, fmt.Errorf(&quot;the sequence %s%s is invalid&quot;, tokens[i-1], token)
            &#125;

            // Split wrappers from identifier if they exist, e.g. in &quot;dv:older&quot;, &quot;dv&quot; are wrappers
            // and &quot;older&quot; is the identifier.
            wrappers, identifier, found := strings.Cut(token, &quot;:&quot;)
            if !found &#123;
                // No colon =&gt; Cut returns `identifier, &quot;&quot;`, not `&quot;&quot;, identifier&quot;`.
                wrappers, identifier = identifier, wrappers
            &#125; else if wrappers == &quot;&quot; &#123;
                return nil, fmt.Errorf(&quot;no wrappers found before colon before identifier: %s&quot;, identifier)
            &#125; else if identifier == &quot;&quot; &#123;
                return nil, fmt.Errorf(&quot;no identifier found after colon after wrappers: %s&quot;, wrappers)
            &#125;

            stack.push(&amp;AST&#123;wrappers: wrappers, identifier: identifier&#125;)
        &#125;
    &#125;
    if stack.size() != 1 &#123;
        return nil, errors.New(&quot;unbalanced&quot;)
    &#125;
    return stack.top(), nil
&#125;
Let&#39;s also add a function to draw the tree, so we can visualize it more easily:

func (a *AST) drawTree(w io.Writer, indent string) &#123;
    if a.wrappers != &quot;&quot; &#123;
        fmt.Fprintf(w, &quot;%s:&quot;, a.wrappers)
    &#125;
    fmt.Fprint(w, a.identifier)
    fmt.Fprintln(w)
    for i, arg := range a.args &#123;
        mark := &quot;&quot;
        delim := &quot;&quot;
        if i == len(a.args)-1 &#123;
            mark = &quot;└──&quot;
        &#125; else &#123;
            mark = &quot;├──&quot;
            delim = &quot;|&quot;
        &#125;
        fmt.Fprintf(w, &quot;%s%s&quot;, indent, mark)
        arg.drawTree(w,
            indent+delim+strings.Repeat(&quot; &quot;, len([]rune(arg.identifier))+len([]rune(mark))-1-len(delim)))
    &#125;
&#125;

func (a *AST) DrawTree() string &#123;
    var b strings.Builder
    a.drawTree(&amp;b, &quot;&quot;)
    return b.String()
&#125;
</code></pre><p>我们用一个复杂的表达式来试一下：</p><pre><code class=go>func main() &#123;
    node, err := createAST(&quot;andor(pk(key_remote),or_i(and_v(v:pkh(key_local),hash160(H)),older(1008)),pk(key_revocation))&quot;)
    if err != nil &#123;
        panic(err)
    &#125;
    fmt.Println(node.DrawTree())
&#125;
</code></pre><p>成功！输出是这样的：</p><pre><code>andor
├──pk
|   └──key_remote
├──or_i
|     ├──and_v
|     |      ├──v:pkh
|     |      |    └──key_local
|     |      └──hash160
|     |               └──H
|     └──older
|            └──1008
└──pk
    └──key_revocation
</code></pre><p>当然，解析器还没有检查过，所以 <code>unknownFragment(foo,bar)</code> 这样的表达式也能被转化成 AST：</p><pre><code>unknownFragment
├──foo
└──bar
</code></pre><p><a target=_blank rel=noopener href=https://go.dev/play/p/5cvol49tupG>点击此处，在线上 Go 环境中运行代码</a></p><h2 id=第二步：检查片段和参数号><a href=#第二步：检查片段和参数号 class=headerlink title=第二步：检查片段和参数号></a>第二步：检查片段和参数号</h2><p><a target=_blank rel=noopener href=https://go.dev/play/p/G395mI5kd_u>点击此处，在线上 Go 环境中运行代码</a></p><p>作为多次树遍历的第一步，我们要作第一种容易的检查：树上的每一个片段标识符都是有效的吗？每一种都有正确的参数号码？</p><p>根据<a target=_blank rel=noopener href=https://bitcoin.sipa.be/miniscript/ >规范</a>，所有的片段排列如下：</p><pre><code class=go>const (
    // 所有的片段标识符

    f_0         = &quot;0&quot;         // 0
    f_1         = &quot;1&quot;         // 1
    f_pk_k      = &quot;pk_k&quot;      // pk_k(key)
    f_pk_h      = &quot;pk_h&quot;      // pk_h(key)
    f_pk        = &quot;pk&quot;        // pk(key) = c:pk_k(key)
    f_pkh       = &quot;pkh&quot;       // pkh(key) = c:pk_h(key)
    f_sha256    = &quot;sha256&quot;    // sha256(h)
    f_ripemd160 = &quot;ripemd160&quot; // ripemd160(h)
    f_hash256   = &quot;hash256&quot;   // hash256(h)
    f_hash160   = &quot;hash160&quot;   // hash160(h)
    f_older     = &quot;older&quot;     // older(n)
    f_after     = &quot;after&quot;     // after(n)
    f_andor     = &quot;andor&quot;     // andor(X,Y,Z)
    f_and_v     = &quot;and_v&quot;     // and_v(X,Y)
    f_and_b     = &quot;and_b&quot;     // and_b(X,Y)
    f_and_n     = &quot;and_n&quot;     // and_n(X,Y) = andor(X,Y,0)
    f_or_b      = &quot;or_b&quot;      // or_b(X,Z)
    f_or_c      = &quot;or_c&quot;      // or_c(X,Z)
    f_or_d      = &quot;or_d&quot;      // or_d(X,Z)
    f_or_i      = &quot;or_i&quot;      // or_i(X,Z)
    f_thresh    = &quot;thresh&quot;    // thresh(k,X1,...,Xn)
    f_multi     = &quot;multi&quot;     // multi(k,key1,...,keyn)
)
</code></pre><p><code>older</code>、<code>after</code>、<code>thresh</code> 和 <code>multi</code> 的第一个参数都是数字。在我们需要解析它、检查它是不是一个有效的数字时，我们要将它转化成一个数字并存储在我们的 AST 中，以备后续使用。因此，我们给 AST 增加一个新的字段：</p><pre><code class=go>// AST is the abstract syntax tree representing a Miniscript expression.
type AST struct &#123;
    wrappers   string
    identifier string
    // 在标识符预计是个数字时解析出来的整数。
    // 比如 older/after/multi/thresh 的第一个参数。否则不使用
    num uint64
    args       []*AST
&#125;
</code></pre><p>我们也需要一种函数，可以递归地遍历整棵树，然后给每一个 Miniscript 表达式&#x2F;子表达式 使用一个函数。这种转化函数可以修改一个节点，或者直接将它替换成一个新节点，这对最后一个阶段的解析是有用的：</p><pre><code class=go>func (a *AST) apply(f func(*AST) (*AST, error)) (*AST, error) &#123;
    for i, arg := range a.args &#123;
        // 我们并不递归进入不是 Miniscript 表达式的参数：
        // key/hash 标量以及 older/after/multi/thresh 的数值参数。
        switch a.identifier &#123;
        case f_pk_k, f_pk_h, f_pk, f_pkh,
            f_sha256, f_hash256, f_ripemd160, f_hash160,
            f_older, f_after, f_multi:
            // 这些函数的变量都不是 Miniscript 表达式，只是
            // 变量（或者说具体的指定）或者数字。
            continue
        case f_thresh:
            // 第一个参数是一个数字，其它的参数是子表达式，
            // 就是我们想要遍历的东西，所以我们只跳过第一个参数。
            if i == 0 &#123;
                continue
            &#125;
        &#125;

        new, err := arg.apply(f)
        if err != nil &#123;
            return nil, err
        &#125;
        a.args[i] = new
    &#125;
    return f(a)
&#125;
</code></pre><p>案例：</p><pre><code class=go>node, _ := createAST(&quot;andor(pk(key_remote),or_i(and_v(v:pkh(key_local),hash160(H)),older(1008)),pk(key_revocation))&quot;)
node.apply(func(node *AST) (*AST, error) &#123;
        fmt.Println(&quot;Visiting node:&quot;, node.identifier)
        return node, nil
    &#125;)
</code></pre><p>输出：</p><pre><code>Visiting node: pk
Visiting node: pkh
Visiting node: hash160
Visiting node: and_v
Visiting node: older
Visiting node: or_i
Visiting node: pk
Visiting node: andor
</code></pre><p>现在，我们加入一个 Parse 函数，它会创建 AST 并连续应用转化函数，其中第一种转化函数就是片段和参数检查器：</p><pre><code class=go>func Parse(miniscript string) (*AST, error) &#123;
    node, err := createAST(miniscript)
    if err != nil &#123;
        return nil, err
    &#125;
    for _, transform := range []func(*AST) (*AST, error)&#123;
        argCheck,
        // More stages to come
    &#125; &#123;
        node, err = node.apply(transform)
        if err != nil &#123;
            return nil, err
        &#125;
    &#125;
    return node, nil
&#125;
</code></pre><p>这个 <code>argCheck</code> 函数会对树的每一个节点使用，而且我们可以简单枚举所有的有效片段标识符，来执行这种基础检查：</p><pre><code class=go>// argCheck 会检查每一个标识符都是一种已知的 Miniscript 标识符，并且
// 具有正确数量的参数，例如 `andor(X,Y,Z)` 必须有三个参数，等等。
func argCheck(node *AST) (*AST, error) &#123;
    // Helper function to check that this node has a specific number of arguments.
    expectArgs := func(num int) error &#123;
        if len(node.args) != num &#123;
            return fmt.Errorf(&quot;%s expects %d arguments, got %d&quot;, node.identifier, num, len(node.args))
        &#125;
        return nil
    &#125;
    switch node.identifier &#123;
    case f_0, f_1:
        if err := expectArgs(0); err != nil &#123;
            return nil, err
        &#125;
    case f_pk_k, f_pk_h, f_pk, f_pkh, f_sha256, f_ripemd160, f_hash256, f_hash160:
        if err := expectArgs(1); err != nil &#123;
            return nil, err
        &#125;
        if len(node.args[0].args) &gt; 0 &#123;
            return nil, fmt.Errorf(&quot;argument of %s must not contain subexpressions&quot;, node.identifier)
        &#125;
    case f_older, f_after:
        if err := expectArgs(1); err != nil &#123;
            return nil, err
        &#125;
        _n := node.args[0]
        if len(_n.args) &gt; 0 &#123;
            return nil, fmt.Errorf(&quot;argument of %s must not contain subexpressions&quot;, node.identifier)
        &#125;
        n, err := strconv.ParseUint(_n.identifier, 10, 64)
        if err != nil &#123;
            return nil, fmt.Errorf(
                &quot;%s(k) =&gt; k must be an unsigned integer, but got: %s&quot;, node.identifier, _n.identifier)
        &#125;
        _n.num = n
        if n &lt; 1 || n &gt;= (1&lt;&lt;31) &#123;
            return nil, fmt.Errorf(&quot;%s(n) -&gt; n must 1 ≤ n &lt; 2^31, but got: %s&quot;, node.identifier, _n.identifier)
        &#125;
    case f_andor:
        if err := expectArgs(3); err != nil &#123;
            return nil, err
        &#125;
    case f_and_v, f_and_b, f_and_n, f_or_b, f_or_c, f_or_d, f_or_i:
        if err := expectArgs(2); err != nil &#123;
            return nil, err
        &#125;
    case f_thresh, f_multi:
        if len(node.args) &lt; 2 &#123;
            return nil, fmt.Errorf(&quot;%s must have at least two arguments&quot;, node.identifier)
        &#125;
        _k := node.args[0]
        if len(_k.args) &gt; 0 &#123;
            return nil, fmt.Errorf(&quot;argument of %s must not contain subexpressions&quot;, node.identifier)
        &#125;
        k, err := strconv.ParseUint(_k.identifier, 10, 64)
        if err != nil &#123;
            return nil, fmt.Errorf(
                &quot;%s(k, ...) =&gt; k must be an integer, but got: %s&quot;, node.identifier, _k.identifier)
        &#125;
        _k.num = k
        numSubs := len(node.args) - 1
        if k &lt; 1 || k &gt; uint64(numSubs) &#123;
            return nil, fmt.Errorf(
                &quot;%s(k) -&gt; k must 1 ≤ k ≤ n, but got: %s&quot;, node.identifier, _k.identifier)
        &#125;
        if node.identifier == f_multi &#123;
            // 一个 multisig 可以拥有的最大公钥数量。
            const multisigMaxKeys = 20
            if numSubs &gt; multisigMaxKeys &#123;
                return nil, fmt.Errorf(&quot;number of multisig keys cannot exceed %d&quot;, multisigMaxKeys)
            &#125;
            // Multisig 的密钥是一种变量，无法拥有子表达式。
            for _, arg := range node.args &#123;
                if len(arg.args) &gt; 0 &#123;
                    return nil, fmt.Errorf(&quot;arguments of %s must not contain subexpressions&quot;, node.identifier)
                &#125;
            &#125;
        &#125;
    default:
        return nil, fmt.Errorf(&quot;unrecognized identifier: %s&quot;, node.identifier)
    &#125;
    return node, nil
&#125;
</code></pre><p>有了这些检查，我们已经可以排除大部分的无效 Miniscript 了。我们来看一些案例：</p><pre><code class=go>func main() &#123;
    for _, expr := range []string&#123;
        &quot;invalid&quot;,
        &quot;pk(key1,tooManyArgs)&quot;,
        &quot;pk(key1(0))&quot;,
        &quot;and_v(0)&quot;,
        &quot;after(notANumber)&quot;,
        &quot;after(-1)&quot;,
        &quot;multi(0,k1)&quot;,
        &quot;multi(2,k1)&quot;,
        &quot;multi(1,k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21)&quot;,
    &#125; &#123;
        _, err := Parse(expr)
        fmt.Println(expr, &quot; -- &quot;, err)
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code>invalid  --  unrecognized identifier: invalid
pk(key1,tooManyArgs)  --  pk expects 1 arguments, got 2
pk(key1(0))  --  argument of pk must not contain subexpressions
and_v(0)  --  and_v expects 2 arguments, got 1
after(notANumber)  --  after(k) =&gt; k must be an unsigned integer, but got: notANumber
after(-1)  --  after(k) =&gt; k must be an unsigned integer, but got: -1
multi(0,k1)  --  multi(k) -&gt; k must 1 ≤ k ≤ n, but got: 0
multi(2,k1)  --  multi(k) -&gt; k must 1 ≤ k ≤ n, but got: 2
multi(1,k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21)  --  number of multisig keys cannot exceed 20
</code></pre><p><a target=_blank rel=noopener href=https://go.dev/play/p/G395mI5kd_u>点击此处，在线上 Go 环境中运行代码</a></p><h2 id=第三步：展开封装器><a href=#第三步：展开封装器 class=headerlink title=第三步：展开封装器></a>第三步：展开封装器</h2><p><a target=_blank rel=noopener href=https://go.dev/play/p/2R2S9ZEty-B>点击此处，在线上 Go 环境中运行代码</a></p><p>每一个片段都可以被封装器封起来，封装器使用冒号 “:” 表明。例子来自<a target=_blank rel=noopener href=https://bitcoin.sipa.be/miniscript/:>此处</a>。</p><p><code>dv:older(144)</code> 表示 d: 封装器应用在了 v: 封装器上，而 v: 封装器用来封装参数为 144 区块的 <code>older</code> 片段。</p><p>在解析器的下一个阶段，我们希望同时对封装器操作，因为它们的动作跟普通的片段一样：它们可以映射成 Bitcoin Script，也有自己的正确性规则，等等。一句话，<code>dv:older(144)</code> 就只是 <code>d(v(older(144)))</code> 的语法糖。</p><p>在这个案例中，我们希望将 AST 从这样：</p><pre><code>dv:older
└──144
</code></pre><p>变成这样：</p><pre><code>d
└──v
   └──older
          └──144
</code></pre><p>为了执行这种转化，我们要把这个函数加入转化列表。注意，我们按反序迭代封装器中的字母，因为它们是从右到左使用的。</p><pre><code class=go>// expandWrappers 应用在封装器（引号以前的字母）上，例如 `ascd:X` =&gt;
// `a(s(c(d(X))))`.
func expandWrappers(node *AST) (*AST, error) &#123;
    const allWrappers = &quot;asctdvjnlu&quot;

    wrappers := []rune(node.wrappers)
    node.wrappers = &quot;&quot;
    for i := len(wrappers) - 1; i &gt;= 0; i-- &#123;
        wrapper := wrappers[i]
        if !strings.ContainsRune(allWrappers, wrapper) &#123;
            return nil, fmt.Errorf(&quot;unknown wrapper: %s&quot;, string(wrapper))
        &#125;
        node = &amp;AST&#123;identifier: string(wrapper), args: []*AST&#123;node&#125;&#125;
    &#125;
    return node, nil
&#125;
</code></pre><p><a target=_blank rel=noopener href=https://go.dev/play/p/2R2S9ZEty-B>点击此处，在线上 Go 环境中运行代码</a></p><h2 id=第四步：解开糖衣><a href=#第四步：解开糖衣 class=headerlink title=第四步：解开糖衣></a>第四步：解开糖衣</h2><p><a target=_blank rel=noopener href=https://go.dev/play/p/W8VAwipFvue>点击此处，在线上 Go 环境中运行代码</a></p><p>Miniscript 定义了 6 种语法糖。如果一个 Miniscript 片段包含了下列等式的坐标的表达式，那么这些表达式可以换成等号右边的表达式。为了节约在后续阶段处理这 6 种片段的功夫，我们添加一种去除糖衣的转化函数，替代这些表达式。</p><p>替代关系如下：</p><pre><code>pk(key) = c:pk_k(key)
pkh(key) = c:pk_h(key)
and_n(X,Y) = andor(X,Y,0)
t:X = and_v(X,1)
l:X = or_i(0,X)
u:X = or_i(X,0)
</code></pre><p>现在，我们恰好可以使用我们一开始在封装器片段中定义的标识符，来扩充这个列表：</p><pre><code class=go>const (
    // [...]
    f_wrap_a    = &quot;a&quot;         // a:X
    f_wrap_s    = &quot;s&quot;         // s:X
    f_wrap_c    = &quot;c&quot;         // c:X
    f_wrap_d    = &quot;d&quot;         // d:X
    f_wrap_v    = &quot;v&quot;         // v:X
    f_wrap_j    = &quot;j&quot;         // j:X
    f_wrap_n    = &quot;n&quot;         // n:X
    f_wrap_t    = &quot;t&quot;         // t:X = and_v(X,1)
    f_wrap_l    = &quot;l&quot;         // l:X = or_i(0,X)
    f_wrap_u    = &quot;u&quot;         // u:X = or_i(X,0))
)
</code></pre><p>转化函数将变成这样：</p><pre><code class=go>// desugar 使用最终的形式替换了语法糖
func desugar(node *AST) (*AST, error) &#123;
    switch node.identifier &#123;
    case f_pk: // pk(key) = c:pk_k(key)
        return &amp;AST&#123;
            identifier: f_wrap_c,
            args: []*AST&#123;
                &#123;
                    identifier: f_pk_k,
                    args:       node.args,
                &#125;,
            &#125;,
        &#125;, nil
    case f_pkh: // pkh(key) = c:pk_h(key)
        return &amp;AST&#123;
            identifier: f_wrap_c,
            args: []*AST&#123;
                &#123;
                    identifier: f_pk_h,
                    args:       node.args,
                &#125;,
            &#125;,
        &#125;, nil
    case f_and_n: // and_n(X,Y) = andor(X,Y,0)
        return &amp;AST&#123;
            identifier: f_andor,
            args: []*AST&#123;
                node.args[0],
                node.args[1],
                &#123;identifier: f_0&#125;,
            &#125;,
        &#125;, nil
    case f_wrap_t: // t:X = and_v(X,1)
        return &amp;AST&#123;
            identifier: f_and_v,
            args: []*AST&#123;
                node.args[0],
                &#123;identifier: f_1&#125;,
            &#125;,
        &#125;, nil
    case f_wrap_l: // l:X = or_i(0,X)
        return &amp;AST&#123;
            identifier: f_or_i,
            args: []*AST&#123;
                &#123;identifier: f_0&#125;,
                node.args[0],
            &#125;,
        &#125;, nil
    case f_wrap_u: // u:X = or_i(X,0)
        return &amp;AST&#123;
            identifier: f_or_i,
            args: []*AST&#123;
                node.args[0],
                &#123;identifier: f_0&#125;,
            &#125;,
        &#125;, nil
    &#125;

    return node, nil
&#125;
</code></pre><p>我们尝试所有这些方法，并运用视觉检查：</p><pre><code class=go>func main() &#123;
    for _, expr := range []string&#123;
        &quot;pk(key)&quot;,
        &quot;pkh(key)&quot;,
        &quot;and_n(pk(key),sha256(H))&quot;,
        &quot;tv:pk(key)&quot;,
        &quot;l:pk(key)&quot;,
        &quot;u:pk(key)&quot;,
    &#125; &#123;
        node, err := Parse(expr)
        if err != nil &#123;
            panic(err)
        &#125;
        fmt.Printf(&quot;Tree for \&quot;%v\&quot;\n&quot;, expr)
        fmt.Println(node.DrawTree())
    &#125;
&#125;
</code></pre><p>从下面的输出可知，去除糖衣的函数奏效了：</p><pre><code>Tree for &quot;pk(key)&quot;
c
└──pk_k
      └──key

Tree for &quot;pkh(key)&quot;
c
└──pk_h
      └──key

Tree for &quot;and_n(pk(key),sha256(H))&quot;
andor
├──c
|  └──pk_k
|        └──key
├──sha256
|       └──H
└──0

Tree for &quot;tv:pk(key)&quot;
and_v
├──v
|  └──c
|     └──pk_k
|           └──key
└──1

Tree for &quot;l:pk(key)&quot;
or_i
├──0
└──c
   └──pk_k
         └──key

Tree for &quot;u:pk(key)&quot;
or_i
├──c
|  └──pk_k
|        └──key
└──0
</code></pre><p><a target=_blank rel=noopener href=https://go.dev/play/p/W8VAwipFvue>点击此处，在线上 Go 环境中运行代码</a></p><h2 id=第五步：类型检查><a href=#第五步：类型检查 class=headerlink title=第五步：类型检查></a>第五步：类型检查</h2><p><a target=_blank rel=noopener href=https://go.dev/play/p/Lv9uAvZqlZw>点击此处，在线上 Go 环境中运行代码</a></p><p>并非所有片段都能相互组合：有些组合无法产生有效的比特币脚本和有效的见证数据。</p><p>但是，因为 Miniscript 表达式和片段是充分结构化、层级式的，所以我们容易静态分析一段 Miniscript 表达式是否在所有条件下都有效。</p><p>举个例子，<code>or_b(pk(key1),pk(key2))</code> 和 <code>or_b(v:pk(key1),v:pk(key2))</code> 不是有效的组合，但 <code>or_b(pk(key1),s:pk(key2))</code> 是有效的。</p><p>根据 <a target=_blank rel=noopener href=https://bitcoin.sipa.be/miniscript/ >Miniscript 规范</a>，每一种片段都可能是四种基础类型 <code>B</code>、<code>V</code>、<code>K</code> 和 <code>W</code> 之一；每一种片段都可以有额外的类型特性（<code>z</code>、<code>o</code>、<code>n</code>、<code>d</code> 和 <code>u</code>）。</p><p>元件片段（不能包含任何子表达式的片段）拥有固定的基础类型和固定的类型特性。举个例子，哈希函数片段 <code>sha256(h)</code> 会被转化成比特币脚本 <code>SIZE &lt;32&gt; EQUALVERIFY SHA256 &lt;h&gt; EQUAL</code>，可以使用见证数据 <code>&lt;32 byte preimage&gt;</code> 来满足（其中的数值满足 <code>sha256(preimage)=h</code>），它的类型为 <code>Bondu</code>，意思是：</p><ul><li><code>B</code>：成功时，向堆栈推入非零值；失败时推入准确的 0 值。消耗栈顶的元素（如果有的话）。</li><li><code>o</code>：消耗一个对战元素（在这个例子中就是那个原像）</li><li><code>n</code>：非零属性 —— 不能用 0 来满足。<code>sha256(h)</code> 的正确原像必须是 32 字节长，所以无法是 0。</li><li><code>d</code>：可以无条件地避开。在 <code>sha256()</code> 这个例子中，任何 32 字节但并非真正原像的数据都是无效的，这总是可以构造出来的。注意，非 32 字节的值不是有效的避开，因为它会在 <code>EQUALVERIFY</code> 的时候导致脚本执行终止，而不是继续执行。</li><li><code>u</code>：在满足的时候，会向堆栈推入 1。</li></ul><p>基本的类型和类型属性是精心定义的，以保证组合出来的片段的正确性。这些属性可以根据脚本和见证数据的推理，分配给每一种片段。类似地，对于包含子表达式的片段，例如 <code>and_b(X,Y)</code>，你可以分析 <code>X</code> 和 <code>Y</code> 必须满足什么样类型，以及 <code>and_b(X,Y)</code> 自身必须具备什么样的衍生类型和属性。幸运的是，Miniscript 的作者已经完成了这部分工作，而且已经在<a target=_blank rel=noopener href=https://bitcoin.sipa.be/miniscript/ >规范</a>中记录了正确性表格。</p><p>顶层的片段必须具备类型 <code>B</code>，否则这个片段就是无效的。</p><p>我们使用基本的类型和类型属性来扩充我们的 AST：</p><pre><code class=go>type basicType string

const (
    typeB basicType = &quot;B&quot;
    typeV basicType = &quot;V&quot;
    typeK basicType = &quot;K&quot;
    typeW basicType = &quot;W&quot;
)

type properties struct &#123;
    // Basic type properties
    z, o, n, d, u bool
&#125;

func (p properties) String() string &#123;
    s := strings.Builder&#123;&#125;
    if p.z &#123;
        s.WriteRune(&#39;z&#39;)
    &#125;
    if p.o &#123;
        s.WriteRune(&#39;o&#39;)
    &#125;
    if p.n &#123;
        s.WriteRune(&#39;n&#39;)
    &#125;
    if p.d &#123;
        s.WriteRune(&#39;d&#39;)
    &#125;
    if p.u &#123;
        s.WriteRune(&#39;u&#39;)
    &#125;
    return s.String()
&#125;

// AST is the abstract syntax tree representing a Miniscript expression.
type AST struct &#123;
    basicType  basicType
    props      properties
    wrappers   string
    identifier string
    // Parsed integer for when identifer is a expected to be a number, i.e. the first argument of
    // older/after/multi/thresh. Otherwise unused.
    num uint64
    args      []*AST
&#125;

// typeRepr returns the basic type (B, V, K or W) followed by all type properties.
func (a *AST) typeRepr() string &#123;
    return fmt.Sprintf(&quot;%s%s&quot;, a.basicType, a.props)
&#125;
</code></pre><p>然后，我们加入另一个函数来遍历整棵树。这个函数将检查子表达式的类型要求，并根据规范的正确性表格设定类型和类型属性。</p><p>由于这个函数非常长，我们就仅展示它处理少数片段的简缩版本，仅演示它是如何工作的。片段类型既跟元件有关，也跟参数有关。它根据规范中的表格直接编码类型规则。举个例子，为使 <code>s:X</code> 是有效的，<code>X</code> 必须是类型 <code>Bo</code>；而整个片段将具有类型 <code>W</code>，并获得 <code>X</code> 的 <code>d</code> 和 <code>u</code> 属性。</p><p>你可以在<a target=_blank rel=noopener href=https://go.dev/play/p/Lv9uAvZqlZw>线上环境</a>中看到和运行能够处理每一种片段的完整版本。</p><pre><code class=go>// expectBasicType is a helper function to check that this node has a specific type.
func (a *AST) expectBasicType(typ basicType) error &#123;
    if a.basicType != typ &#123;
        return fmt.Errorf(&quot;expression `%s` expected to have type %s, but is type %s&quot;,
            a.identifier, typ, a.basicType)
    &#125;
    return nil
&#125;

func typeCheck(node *AST) (*AST, error) &#123;
    switch node.identifier &#123;
    case f_0:
        node.basicType = typeB
        node.props.z = true
        node.props.u = true
        node.props.d = true
    // [...]
    case f_pk_k:
        node.basicType = typeK
        node.props.o = true
        node.props.n = true
        node.props.d = true
        node.props.u = true
    // [...]
    case f_or_d:
        _x, _z := node.args[0], node.args[1]
        if err := _x.expectBasicType(typeB); err != nil &#123;
            return nil, err
        &#125;
        if !_x.props.d || !_x.props.u &#123;
            return nil, fmt.Errorf(
                &quot;wrong properties on `%s`, the first argument of `%s`&quot;, _x.identifier, node.identifier)
        &#125;
        if err := _z.expectBasicType(typeB); err != nil &#123;
            return nil, err
        &#125;
        node.basicType = typeB
        node.props.z = _x.props.z &amp;&amp; _z.props.z
        node.props.o = _x.props.o &amp;&amp; _z.props.z
        node.props.d = _z.props.d
        node.props.u = _z.props.u
    // [...]
    case f_wrap_s:
        _x := node.args[0]
        if err := _x.expectBasicType(typeB); err != nil &#123;
            return nil, err
        &#125;
        if !_x.props.o &#123;
            return nil, fmt.Errorf(
                &quot;wrong properties on `%s`, the first argument of `%s`&quot;, _x.identifier, node.identifier)
        &#125;
        node.props.d = _x.props.d
        node.props.u = _x.props.u
    // [...]
    &#125;
    return node, nil
&#125;
</code></pre><p>现在，我们已经推导出了所有的类型和类型属性，我们也需要将顶层表达式必须具有类型 <code>B</code> 的检查加入最终检查中：</p><pre><code class=go>func Parse(miniscript string) (*AST, error) &#123;
    node, err := createAST(miniscript)
    if err != nil &#123;
        return nil, err
    &#125;
    for _, transform := range []func(*AST) (*AST, error)&#123;
        argCheck,
        expandWrappers,
        desugar,
        typeCheck,
        // More stages to come
    &#125; &#123;
        node, err = node.apply(transform)
        if err != nil &#123;
            return nil, err
        &#125;
    &#125;
    // Top-level expression must be of type &quot;B&quot;.
    if err := node.expectBasicType(typeB); err != nil &#123;
        return nil, err
    &#125;
    return node, nil
&#125;
</code></pre><p>我们用有效和无效的 Miniscript 片段来检验一下：</p><pre><code class=go>func main() &#123;
    expr := &quot;or_b(pk(key1),s:pk(key2))&quot;
    node, err := Parse(expr)
    if err == nil &#123;
        fmt.Println(&quot;miniscript valid:&quot;, expr)
        fmt.Println(node.DrawTree())
    &#125;
    for _, expr := range []string&#123;&quot;pk_k(key)&quot;, &quot;or_b(pk(key1),pk(key2))&quot;&#125; &#123;
        _, err = Parse(expr)
        fmt.Println(&quot;miniscript invalid:&quot;, expr, &quot;-&quot;, err)
    &#125;
&#125;
</code></pre><p>成功！输出是这样的：</p><pre><code>miniscript valid: or_b(pk(key1),s:pk(key2))
or_b [Bdu]
├──c [Bondu]
|  └──pk_k [Kondu]
|        └──key1
└──s [Wdu]
   └──c [Bondu]
      └──pk_k [Kondu]
            └──key2

miniscript invalid: pk_k(key) - expression `pk_k` expected to have type B, but is type K
miniscript invalid: or_b(pk(key1),pk(key2)) - expression `c` expected to have type W, but is type B
</code></pre><p>（我们修改了 <code>draw()</code> 函数，以在每个片段旁边展示其类型。）</p><p><a target=_blank rel=noopener href=https://go.dev/play/p/Lv9uAvZqlZw>点击此处，在线上 Go 环境中运行代码</a></p><h2 id=第六步：产生比特币脚本><a href=#第六步：产生比特币脚本 class=headerlink title=第六步：产生比特币脚本></a>第六步：产生比特币脚本</h2><p>我们还没有实现能够拒绝所有无效 Miniscript 片段的检查，但现在，可以实验一下用它来生成比特币脚本了。</p><p><a target=_blank rel=noopener href=https://bitcoin.sipa.be/miniscript/ >规范</a>中的转换表定义了 Miniscript 碎片如何映射成比特币脚本。举个例子，<code>and_b(X, Y)</code> 映射成 <code>[X] [Y] BOOLAND</code>，等等。</p><p>我们会先制作一个函数，它会创建一个可以直接阅读的脚本的字符串表示，就像那张转换表一样。这换我们容易制作出原型并消除 bug，因为你可以容易检查输出。实际的脚本是一串字节，我们后面会实现的。</p><p>我们加入这个函数，根据转换表将每一种片段映射成脚本：</p><pre><code class=go>func scriptStr(node *AST) string &#123;
    switch node.identifier &#123;
    case f_0, f_1:
        return node.identifier
    case f_pk_k:
        return fmt.Sprintf(&quot;&lt;%s&gt;&quot;, node.args[0].identifier)
    case f_pk_h:
        return fmt.Sprintf(&quot;DUP HASH160 &lt;HASH160(%s)&gt; EQUALVERIFY&quot;, node.args[0].identifier)
    case f_older:
        return fmt.Sprintf(&quot;&lt;%s&gt; CHECKSEQUENCEVERIFY&quot;, node.args[0].identifier)
    case f_after:
        return fmt.Sprintf(&quot;&lt;%s&gt; CHECKLOCKTIMEVERIFY&quot;, node.args[0].identifier)
    case f_sha256, f_hash256, f_ripemd160, f_hash160:
        return fmt.Sprintf(
            &quot;SIZE &lt;32&gt; EQUALVERIFY %s &lt;%s&gt; EQUAL&quot;,
            strings.ToUpper(node.identifier),
            node.args[0].identifier)
    case f_andor:
        return fmt.Sprintf(&quot;%s NOTIF %s ELSE %s ENDIF&quot;,
            scriptStr(node.args[0]),
            scriptStr(node.args[2]),
            scriptStr(node.args[1]),
        )
    case f_and_v:
        return fmt.Sprintf(&quot;%s %s&quot;,
            scriptStr(node.args[0]),
            scriptStr(node.args[1]))
    case f_and_b:
        return fmt.Sprintf(&quot;%s %s BOOLAND&quot;,
            scriptStr(node.args[0]),
            scriptStr(node.args[1]),
        )
    case f_or_b:
        return fmt.Sprintf(&quot;%s %s BOOLOR&quot;,
            scriptStr(node.args[0]),
            scriptStr(node.args[1]),
        )
    case f_or_c:
        return fmt.Sprintf(&quot;%s NOTIF %s ENDIF&quot;,
            scriptStr(node.args[0]),
            scriptStr(node.args[1]),
        )
    case f_or_d:
        return fmt.Sprintf(&quot;%s IFDUP NOTIF %s ENDIF&quot;,
            scriptStr(node.args[0]),
            scriptStr(node.args[1]),
        )
    case f_or_i:
        return fmt.Sprintf(&quot;IF %s ELSE %s ENDIF&quot;,
            scriptStr(node.args[0]),
            scriptStr(node.args[1]),
        )
    case f_thresh:
        s := []string&#123;&#125;
        for i := 1; i &lt; len(node.args); i++ &#123;
            s = append(s, scriptStr(node.args[i]))
            if i &gt; 1 &#123;
                s = append(s, &quot;ADD&quot;)
            &#125;
        &#125;

        s = append(s, node.args[0].identifier)
        s = append(s, &quot;EQUAL&quot;)
        return strings.Join(s, &quot; &quot;)
    case f_multi:
        s := []string&#123;node.args[0].identifier&#125;
        for _, arg := range node.args[1:] &#123;
            s = append(s, fmt.Sprintf(&quot;&lt;%s&gt;&quot;, arg.identifier))
        &#125;
        s = append(s, fmt.Sprint(len(node.args)-1))
        s = append(s, &quot;CHECKMULTISIG&quot;)
        return strings.Join(s, &quot; &quot;)
    case f_wrap_a:
        return fmt.Sprintf(&quot;TOALTSTACK %s FROMALTSTACK&quot;, scriptStr(node.args[0]))
    case f_wrap_s:
        return fmt.Sprintf(&quot;SWAP %s&quot;, scriptStr(node.args[0]))
    case f_wrap_c:
        return fmt.Sprintf(&quot;%s CHECKSIG&quot;,
            scriptStr(node.args[0]))
    case f_wrap_d:
        return fmt.Sprintf(&quot;DUP IF %s ENDIF&quot;,
            scriptStr(node.args[0]))
    case f_wrap_v:
        return fmt.Sprintf(&quot;%s VERIFY&quot;, scriptStr(node.args[0]))
    case f_wrap_j:
        return fmt.Sprintf(&quot;SIZE 0NOTEQUAL IF %s ENDIF&quot;,
            scriptStr(node.args[0]))
    case f_wrap_n:
        return fmt.Sprintf(&quot;%s 0NOTEQUAL&quot;,
            scriptStr(node.args[0]))
    default:
        return &quot;&lt;unknown&gt;&quot;
    &#125;
&#125;
</code></pre><p>试一试：</p><p><a target=_blank rel=noopener href=https://go.dev/play/p/MDqSTYvBB9p>在线上环境中运行</a></p><pre><code class=go>func main() &#123;
    node, err := Parse(&quot;or_d(pk(pubkey1),and_v(v:pk(pubkey2),older(52560)))&quot;)
    if err != nil &#123;
        panic(err)
    &#125;
    fmt.Println(scriptStr(node))
&#125;
</code></pre><p>输出：</p><pre><code>&lt;pubkey1&gt; CHECKSIG IFDUP NOTIF &lt;pubkey2&gt; CHECKSIG VERIFY &lt;52560&gt; CHECKSEQUENCEVERIFY ENDIF
</code></pre><p>这是正确的，但还有一处需要优化。<code>v:X</code> 封装器会映射成 <code>[X] VERIFY</code>。操作符 <code>EQUALVERIFY</code>、<code>CHECKSIGVERIFY</code> 和 <code>CHECKMULTISIGVERIFY</code> 分别是 <code>EQUAL VERIFY</code>、<code>CHECKSIG VERIFY</code> 和 <code>CHECKMULTISIG VERIFY</code> 的缩写，所以在上述脚本中，<code>CHECKSIG VERIFY</code> 应该被缩写成 <code>CHECKSIGVERITY</code>，以在脚本中节省一个字节。</p><p>如果在 <code>v:X</code> 中，<code>[X]</code> 的最后一个操作符是 <code>EQUAL</code>&#x2F;<code>CHECKSIG</code>&#x2F;<code>CHECKMULTISIG</code>，可以替换成 <code>VERITY</code> 版本。</p><p>因为 <code>X</code> 可以是任意的表达式，我们需要另一次树遍历来确定每个片段的最后一个操作符是否是上述三者之一。</p><p>我们把这个属性加入属性结构体中：</p><pre><code class=go>type properties struct &#123;
    // Basic type properties
    z, o, n, d, u bool

    // Check if the rightmost script byte produced by this node is OP_EQUAL, OP_CHECKSIG or
    // OP_CHECKMULTISIG.
    //
    // If so, it can be be converted into the VERIFY version if an ancestor is the verify wrapper
    // `v`, i.e. OP_EQUALVERIFY, OP_CHECKSIGVERIFY and OP_CHECKMULTISIGVERIFY instead of using two
    // opcodes, e.g. `OP_EQUAL OP_VERIFY`.
    canCollapseVerify bool
&#125;
</code></pre><p>而且，这个函数为每一个片段设置了这个字段，我们需要添加到转化函数列表中：</p><pre><code class=go>func canCollapseVerify(node *AST) (*AST, error) &#123;
    switch node.identifier &#123;
    case f_sha256, f_ripemd160, f_hash256, f_hash160, f_thresh, f_multi, f_wrap_c:
        node.props.canCollapseVerify = true
    case f_and_v:
        node.props.canCollapseVerify = node.args[1].props.canCollapseVerify
    case f_wrap_s:
        node.props.canCollapseVerify = node.args[0].props.canCollapseVerify
    &#125;
    return node, nil
&#125;
</code></pre><p><code>and_v</code> 片段和 <code>s-</code> 封装器是仅有的可以把子表达式作为结尾的可组合片段：<code>and_v(X,Y) =&gt; [X] [Y]</code> 和 <code>s:X =&gt; SWAP [X]</code>，所以，它们会直接获得来自子节点的特性。脚本中的哈希片段和 <code>thresh</code>&#x2F;<code>multi</code>&#x2F;<code>c</code> 最终都会以 <code>EQUAL</code>&#x2F;<code>CHECKSIG</code>&#x2F;<code>CHECKMULTISIG</code> 结尾，例如 <code>c:X =&gt; [X] CHECKSIG</code>。这些是将被分解为这些操作符的 <code>VERIFY</code> 版本的候选。</p><p>然后，我们可以修改我们的<code>scriptStr</code> 函数，在允许的时候使用操作符的 <code>VERIFY</code> 版本。为了简洁，我们只在下面展示了两种情形。你可以在<a target=_blank rel=noopener href=https://go.dev/play/p/8vgjWXV3CJ1>这个网站</a>上看到和运行完整的版本。</p><pre><code class=go>// collapseVerify is true if the `v` wrapper (VERIFY wrapper) is an ancestor of the node. If so, the
// two opcodes `OP_CHECKSIG VERIFY` can be collapsed into one opcode `OP_CHECKSIGVERIFY` (same for
// OP_EQUAL and OP_CHECKMULTISIG).
func scriptStr(node *AST, collapseVerify bool) string &#123;
    switch node.identifier &#123;
     // [...]
    case f_wrap_c:
        opVerify := &quot;CHECKSIG&quot;
        if node.props.canCollapseVerify &amp;&amp; collapseVerify &#123;
            opVerify = &quot;CHECKSIGVERIFY&quot;
        &#125;
        return fmt.Sprintf(&quot;%s %s&quot;,
            scriptStr(node.args[0], collapseVerify),
            opVerify,
        )
     // [...]
    case f_wrap_v:
        s := scriptStr(node.args[0], true)
        if !node.args[0].props.canCollapseVerify &#123;
            s += &quot; VERIFY&quot;
        &#125;
        return s

&#125;
</code></pre><p>使用修改后的函数运行程序，你会得到这样的输出：</p><pre><code>&lt;pubkey1&gt; CHECKSIG IFDUP NOTIF &lt;pubkey2&gt; CHECKSIGVERIFY &lt;52560&gt; CHECKSEQUENCEVERIFY ENDIF
</code></pre><p>成功将 <code>CHECKSIG VERITY</code> 简化为 <code>CHECKSIGVERIFY</code>。</p><h2 id=第七步：生成收款地址><a href=#第七步：生成收款地址 class=headerlink title=第七步：生成收款地址></a>第七步：生成收款地址</h2><p><a target=_blank rel=noopener href=https://go.dev/play/p/KOW8OcfGspY>点击此处，在线上 Go 环境中运行代码</a></p><p>在上一个接种，我们为比特币脚本创建了一个可读的表示。为了生成一个 P2WSH 地址，我们需要开发出实际的、作为字节序列的脚本，然后编码成一个地址。</p><p>为此，我们先要将公钥和哈希值变量替换成真实的公钥和哈希值。我们为 AST 增加一个新的字段：<code>value</code>。</p><pre><code class=go>type AST struct &#123;
    // [...]
    identifier string
    // For key arguments, this will be the 33 bytes compressed pubkey.
    // For hash arguments, this will be the 32 bytes (sha256, hash256) or 20 bytes (ripemd160, hash160) hash.
    value []byte
    args  []*AST
&#125;
</code></pre><p>现在，我们可以增加一个新的函数 <code>ApplyVars</code>，它会将 Miniscript 表达式中的所有变量都替换成真实的数值。调用者可以提供一个回调函数来提供这些数值。</p><p>Miniscript 也指明公钥不可重复（可以简化脚本的分析），所以我们要检查复制。</p><pre><code class=go>// ApplyVars replaces key and hash values in the miniscript.
//
// The callback should return `nil, nil` if the variable is unknown. In this case, the identifier
// itself will be parsed as the value (hex-encoded pubkey, hex-encoded hash value).
func (a *AST) ApplyVars(lookupVar func(identifier string) ([]byte, error)) error &#123;
    // Set of all pubkeys to check for duplicates
    allPubKeys := map[string]struct&#123;&#125;&#123;&#125;

    _, err := a.apply(func(node *AST) (*AST, error) &#123;
        switch node.identifier &#123;
        case f_pk_k, f_pk_h, f_multi:
            var keyArgs []*AST
            if node.identifier == f_multi &#123;
                keyArgs = node.args[1:]
            &#125; else &#123;
                keyArgs = node.args[:1]
            &#125;
            for _, arg := range keyArgs &#123;
                key, err := lookupVar(arg.identifier)
                if err != nil &#123;
                    return nil, err
                &#125;
                if key == nil &#123;
                    // If the key was not a variable, assume it&#39;s the key value directly encoded as
                    // hex.
                    key, err = hex.DecodeString(arg.identifier)
                    if err != nil &#123;
                        return nil, err
                    &#125;
                &#125;
                if len(key) != pubKeyLen &#123;
                    return nil, fmt.Errorf(&quot;pubkey argument of %s expected to be of size %d, but got %d&quot;,
                        node.identifier, pubKeyLen, len(key))
                &#125;

                pubKeyHex := hex.EncodeToString(key)
                if _, ok := allPubKeys[pubKeyHex]; ok &#123;
                    return nil, fmt.Errorf(
                        &quot;duplicate key found at %s (key=%s, arg identifier=%s)&quot;,
                        node.identifier, pubKeyHex, arg.identifier)
                &#125;
                allPubKeys[pubKeyHex] = struct&#123;&#125;&#123;&#125;

                arg.value = key
            &#125;
        case f_sha256, f_hash256, f_ripemd160, f_hash160:
            arg := node.args[0]
            hashLen := map[string]int&#123;
                f_sha256:    32,
                f_hash256:   32,
                f_ripemd160: 20,
                f_hash160:   20,
            &#125;[node.identifier]
            hashValue, err := lookupVar(arg.identifier)
            if err != nil &#123;
                return nil, err
            &#125;
            if hashValue == nil &#123;
                // If the hash value was not a variable, assume it&#39;s the hash value directly encoded
                // as hex.
                hashValue, err = hex.DecodeString(node.args[0].identifier)
                if err != nil &#123;
                    return nil, err
                &#125;
            &#125;
            if len(hashValue) != hashLen &#123;
                return nil, fmt.Errorf(&quot;%s len must be %d, got %d&quot;, node.identifier, hashLen, len(hashValue))
            &#125;
            arg.value = hashValue
        &#125;
        return node, nil
    &#125;)
    return err
&#125;
</code></pre><p>看看它的实际情况：</p><pre><code class=go>func main() &#123;
    node, err := Parse(&quot;or_d(pk(pubkey1),and_v(v:pk(pubkey2),older(52560)))&quot;)
    if err != nil &#123;
        panic(err)
    &#125;
    unhex := func(s string) []byte &#123;
        b, _ := hex.DecodeString(s)
        return b
    &#125;

    // Two arbitrary pubkeys.
    _, pubKey1 := btcec.PrivKeyFromBytes(
        unhex(&quot;2c3931f593f26037a8b8bf837363831b18bbfb91a712dd9d862db5b9b06dc5df&quot;))
    _, pubKey2 := btcec.PrivKeyFromBytes(
        unhex(&quot;f902f94da618721e516d0a2a2666e2ec37079aaa184ee5a2c00c835c5121b3eb&quot;))

    err = node.ApplyVars(func(identifier string) ([]byte, error) &#123;
        switch identifier &#123;
        case &quot;pubkey1&quot;:
            return pubKey1.SerializeCompressed(), nil
        case &quot;pubkey2&quot;:
            return pubKey2.SerializeCompressed(), nil
        &#125;
        return nil, nil
    &#125;)
    if err != nil &#123;
        panic(err)
    &#125;
    fmt.Println(node.DrawTree())
&#125;
</code></pre><p>输出，公钥已成功替换：</p><pre><code>or_d [B]
├──c [Bonduv]
|  └──pk_k [Kondu]
|        └──pubkey1 [03469d685c3445e83ee6e3cfb30382795c249c91955523c25f484d69379c7a7d6f]
└──and_v [Bon]
       ├──v [Von]
       |  └──c [Bonduv]
       |     └──pk_k [Kondu]
       |           └──pubkey2 [03ba991cc359438fdd8cf43e3cf7894f90cf4d0e040314a6bba82963fa77b7a434]
       └──older [Bz]
              └──52560
</code></pre><p>（我们修改 <code>drawTree()</code> 函数，以在每个变量旁边显示实际数值。）</p><p>有了这个绝妙的 <a target=_blank rel=noopener href=https://github.com/btcsuite/btcd>btcd</a> 库的帮助，我们现在可以构建出实际的脚本了。它看起来非常像上面的 <code>scriptStr()</code>，但将它编码成了一个字节串，关注于将整数和数据推入堆栈的实际问题。我们在这里使用了一个缩减版本。完整版本可见<a target=_blank rel=noopener href=https://go.dev/play/p/KOW8OcfGspY>这个网站</a>。</p><pre><code class=go>// Script creates the witness script from a parsed miniscript.
func (a *AST) Script() ([]byte, error) &#123;
    b := txscript.NewScriptBuilder()
    if err := buildScript(a, b, false); err != nil &#123;
        return nil, err
    &#125;
    return b.Script()
&#125;

// collapseVerify is true if the `v` wrapper (VERIFY wrapper) is an ancestor of the node. If so, the
// two opcodes `OP_CHECKSIG VERIFY` can be collapsed into one opcode `OP_CHECKSIGVERIFY` (same for
// OP_EQUAL and OP_CHECKMULTISIGVERIFY).
func buildScript(node *AST, b *txscript.ScriptBuilder, collapseVerify bool) error &#123;
    switch node.identifier &#123;
    case f_0:
        b.AddOp(txscript.OP_FALSE)
    case f_1:
        b.AddOp(txscript.OP_TRUE)
    case f_pk_h:
        arg := node.args[0]
        key := arg.value
        if key == nil &#123;
            return fmt.Errorf(&quot;empty key for %s (%s)&quot;, node.identifier, arg.identifier)
        &#125;
        b.AddOp(txscript.OP_DUP)
        b.AddOp(txscript.OP_HASH160)
        b.AddData(btcutil.Hash160(key))
        b.AddOp(txscript.OP_EQUALVERIFY)
    case f_older:
        b.AddInt64(int64(node.args[0].num))
        b.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)
    case f_after:
        b.AddInt64(int64(node.args[0].num))
        b.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)
    case f_and_b:
        if err := buildScript(node.args[0], b, collapseVerify); err != nil &#123;
            return err
        &#125;
        if err := buildScript(node.args[1], b, collapseVerify); err != nil &#123;
            return err
        &#125;
        b.AddOp(txscript.OP_BOOLAND)
    case f_wrap_c:
        if err := buildScript(node.args[0], b, collapseVerify); err != nil &#123;
            return err
        &#125;
        if node.props.canCollapseVerify &amp;&amp; collapseVerify &#123;
            b.AddOp(txscript.OP_CHECKSIGVERIFY)
        &#125; else &#123;
            b.AddOp(txscript.OP_CHECKSIG)
        &#125;
    case f_wrap_v:
        if err := buildScript(node.args[0], b, true); err != nil &#123;
            return err
        &#125;
        if !node.args[0].props.canCollapseVerify &#123;
            b.AddOp(txscript.OP_VERIFY)
        &#125;
    // More cases [...]
    default:
        return fmt.Errorf(&quot;unknown identifier: %s&quot;, node.identifier)
    &#125;
    return nil
&#125;
</code></pre><p>运行它吧：</p><pre><code class=go>func main() &#123;
    // [...]
    script, err := node.Script()
    if err != nil &#123;
        panic(err)
    &#125;
    fmt.Println(&quot;Script&quot;, hex.EncodeToString(script))
&#125;
</code></pre><p>输出：</p><pre><code>Script 2103469d685c3445e83ee6e3cfb30382795c249c91955523c25f484d69379c7a7d6fac73642103ba991cc359438fdd8cf43e3cf7894f90cf4d0e040314a6bba82963fa77b7a434ad0350cd00b268
</code></pre><p>根据 <a target=_blank rel=noopener href=https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki>BIP141</a> 和 <a target=_blank rel=noopener href=https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki>BIP173</a>，P2WSH 地址应该是 <code>0 &lt;sha256(script)&gt;</code> 的 bech32 编码，其中 <code>0</code> 表示隔离见证版本 0。我们将使用这个 btcd 库来帮助我们创建地址：</p><pre><code class=go>addr, err := btcutil.NewAddressWitnessScriptHash(chainhash.HashB(script), &amp;chaincfg.TestNet3Params)
if err != nil &#123;
       panic(err)
&#125;
fmt.Println(&quot;Address:&quot;, addr.String())
</code></pre><p>我们的测试网收款地址准备好了：</p><pre><code>Address: tb1q4q3cw0mausmamm7n7fn2phh0fpca4n0vmkc7rdh6hxnkz9rd8l0qcpefrj
</code></pre><p>这个地址收到的资金将使用花费条件 <code>or_d(pk(pubkey1),and_v(v:pk(pubkey2),older(52560)))</code> 锁定，即，公钥 1 可以随时花费；公钥 2 可以在资金进入这个地址的 52560 个区块（大约一年）后花费。</p><p><a target=_blank rel=noopener href=https://go.dev/play/p/KOW8OcfGspY>点击此处，在线上 Go 环境中运行代码</a></p><h2 id=结论><a href=#结论 class=headerlink title=结论></a>结论</h2><p>评论是，我们已经创建了一个 Miniscript 代码库，可以解析 Miniscript 表达式并执行类型检查，并生成收款地址。</p><p>还有很多情形需要考虑。在下一篇文章中，我们将学习如何根据 Miniscript 表达式生成见证数据，从而可以花费资金；如何保证 Miniscript 遵守比特币的共识以及标准，例如脚本的体积和操作符限制。</p><p>如果你希望这个系列继续，请在 Twitter 上告诉我：<a target=_blank rel=noopener href=https://twitter.com/_benma_>@<em>benma</em></a>。</p></article></div></div></main><script src="/js/post.js?v=1682773100887"></script><script src="/js/highlight.min.js?v=1682773100887"></script><script>var containerEl=document.querySelector(".post-container"),postFontSize=localStorage.getItem("post-font-size")||"16",inputEl=document.querySelector("#size-change-input"),inputEl2=document.querySelector("#size-change-input2");inputEl.value=postFontSize,inputEl2.value=postFontSize,containerEl.style.fontSize=postFontSize+"px",$(function(){function e(t){$(".post-container").css("font-size",t+"px"),localStorage.setItem("post-font-size",t),$("#size-change-input").val(t),$("#size-change-input2").val(t)}$("#size-change-input").on("input propertychange",function(t){e(t.target.value)}),$("#size-change-input2").on("input propertychange",function(t){e(t.target.value)})})</script><script>hljs.initHighlightingOnLoad()</script></main></div><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0"><section class=sns-container><a title=nostr target=_blank rel="noopener nofollow" href=https://iris.to/npub1g2qs0ca5kpwlrcfug2em4jelmh65clk3yccwjxrs6hvdpd9qj80q022j4m>Nostr</a><a title=rss target=_blank rel="noopener nofollow" href=/atom.xml>rss</a><a title=telegram target=_blank rel="noopener nofollow" href=//t.me/btcstudyorg>Telegram</a></section></footer><script async src="/js/buttons.js?v=1682773100887"></script><script async src="/js/index.js?v=1682773100887"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-JVCJ9XXG1Z"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-JVCJ9XXG1Z")</script><script>var _hmt=_hmt||[];(()=>{var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?c92c073c85be5be8d9b1b76f62a7e306",e.async=!0,e.defer=!0,document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)})()</script></body></html>